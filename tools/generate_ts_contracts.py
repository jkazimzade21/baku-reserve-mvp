#!/usr/bin/env python3
"""Generate TypeScript contract types from the OpenAPI schema."""
from __future__ import annotations

import json
from pathlib import Path
from typing import Any

OPENAPI_PATH = Path("artifacts/openapi.json")
OUTPUT_PATH = Path("mobile/src/types/server.d.ts")
TARGET_SCHEMAS = [
    "RestaurantListItem",
    "Restaurant",
    "Area",
    "Table",
    "Reservation",
    "ReservationCreate",
    "ArrivalIntent",
    "ArrivalIntentRequest",
    "ArrivalIntentDecision",
    "ArrivalLocationPing",
    "ArrivalEtaConfirmation",
    "ArrivalLocationSuggestion",
]


def load_openapi() -> dict[str, Any]:
    if not OPENAPI_PATH.exists():
        raise SystemExit(
            f"OpenAPI schema not found at {OPENAPI_PATH}. Run export_openapi.py first."
        )
    data = json.loads(OPENAPI_PATH.read_text(encoding="utf-8"))
    schemas = data.get("components", {}).get("schemas", {})
    if not schemas:
        raise SystemExit("OpenAPI schema missing components.schemas block")
    return schemas


def ts_literal(value: Any) -> str:
    if isinstance(value, str):
        return json.dumps(value)
    if isinstance(value, bool):
        return "true" if value else "false"
    if value is None:
        return "null"
    return str(value)


def ts_type(schema: dict[str, Any], schemas: dict[str, Any]) -> str:
    if "$ref" in schema:
        return schema["$ref"].split("/")[-1]

    if "allOf" in schema:
        return " & ".join(ts_type(part, schemas) for part in schema["allOf"])
    if "oneOf" in schema:
        return " | ".join(ts_type(part, schemas) for part in schema["oneOf"])
    if "anyOf" in schema:
        return " | ".join(ts_type(part, schemas) for part in schema["anyOf"])

    schema_type = schema.get("type")
    if schema_type == "array":
        prefix_items = schema.get("prefixItems")
        if isinstance(prefix_items, list) and prefix_items:
            parts = [ts_type(item, schemas) for item in prefix_items]
            additional = schema.get("items")
            if additional:
                parts.append(f"...{ts_type(additional, schemas)}[]")
            return "[" + ", ".join(parts) + "]"
        return f"{ts_type(schema.get('items', {'type': 'unknown'}), schemas)}[]"
    if schema_type == "object":
        props = schema.get("properties") or {}
        if not props:
            additional = schema.get("additionalProperties")
            if additional:
                return f"Record<string, {ts_type(additional, schemas)}>"
            return "Record<string, unknown>"
        required = set(schema.get("required", []))
        parts = []
        for key, prop_schema in props.items():
            optional = "?" if key not in required else ""
            prop_type = ts_type(prop_schema, schemas)
            parts.append(f"  {key}{optional}: {prop_type};")
        return "{\n" + "\n".join(parts) + "\n}"
    if schema_type == "string":
        if "enum" in schema:
            return " | ".join(ts_literal(item) for item in schema["enum"])
        return "string"
    if schema_type == "integer" or schema_type == "number":
        return "number"
    if schema_type == "boolean":
        return "boolean"
    if schema_type == "null":
        return "null"

    if "enum" in schema:
        return " | ".join(ts_literal(item) for item in schema["enum"])

    return "unknown"


def build_interface(name: str, schema: dict[str, Any], schemas: dict[str, Any]) -> str:
    body = ts_type(schema, schemas)
    if not body.startswith("{"):
        # Primitive alias
        return f"export type {name} = {body};\n"
    return f"export interface {name} {body}\n"


def main() -> None:
    schemas = load_openapi()
    lines = [
        "// AUTO-GENERATED by tools/generate_ts_contracts.py",
        "// Do not edit manually; run `npm run generate:api-types` instead.\n",
    ]
    for name in TARGET_SCHEMAS:
        schema = schemas.get(name)
        if not schema:
            print(f"[generate_ts_contracts] Skipping missing schema: {name}")
            continue
        lines.append(build_interface(name, schema, schemas))
    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_PATH.write_text("\n".join(lines), encoding="utf-8")
    print(f"[generate_ts_contracts] Wrote {OUTPUT_PATH}")


if __name__ == "__main__":
    main()
