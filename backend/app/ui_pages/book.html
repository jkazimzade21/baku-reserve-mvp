<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Baku Reserve – Book a Table</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --page-bg: linear-gradient(140deg, #0ea5e9 0%, #818cf8 24%, #f8fafc 100%);
      --panel-bg: rgba(255, 255, 255, 0.94);
      --border: rgba(148, 163, 184, 0.28);
      --accent: #0f766e;
      --accent-strong: #0ea5e9;
      --accent-soft: rgba(14, 165, 233, 0.1);
      --danger: #b91c1c;
      --text: #0f172a;
      --muted: #475569;
      --shadow: 0 24px 48px -28px rgba(15, 23, 42, 0.55);
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--page-bg);
      color: var(--text);
      line-height: 1.5;
    }
    a {
      color: inherit;
      text-decoration: none;
    }
    .topbar {
      position: sticky;
      top: 0;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 32px;
      background: rgba(15, 23, 42, 0.78);
      color: #fff;
      backdrop-filter: blur(14px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 12px 28px -18px rgba(15, 23, 42, 0.65);
    }
    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    .brand-mark {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.15);
      font-size: 18px;
      font-weight: 700;
    }
    .nav {
      display: flex;
      gap: 20px;
      align-items: center;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .nav-link {
      position: relative;
      padding-bottom: 4px;
      color: rgba(255, 255, 255, 0.82);
      transition: color 0.2s ease;
    }
    .nav-link::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 2px;
      background: rgba(255, 255, 255, 0.45);
      border-radius: 999px;
      transform: scaleX(0);
      transform-origin: center;
      transition: transform 0.2s ease;
    }
    .nav-link:hover {
      color: #fff;
    }
    .nav-link:hover::after,
    .nav-link.active::after {
      transform: scaleX(1);
    }
    main.page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px 24px 64px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    h1, h2, h3 {
      margin: 0;
      font-weight: 600;
      letter-spacing: -0.01em;
    }
    p {
      margin: 8px 0 0;
      color: var(--muted);
    }
    .panel {
      background: var(--panel-bg);
      border-radius: 20px;
      padding: 24px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    .intro {
      display: grid;
      gap: 8px;
    }
    .intro h1 {
      font-size: 32px;
    }
    .meta {
      font-size: 13px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .controls-grid {
      display: grid;
      gap: 16px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: flex-end;
    }
    label {
      font-size: 14px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 160px;
      font-weight: 500;
      color: var(--muted);
    }
    select, input, button {
      font-size: 15px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      font-family: inherit;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }
    select:focus, input:focus {
      outline: none;
      border-color: var(--accent-strong);
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2);
    }
    .button {
      cursor: pointer;
      border: none;
      color: #fff;
      background: var(--accent);
      font-weight: 600;
      letter-spacing: 0.02em;
      padding: 10px 18px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }
    .button.secondary {
      background: #111827;
    }
    .button.ghost {
      background: rgba(15, 23, 42, 0.08);
      color: var(--text);
    }
    .button.ghost:hover {
      background: rgba(15, 23, 42, 0.12);
    }
    .button.danger {
      background: var(--danger);
    }
    .button:hover {
      filter: brightness(1.05);
    }
    .stack {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .space-between {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }
    .date-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      font-size: 14px;
      color: var(--muted);
    }
    .toggle input {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    .status {
      padding: 14px 18px;
      border-radius: 14px;
      font-weight: 500;
      display: none;
      border: 1px solid transparent;
    }
    .status.info {
      display: block;
      background: rgba(14, 165, 233, 0.1);
      color: #0369a1;
      border-color: rgba(14, 165, 233, 0.25);
    }
    .status.success {
      display: block;
      background: rgba(16, 185, 129, 0.1);
      color: #047857;
      border-color: rgba(16, 185, 129, 0.2);
    }
    .status.error {
      display: block;
      background: rgba(248, 113, 113, 0.12);
      color: #b91c1c;
      border-color: rgba(248, 113, 113, 0.28);
    }
    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
    }
    .metric {
      padding: 16px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.03);
      border: 1px solid rgba(148, 163, 184, 0.25);
      display: grid;
      gap: 4px;
    }
    .metric .label {
      font-size: 13px;
      letter-spacing: 0.04em;
      color: var(--muted);
      text-transform: uppercase;
    }
    .metric .value {
      font-size: 24px;
      font-weight: 600;
    }
    .split-grid {
      display: grid;
      grid-template-columns: 1fr minmax(0, 1.2fr);
      gap: 20px;
    }
    .restaurant-card {
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      overflow: hidden;
      background: #fff;
      box-shadow: 0 16px 28px -28px rgba(15, 23, 42, 0.65);
    }
    .restaurant-card img {
      width: 100%;
      height: 220px;
      object-fit: cover;
    }
    .restaurant-card .body {
      padding: 20px;
      display: grid;
      gap: 12px;
    }
    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .chip {
      display: inline-flex;
      align-items: center;
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--accent);
      font-size: 13px;
      font-weight: 500;
      letter-spacing: 0.02em;
    }
    .slot-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
    }
    .slot-card {
      background: rgba(15, 23, 42, 0.03);
      border-radius: 16px;
      padding: 18px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      display: grid;
      gap: 12px;
    }
    .slot-card h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    .slot-card .meta-line {
      font-size: 13px;
      color: var(--muted);
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    .slot-card .tables {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .slot-card .tables button {
      font-size: 13px;
      padding: 8px 12px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: #111827;
      color: #fff;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .slot-card .tables button:hover {
      filter: brightness(1.05);
    }
    .slot-card.active {
      border-color: rgba(14, 165, 233, 0.45);
      background: rgba(14, 165, 233, 0.12);
      box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.25);
    }
    .empty {
      text-align: center;
      padding: 28px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.03);
      border: 1px dashed rgba(148, 163, 184, 0.3);
      color: var(--muted);
      font-weight: 500;
    }
    .activity-feed {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 10px;
    }
    .activity-item {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 14px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.04);
      border: 1px solid rgba(148, 163, 184, 0.18);
      font-size: 14px;
    }
    .activity-item .time {
      font-family: "JetBrains Mono", "SFMono-Regular", ui-monospace, monospace;
      font-size: 12px;
      letter-spacing: 0.08em;
      color: var(--muted);
    }
    .activity-item.meta {
      background: rgba(14, 165, 233, 0.12);
      color: #075985;
    }
    .activity-item.error {
      background: rgba(248, 113, 113, 0.16);
      border-color: rgba(248, 113, 113, 0.4);
      color: #991b1b;
    }
    .seatmap-panel {
      display: grid;
      gap: 16px;
    }
    .seatmap-header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: flex-start;
      justify-content: space-between;
    }
    .seatmap-header h2 {
      margin-bottom: 4px;
    }
    .area-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .area-chip {
      border: none;
      cursor: pointer;
      padding: 6px 14px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.08);
      color: var(--text);
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.02em;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .area-chip:hover {
      background: rgba(15, 23, 42, 0.12);
    }
    .area-chip.active {
      background: var(--accent);
      color: #fff;
    }
    .area-chip:focus-visible {
      outline: 2px solid var(--accent-strong);
      outline-offset: 2px;
    }
    .seatmap-wrapper {
      position: relative;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: linear-gradient(135deg, rgba(14, 165, 233, 0.08), rgba(14, 165, 233, 0.02));
      overflow: hidden;
      min-height: 320px;
    }
    #seatMap {
      width: 100%;
      height: 360px;
      display: none;
    }
    .seatmap-wrapper .empty {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: transparent;
      border: none;
    }
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 13px;
      color: var(--muted);
    }
    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .legend .dot {
      width: 12px;
      height: 12px;
      border-radius: 4px;
      display: inline-block;
      border: 1px solid rgba(15, 23, 42, 0.18);
    }
    .legend .available .dot {
      background: rgba(16, 185, 129, 0.4);
      border-color: rgba(16, 185, 129, 0.6);
    }
    .legend .held .dot {
      background: rgba(148, 163, 184, 0.25);
      border-color: rgba(148, 163, 184, 0.4);
    }
    .legend .reserved .dot {
      background: rgba(248, 113, 113, 0.35);
      border-color: rgba(248, 113, 113, 0.55);
    }
    .legend .selected .dot {
      background: rgba(59, 130, 246, 0.45);
      border-color: rgba(59, 130, 246, 0.65);
    }
    .seatmap-footer {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }
    .selection-meta {
      font-size: 14px;
      font-weight: 500;
      color: var(--muted);
    }
    .seatmap-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: flex-end;
    }
    .seatmap-actions .button {
      min-width: 160px;
    }
    .seatmap-actions .button:disabled,
    button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      filter: grayscale(0.15);
    }
    .seat-group {
      cursor: pointer;
      transition: transform 0.2s ease, filter 0.2s ease;
    }
    .seat-group text {
      font-size: 2.6px;
      fill: #0f172a;
      text-anchor: middle;
      alignment-baseline: middle;
      pointer-events: none;
      font-weight: 600;
    }
    .seat-group.available path,
    .seat-group.available circle,
    .seat-group.available rect,
    .seat-group.available polygon {
      fill: rgba(16, 185, 129, 0.65);
      stroke: rgba(16, 185, 129, 0.9);
      stroke-width: 0.6;
    }
    .seat-group.held path,
    .seat-group.held circle,
    .seat-group.held rect,
    .seat-group.held polygon {
      fill: rgba(148, 163, 184, 0.35);
      stroke: rgba(148, 163, 184, 0.55);
      stroke-width: 0.6;
    }
    .seat-group.reserved path,
    .seat-group.reserved circle,
    .seat-group.reserved rect,
    .seat-group.reserved polygon {
      fill: rgba(248, 113, 113, 0.45);
      stroke: rgba(248, 113, 113, 0.75);
      stroke-width: 0.6;
    }
    .seat-group.selected path,
    .seat-group.selected circle,
    .seat-group.selected rect,
    .seat-group.selected polygon {
      fill: rgba(59, 130, 246, 0.7);
      stroke: rgba(37, 99, 235, 0.85);
      stroke-width: 0.8;
      filter: drop-shadow(0 0 4px rgba(37, 99, 235, 0.35));
    }
    .seat-group.disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }
    .seat-group:hover {
      transform: translate(0, 0) scale(1.04);
    }
    .seatmap-wrapper svg {
      width: 100%;
      height: 100%;
      display: none;
    }
    .seat-landmark {
      fill: rgba(15, 23, 42, 0.08);
      stroke: rgba(15, 23, 42, 0.22);
      stroke-width: 0.4;
    }
    .seat-landmark text {
      font-size: 2.2px;
      fill: rgba(15, 23, 42, 0.65);
      text-anchor: middle;
      pointer-events: none;
    }
    .seat-landmark-label {
      font-size: 2.2px;
      fill: rgba(15, 23, 42, 0.65);
      text-anchor: middle;
      pointer-events: none;
      font-weight: 600;
    }
    .seat-label {
      font-size: 2.6px;
      fill: rgba(15, 23, 42, 0.82);
      font-weight: 600;
      text-anchor: middle;
      alignment-baseline: middle;
      pointer-events: none;
    }
    .status-row {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #slotSummary {
      font-size: 13px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--muted);
    }
    @media (max-width: 900px) {
      .split-grid {
        grid-template-columns: 1fr;
      }
      .topbar {
        padding: 16px 20px;
      }
      main.page {
        padding: 24px 16px 56px;
      }
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <span class="brand-mark">BR</span>
      <span>Baku Reserve</span>
    </div>
    <nav class="nav">
      <a class="nav-link active" href="/book/">Book</a>
      <a class="nav-link" href="/admin/">Admin</a>
      <a class="nav-link" href="/docs">API Docs</a>
    </nav>
  </header>

  <main class="page">
    <section class="panel intro">
      <div class="space-between">
        <div>
          <h1 id="heroTitle">Plan the perfect service</h1>
          <p>Explore live availability, place bookings, and share curated time slots directly from the Baku Reserve API.</p>
        </div>
        <div class="meta">Last refreshed · <span id="lastUpdated">Never</span></div>
      </div>
    </section>

    <section class="panel controls-grid">
      <h2>Search &amp; filters</h2>
      <div class="controls">
        <label>
          Restaurant
          <select id="restaurantSelect"></select>
        </label>
        <label>
          Date
          <input type="date" id="dateInput" />
        </label>
        <label>
          Party size
          <input type="number" id="partyInput" min="1" max="20" />
        </label>
        <label>
          Guest name
          <input type="text" id="guestName" placeholder="Guest name" />
        </label>
        <label>
          Guest phone
          <input type="tel" id="guestPhone" placeholder="+994..." />
        </label>
      </div>
      <div class="space-between">
        <div class="date-controls">
          <button id="prevDayBtn" type="button" class="button ghost">Previous day</button>
          <button id="todayBtn" type="button" class="button ghost">Today</button>
          <button id="nextDayBtn" type="button" class="button ghost">Next day</button>
          <button id="refreshBtn" class="button secondary" type="button">Refresh availability</button>
        </div>
        <div class="stack">
          <label class="toggle">
            <input type="checkbox" id="autoRefreshToggle" />
            <span>Auto-refresh every 60&nbsp;s</span>
          </label>
          <button id="downloadBtn" type="button" class="button ghost">Download JSON</button>
          <button id="copyLinkBtn" type="button" class="button ghost">Copy share link</button>
        </div>
      </div>
    </section>

    <div class="status-row">
      <div id="status" class="status info" role="status">Loading…</div>
      <span id="slotSummary"></span>
    </div>

    <section class="panel metrics" id="snapshot">
      <div class="empty">Load availability to see live restaurant insights.</div>
    </section>

    <div class="split-grid">
      <section class="panel" id="restaurantPanel">
        <div class="space-between">
          <h2>Restaurant overview</h2>
          <span class="meta" id="restaurantMeta"></span>
        </div>
        <div id="restaurantInfo"></div>
      </section>

      <section class="panel seatmap-panel" id="seatPanel">
        <div class="seatmap-header">
          <div>
            <h2>Seat map</h2>
            <p class="meta" id="seatMapSubtitle">Select an availability slot to preview the floor plan.</p>
          </div>
          <div id="areaTabs" class="area-tabs"></div>
        </div>
        <div class="seatmap-wrapper">
          <svg id="seatMap" viewBox="0 0 100 100" role="img" aria-label="Seat map"></svg>
          <div id="seatMapEmpty" class="empty">Choose an availability slot to load the floor plan.</div>
        </div>
        <div class="seatmap-footer">
          <div id="seatLegend" class="legend"></div>
          <div id="seatSelectionMeta" class="selection-meta">No slot selected yet.</div>
        </div>
        <div class="seatmap-actions">
          <button type="button" id="clearSelectionBtn" class="button ghost" disabled>Clear selection</button>
          <button type="button" id="bookSelectionBtn" class="button" disabled>Book selected table</button>
        </div>
      </section>
    </div>

    <section class="panel" id="availabilityPanel">
      <div class="space-between">
        <h2>Availability</h2>
        <span class="meta" id="availabilityMeta">Waiting for data…</span>
      </div>
      <div id="availability" class="slot-grid"></div>
    </section>

    <section class="panel">
      <div class="space-between">
        <h2>Activity feed</h2>
        <span class="meta">Latest six actions</span>
      </div>
      <ul id="activityList" class="activity-feed">
        <li class="activity-item meta"><span class="time">--:--</span><span class="message">Ready when you are.</span></li>
      </ul>
    </section>
  </main>

  <script>
    const defaultParty = 2;
    const state = {
      rid: null,
      date: null,
      party: defaultParty,
      restaurants: [],
      lastSlots: [],
      usableSlots: [],
      restaurantDetail: null,
      normalizedAreas: [],
      areaById: new Map(),
      tableById: new Map(),
      activeAreaId: null,
      selectedSlotIndex: null,
      selectedSlotStart: null,
      selectedSlot: null,
      selectedTableId: null
    };

    const params = new URLSearchParams(window.location.search);
    const restaurantSelect = document.getElementById('restaurantSelect');
    const dateInput = document.getElementById('dateInput');
    const partyInput = document.getElementById('partyInput');
    const refreshBtn = document.getElementById('refreshBtn');
    const guestNameInput = document.getElementById('guestName');
    const guestPhoneInput = document.getElementById('guestPhone');
    const statusEl = document.getElementById('status');
    const slotSummaryEl = document.getElementById('slotSummary');
    const availabilityEl = document.getElementById('availability');
    const restaurantInfoEl = document.getElementById('restaurantInfo');
    const restaurantMetaEl = document.getElementById('restaurantMeta');
    const availabilityMetaEl = document.getElementById('availabilityMeta');
    const snapshotEl = document.getElementById('snapshot');
    const activityList = document.getElementById('activityList');
    const lastUpdatedEl = document.getElementById('lastUpdated');
    const prevDayBtn = document.getElementById('prevDayBtn');
    const nextDayBtn = document.getElementById('nextDayBtn');
    const todayBtn = document.getElementById('todayBtn');
    const autoRefreshToggle = document.getElementById('autoRefreshToggle');
    const downloadBtn = document.getElementById('downloadBtn');
    const copyLinkBtn = document.getElementById('copyLinkBtn');
    const heroTitle = document.getElementById('heroTitle');
    const seatMapSvg = document.getElementById('seatMap');
    const seatMapEmpty = document.getElementById('seatMapEmpty');
    const areaTabsEl = document.getElementById('areaTabs');
    const seatLegendEl = document.getElementById('seatLegend');
    const seatSelectionMetaEl = document.getElementById('seatSelectionMeta');
    const seatMapSubtitleEl = document.getElementById('seatMapSubtitle');
    const clearSelectionBtn = document.getElementById('clearSelectionBtn');
    const bookSelectionBtn = document.getElementById('bookSelectionBtn');

    let autoRefreshHandle = 0;

    function formatClock(dateObj) {
      return dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function logActivity(message, tone = 'info') {
      const li = document.createElement('li');
      li.className = `activity-item ${tone}`;
      const time = document.createElement('span');
      time.className = 'time';
      time.textContent = formatClock(new Date());
      const msg = document.createElement('span');
      msg.className = 'message';
      msg.textContent = message;
      li.appendChild(time);
      li.appendChild(msg);
      activityList.insertBefore(li, activityList.firstChild);
      while (activityList.children.length > 6) {
        activityList.removeChild(activityList.lastChild);
      }
    }

    function setStatus(message, type = 'info') {
      statusEl.textContent = message;
      statusEl.className = `status ${type}`;
      statusEl.style.display = message ? 'block' : 'none';
    }

    function syncQuery() {
      const p = new URLSearchParams();
      if (state.rid) p.set('rid', state.rid);
      if (state.date) p.set('date', state.date);
      if (state.party) p.set('party', String(state.party));
      const query = p.toString();
      const nextUrl = query ? `${window.location.pathname}?${query}` : window.location.pathname;
      history.replaceState(null, '', nextUrl);
    }

    async function fetchJson(path, options) {
      const response = await fetch(path, options);
      if (!response.ok) {
        let detail = response.statusText;
        try {
          const payload = await response.json();
          if (payload && payload.detail) {
            if (typeof payload.detail === 'string') {
              detail = payload.detail;
            } else if (Array.isArray(payload.detail)) {
              detail = payload.detail.map((d) => d.msg || JSON.stringify(d)).join(', ');
            }
          }
        } catch (err) {
          // ignore parse errors
        }
        throw new Error(`${detail} (status ${response.status})`);
      }
      return response.json();
    }

    const SVG_NS = 'http://www.w3.org/2000/svg';
    const OUTPUT_MIN = 8;
    const OUTPUT_MAX = 92;
    const OUTPUT_RANGE = OUTPUT_MAX - OUTPUT_MIN;

    function clonePoint(point) {
      if (!Array.isArray(point) || point.length < 2) {
        return null;
      }
      const nx = Number(point[0]);
      const ny = Number(point[1]);
      if (!Number.isFinite(nx) || !Number.isFinite(ny)) {
        return null;
      }
      return [nx, ny];
    }

    function collectTablePoints(table) {
      if (!table || typeof table !== 'object') return [];
      const points = [];
      const push = (pt) => {
        const clone = clonePoint(pt);
        if (clone) points.push(clone);
      };
      push(table.position);
      if (Array.isArray(table.footprint)) {
        table.footprint.forEach(push);
      }
      const geometry = table.geometry && typeof table.geometry === 'object' ? table.geometry : null;
      if (geometry) {
        push(geometry.position);
        push(geometry.hotspot);
        if (Array.isArray(geometry.footprint)) {
          geometry.footprint.forEach(push);
        }
      }
      return points;
    }

    function collectLandmarkPoints(landmark) {
      if (!landmark || typeof landmark !== 'object') return [];
      const points = [];
      const push = (pt) => {
        const clone = clonePoint(pt);
        if (clone) points.push(clone);
      };
      push(landmark.position);
      if (Array.isArray(landmark.footprint)) {
        landmark.footprint.forEach(push);
      }
      return points;
    }

    function normalizeAreaGeometry(area) {
      if (!area) {
        return { id: '', name: '', tables: [] };
      }
      const tablesSource = Array.isArray(area.tables) ? area.tables : [];
      const landmarksSource = Array.isArray(area.landmarks) ? area.landmarks : [];
      const points = [];
      tablesSource.forEach((table) => {
        collectTablePoints(table).forEach((pt) => points.push(pt));
      });
      landmarksSource.forEach((lm) => {
        collectLandmarkPoints(lm).forEach((pt) => points.push(pt));
      });
      if (!points.length) {
        return {
          ...area,
          tables: tablesSource.map((table) => ({
            ...table,
            position: clonePoint(table.position) ?? table.position,
            footprint: Array.isArray(table.footprint)
              ? table.footprint.map((pt) => clonePoint(pt) ?? pt)
              : table.footprint,
            geometry: table.geometry && typeof table.geometry === 'object'
              ? {
                  ...table.geometry,
                  position: clonePoint(table.geometry.position) ?? table.geometry.position,
                  footprint: Array.isArray(table.geometry.footprint)
                    ? table.geometry.footprint.map((pt) => clonePoint(pt) ?? pt)
                    : table.geometry.footprint,
                  hotspot: clonePoint(table.geometry.hotspot) ?? table.geometry.hotspot,
                }
              : undefined,
          })),
          landmarks: landmarksSource.map((lm) => ({
            ...lm,
            position: clonePoint(lm.position) ?? lm.position,
            footprint: Array.isArray(lm.footprint)
              ? lm.footprint.map((pt) => clonePoint(pt) ?? pt)
              : lm.footprint,
          })),
        };
      }
      const xs = points.map((pt) => pt[0]);
      const ys = points.map((pt) => pt[1]);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const rangeX = maxX - minX;
      const rangeY = maxY - minY;
      const dominantRange = Math.max(rangeX, rangeY, 1);
      const scale = OUTPUT_RANGE / dominantRange;
      const scaledWidth = rangeX * scale;
      const scaledHeight = rangeY * scale;
      const paddingX = (OUTPUT_RANGE - scaledWidth) / 2;
      const paddingY = (OUTPUT_RANGE - scaledHeight) / 2;
      const normalizePoint = (point) => {
        const [x, y] = point;
        const normX = OUTPUT_MIN + paddingX + (rangeX === 0 ? 0 : (x - minX) * scale);
        const normY = OUTPUT_MIN + paddingY + (rangeY === 0 ? 0 : (y - minY) * scale);
        return [Number(normX), Number(normY)];
      };
      const normalizeMaybe = (point) => {
        const clone = clonePoint(point);
        return clone ? normalizePoint(clone) : undefined;
      };
      const normalizeFootprint = (footprint) => {
        if (!Array.isArray(footprint)) return undefined;
        const normalized = footprint
          .map((pt) => normalizeMaybe(pt))
          .filter((pt) => Array.isArray(pt));
        return normalized.length ? normalized : undefined;
      };
      const normalizedTables = tablesSource.map((table) => {
        const geometry = table && typeof table === 'object' ? table.geometry : undefined;
        const normalizedPosition =
          normalizeMaybe(table.position) ||
          normalizeMaybe(geometry?.position) ||
          normalizeMaybe(geometry?.hotspot);
        const normalizedFootprint =
          normalizeFootprint(table.footprint) || normalizeFootprint(geometry?.footprint);
        const normalizedGeometry =
          geometry && typeof geometry === 'object'
            ? {
                ...geometry,
                position:
                  normalizeMaybe(geometry.position) ||
                  normalizedPosition ||
                  geometry.position,
                footprint: normalizeFootprint(geometry.footprint) || geometry.footprint,
                hotspot: normalizeMaybe(geometry.hotspot) || geometry.hotspot,
              }
            : undefined;
        return {
          ...table,
          position: normalizedPosition || table.position,
          footprint: normalizedFootprint || table.footprint,
          geometry: normalizedGeometry,
        };
      });
      const normalizedLandmarks = landmarksSource.map((lm) => ({
        ...lm,
        position: normalizeMaybe(lm.position) || lm.position,
        footprint: normalizeFootprint(lm.footprint) || lm.footprint,
      }));
      return {
        ...area,
        tables: normalizedTables,
        landmarks: normalizedLandmarks,
      };
    }

    function hydrateLayoutAreas(areas) {
      state.normalizedAreas = Array.isArray(areas) ? areas.map((area) => normalizeAreaGeometry(area)) : [];
      state.areaById = new Map();
      state.tableById = new Map();
      state.normalizedAreas.forEach((area) => {
        state.areaById.set(area.id, area);
        (area.tables || []).forEach((table) => {
          state.tableById.set(table.id, {
            id: table.id,
            label: table.name || `Table ${String(table.id).slice(0, 6).toUpperCase()}`,
            capacity: Number(table.capacity) || 0,
            areaId: area.id,
            areaName: area.name,
            tags: Array.isArray(table.tags) ? table.tags : [],
            shape: table.shape,
          });
        });
      });
      if (!state.normalizedAreas.length) {
        state.activeAreaId = null;
      } else if (!state.normalizedAreas.some((area) => area.id === state.activeAreaId)) {
        state.activeAreaId = state.normalizedAreas[0].id;
      }
      renderAreaTabs();
      renderSeatMap();
    }

    function ensureActiveArea() {
      if (!state.normalizedAreas.length) {
        state.activeAreaId = null;
        return;
      }
      if (!state.activeAreaId || !state.areaById.has(state.activeAreaId)) {
        state.activeAreaId = state.normalizedAreas[0]?.id || null;
      }
    }

    function renderAreaTabs() {
      areaTabsEl.innerHTML = '';
      if (!state.normalizedAreas.length) {
        return;
      }
      ensureActiveArea();
      state.normalizedAreas.forEach((area) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = `area-chip${state.activeAreaId === area.id ? ' active' : ''}`;
        button.textContent = area.name || 'Area';
        button.dataset.areaId = area.id;
        button.addEventListener('click', () => setActiveArea(area.id, { user: true }));
        button.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            setActiveArea(area.id, { user: true });
          }
        });
        areaTabsEl.appendChild(button);
      });
    }

    function setActiveArea(areaId, opts = {}) {
      if (!areaId || areaId === state.activeAreaId || !state.areaById.has(areaId)) {
        return;
      }
      state.activeAreaId = areaId;
      renderAreaTabs();
      renderSeatMap();
      if (opts.user) {
        const area = state.areaById.get(areaId);
        if (area) {
          logActivity(`Viewing ${area.name || 'selected'} area layout`, 'meta');
        }
      }
    }

    function getSeatStatus(table, availableSet) {
      if (!table || !table.id) return 'held';
      if (state.selectedTableId && state.selectedTableId === table.id) {
        return 'selected';
      }
      if (availableSet.has(table.id)) {
        return 'available';
      }
      const capacity = Number(table.capacity) || 0;
      if (capacity && capacity < state.party) {
        return 'held';
      }
      return 'reserved';
    }

    function buildSeatGroup(table, status) {
      if (!table || !table.id) return null;
      const position =
        (Array.isArray(table.position) && table.position) ||
        (table.geometry && Array.isArray(table.geometry.position) && table.geometry.position);
      const centre = clonePoint(position);
      if (!centre) {
        return null;
      }
      const [cx, cy] = centre;
      const group = document.createElementNS(SVG_NS, 'g');
      group.classList.add('seat-group', status);
      if (status !== 'available' && status !== 'selected') {
        group.classList.add('disabled');
      }
      group.dataset.tableId = table.id;
      group.setAttribute('role', 'button');
      group.setAttribute('tabindex', status === 'available' || status === 'selected' ? '0' : '-1');
      group.setAttribute('aria-pressed', status === 'selected' ? 'true' : 'false');
      group.setAttribute('aria-disabled', status === 'available' || status === 'selected' ? 'false' : 'true');
      group.setAttribute(
        'aria-label',
        `${table.name || `Table ${String(table.id).slice(0, 6).toUpperCase()}`} · seats ${table.capacity || '?'}`
      );

      const footprint =
        (Array.isArray(table.footprint) && table.footprint.length ? table.footprint : null) ||
        (table.geometry &&
          Array.isArray(table.geometry.footprint) &&
          table.geometry.footprint.length
          ? table.geometry.footprint
          : null);

      if (footprint) {
        const polygon = document.createElementNS(SVG_NS, 'polygon');
        polygon.setAttribute('points', footprint.map((pt) => pt.join(',')).join(' '));
        group.appendChild(polygon);
      } else if ((table.shape || '').toLowerCase() === 'circle') {
        const circle = document.createElementNS(SVG_NS, 'circle');
        const radius = Math.min(5.5, Math.max(3.2, (Number(table.capacity) || 2) * 0.9));
        circle.setAttribute('cx', String(cx));
        circle.setAttribute('cy', String(cy));
        circle.setAttribute('r', String(radius));
        group.appendChild(circle);
      } else {
        const rect = document.createElementNS(SVG_NS, 'rect');
        const width = Math.min(10, Math.max(6, (Number(table.capacity) || 2) * 1.8));
        const height = Math.min(8, Math.max(5, (Number(table.capacity) || 2) * 1.4));
        rect.setAttribute('x', String(cx - width / 2));
        rect.setAttribute('y', String(cy - height / 2));
        rect.setAttribute('width', String(width));
        rect.setAttribute('height', String(height));
        rect.setAttribute('rx', '1.8');
        rect.setAttribute('ry', '1.8');
        group.appendChild(rect);
      }

      const label = document.createElementNS(SVG_NS, 'text');
      label.setAttribute('x', String(cx));
      label.setAttribute('y', String(cy));
      label.classList.add('seat-label');
      label.textContent = table.name || String(table.id).slice(0, 4).toUpperCase();
      group.appendChild(label);

      group.addEventListener('click', (event) => {
        event.preventDefault();
        handleSeatSelection(table, status);
      });
      group.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          handleSeatSelection(table, status);
        }
      });
      return group;
    }

    function renderSeatLegend(counts) {
      const entries = [
        { key: 'available', label: `${counts.available || 0} available` },
        { key: 'held', label: `${counts.held || 0} held` },
        { key: 'reserved', label: `${counts.reserved || 0} reserved` },
        { key: 'selected', label: `${counts.selected || 0} selected` },
      ];
      seatLegendEl.innerHTML = entries
        .map((entry) => `<span class="${entry.key}"><span class="dot"></span>${entry.label}</span>`)
        .join('');
    }

    function updateSeatSelectionMeta() {
      if (!state.selectedSlot) {
        seatSelectionMetaEl.textContent = 'Select an availability slot to preview tables.';
        return;
      }
      const slotLabel = `${formatTime(state.selectedSlot.start)} → ${formatTime(state.selectedSlot.end)}`;
      const availableCount = (state.selectedSlot.available_table_ids || []).length;
      if (!availableCount) {
        seatSelectionMetaEl.textContent = `${slotLabel} · Fully booked for party of ${state.party}.`;
        return;
      }
      if (!state.selectedTableId) {
        seatSelectionMetaEl.textContent = `${slotLabel} · ${availableCount} table${availableCount === 1 ? '' : 's'} open. Select a table to preview details.`;
        return;
      }
      const tableInfo = state.tableById.get(state.selectedTableId);
      seatSelectionMetaEl.textContent = `${slotLabel} · ${tableInfo?.label || state.selectedTableId} selected · seats ${tableInfo?.capacity ?? '?'}.`;
    }

    function updateSeatMapSubtitle() {
      if (!state.selectedSlot) {
        seatMapSubtitleEl.textContent = 'Select an availability slot to preview the floor plan.';
        return;
      }
      seatMapSubtitleEl.textContent = `Viewing ${formatTime(state.selectedSlot.start)} → ${formatTime(state.selectedSlot.end)} · party ${state.party}`;
    }

    function updateSelectionButtons() {
      clearSelectionBtn.disabled = !state.selectedTableId;
      bookSelectionBtn.disabled = !(state.selectedSlot && state.selectedTableId);
    }

    function renderSeatMap() {
      if (!state.normalizedAreas.length) {
        seatMapSvg.innerHTML = '';
        seatMapSvg.style.display = 'none';
        seatMapSvg.setAttribute('aria-hidden', 'true');
        seatMapEmpty.style.display = 'grid';
        seatMapEmpty.textContent = 'Seat map not available for this restaurant.';
        seatLegendEl.innerHTML = '';
        updateSeatSelectionMeta();
        updateSelectionButtons();
        seatMapSubtitleEl.textContent = 'Seat map unavailable for this restaurant.';
        return;
      }
      if (!state.selectedSlot) {
        seatMapSvg.innerHTML = '';
        seatMapSvg.style.display = 'none';
        seatMapSvg.setAttribute('aria-hidden', 'true');
        seatMapEmpty.style.display = 'grid';
        seatMapEmpty.textContent = 'Select an availability slot to load the floor plan.';
        seatLegendEl.innerHTML = '';
        updateSeatSelectionMeta();
        updateSelectionButtons();
        updateSeatMapSubtitle();
        return;
      }
      ensureActiveArea();
      renderAreaTabs();
      const area = state.areaById.get(state.activeAreaId);
      if (!area) {
        seatMapSvg.innerHTML = '';
        seatMapSvg.style.display = 'none';
        seatMapSvg.setAttribute('aria-hidden', 'true');
        seatMapEmpty.style.display = 'grid';
        seatMapEmpty.textContent = 'Seat map data is unavailable for this area.';
        seatLegendEl.innerHTML = '';
        updateSeatSelectionMeta();
        updateSelectionButtons();
        return;
      }
      const availableSet = new Set(state.selectedSlot.available_table_ids || []);
      const counts = {
        available: 0,
        held: 0,
        reserved: 0,
        selected: 0,
      };
      const fragment = document.createDocumentFragment();
      (area.landmarks || []).forEach((landmark) => {
        const footprint = Array.isArray(landmark.footprint) && landmark.footprint.length ? landmark.footprint : null;
        if (footprint) {
          const poly = document.createElementNS(SVG_NS, 'polygon');
          poly.setAttribute('points', footprint.map((pt) => pt.join(',')).join(' '));
          poly.classList.add('seat-landmark');
          fragment.appendChild(poly);
        }
        const point = clonePoint(landmark.position);
        if (point && landmark.label) {
          const label = document.createElementNS(SVG_NS, 'text');
          label.textContent = landmark.label;
          label.setAttribute('x', String(point[0]));
          label.setAttribute('y', String(point[1]));
          label.classList.add('seat-landmark-label');
          fragment.appendChild(label);
        }
      });
      (area.tables || []).forEach((table) => {
        const status = getSeatStatus(table, availableSet);
        counts[status] = (counts[status] || 0) + 1;
        const group = buildSeatGroup(table, status);
        if (group) {
          fragment.appendChild(group);
        }
      });
      seatMapSvg.innerHTML = '';
      seatMapSvg.appendChild(fragment);
      seatMapSvg.style.display = 'block';
      seatMapSvg.setAttribute('aria-hidden', 'false');
      seatMapEmpty.style.display = 'none';
      renderSeatLegend(counts);
      updateSeatSelectionMeta();
      updateSelectionButtons();
      updateSeatMapSubtitle();
    }

    function clearSeatSelection(silent = false) {
      if (!state.selectedTableId) return;
      state.selectedTableId = null;
      renderSeatMap();
      if (!silent) {
        logActivity('Seat selection cleared', 'meta');
      }
    }

    function selectTable(tableId, opts = {}) {
      if (!tableId || !state.tableById.has(tableId)) {
        state.selectedTableId = null;
        renderSeatMap();
        return;
      }
      state.selectedTableId = tableId;
      renderSeatMap();
      if (opts.log) {
        const table = state.tableById.get(tableId);
        if (table) {
          logActivity(`Table ${table.label} selected`, 'meta');
        }
      }
    }

    function handleSeatSelection(table, status) {
      if (status !== 'available' && status !== 'selected') {
        return;
      }
      const already = state.selectedTableId === table.id;
      if (already) {
        clearSeatSelection(true);
        renderSeatMap();
        updateSeatSelectionMeta();
        updateSelectionButtons();
        return;
      }
      selectTable(table.id, { log: true });
    }

    function updateSlotCardStates() {
      const cards = availabilityEl.querySelectorAll('.slot-card');
      cards.forEach((card) => {
        const idx = Number(card.dataset.slotIndex);
        card.classList.toggle('active', Number.isInteger(idx) && idx === state.selectedSlotIndex);
      });
    }

    function resetSlotSelection() {
      state.selectedSlot = null;
      state.selectedSlotIndex = null;
      state.selectedSlotStart = null;
      state.selectedTableId = null;
      updateSlotCardStates();
      renderSeatMap();
      updateSeatSelectionMeta();
      updateSelectionButtons();
      updateSeatMapSubtitle();
    }

    function setSelectedSlot(index, opts = {}) {
      if (!Array.isArray(state.usableSlots) || !state.usableSlots.length) {
        state.selectedSlotIndex = null;
        state.selectedSlot = null;
        state.selectedSlotStart = null;
        state.selectedTableId = null;
        updateSlotCardStates();
        renderSeatMap();
        updateSeatSelectionMeta();
        updateSelectionButtons();
        updateSeatMapSubtitle();
        return;
      }
      const slot = state.usableSlots[index];
      if (!slot) return;
      state.selectedSlotIndex = index;
      state.selectedSlot = slot;
      state.selectedSlotStart = slot.start;
      state.selectedTableId = null;
      updateSlotCardStates();
      renderSeatMap();
      if (opts.log) {
        logActivity(`Slot ${formatTime(slot.start)} selected`, 'meta');
      }
    }

    function restoreSlotSelection() {
      if (!state.usableSlots.length) {
        state.selectedSlotIndex = null;
        state.selectedSlot = null;
        state.selectedSlotStart = null;
        state.selectedTableId = null;
        renderSeatMap();
        updateSeatSelectionMeta();
        updateSelectionButtons();
        updateSeatMapSubtitle();
        updateSlotCardStates();
        return;
      }
      let index = -1;
      if (state.selectedSlotStart) {
        index = state.usableSlots.findIndex((slot) => slot.start === state.selectedSlotStart);
      }
      if (index === -1) {
        index = 0;
      }
      setSelectedSlot(index, { log: false });
    }

    function formatTime(iso) {
      if (!iso) return '';
      return iso.split('T')[1]?.slice(0, 5) || iso;
    }

    function renderRestaurant(detail) {
      state.restaurantDetail = detail;
      state.selectedSlotIndex = null;
      state.selectedSlot = null;
      state.selectedSlotStart = null;
      state.selectedTableId = null;
      hydrateLayoutAreas(detail.areas || []);
      updateSeatSelectionMeta();
      updateSelectionButtons();
      updateSeatMapSubtitle();
      restaurantInfoEl.innerHTML = '';
      restaurantMetaEl.textContent = detail.city ? `${detail.city} · ${detail.cuisine?.join(', ') || 'Cuisine TBD'}` : (detail.cuisine?.join(', ') || '');
      heroTitle.textContent = `Bookings for ${detail.name}`;
      const card = document.createElement('article');
      card.className = 'restaurant-card';
      const cover = detail.cover_photo || (detail.photos && detail.photos[0]);
      if (cover) {
        const img = document.createElement('img');
        img.src = cover;
        img.alt = detail.name;
        card.appendChild(img);
      }
      const body = document.createElement('div');
      body.className = 'body';
      const title = document.createElement('h2');
      title.textContent = detail.name;
      body.appendChild(title);
      if (detail.address) {
        const address = document.createElement('p');
        address.textContent = detail.address;
        body.appendChild(address);
      }
      const phone = document.createElement('p');
      phone.innerHTML = `<strong>Phone:</strong> ${detail.phone || 'No phone listed'}`;
      body.appendChild(phone);
      if (detail.areas?.length) {
        const areaHeading = document.createElement('p');
        areaHeading.innerHTML = '<strong>Areas &amp; tables</strong>';
        body.appendChild(areaHeading);
        const chips = document.createElement('div');
        chips.className = 'chip-row';
        detail.areas.forEach((area) => {
          const total = area.tables?.length || 0;
          const capacity = area.tables?.reduce((acc, t) => acc + (t.capacity || 0), 0) || 0;
          const chip = document.createElement('span');
          chip.className = 'chip';
          chip.textContent = `${area.name} · ${total} tables · ${capacity} seats`;
          chips.appendChild(chip);
        });
        body.appendChild(chips);
      }
      card.appendChild(body);
      restaurantInfoEl.appendChild(card);
    }

    function renderSnapshot(slots) {
      snapshotEl.innerHTML = '';
      if (!slots.length) {
        snapshotEl.innerHTML = '<div class="empty">No availability data yet. Try refreshing or choosing another restaurant.</div>';
        slotSummaryEl.textContent = '';
        availabilityMetaEl.textContent = 'No live data yet';
        return;
      }
      const available = slots.filter((slot) => Array.isArray(slot.available_table_ids) && slot.available_table_ids.length > 0);
      const totalFreeTables = available.reduce((acc, slot) => acc + slot.available_table_ids.length, 0);
      const busiest = available.reduce((acc, slot) => {
        if (!acc || slot.available_table_ids.length > acc.available_table_ids.length) return slot;
        return acc;
      }, null);
      const firstStart = slots.reduce((min, slot) => (slot.start < min ? slot.start : min), slots[0].start);
      const lastEnd = slots.reduce((max, slot) => (slot.end > max ? slot.end : max), slots[0].end);
      const coverage = new Set(slots.map((slot) => slot.start)).size;

      const metrics = [
        { label: 'Open slots', value: `${available.length}` },
        { label: 'Tables free', value: `${totalFreeTables}` },
        { label: 'Busiest slot', value: busiest ? `${formatTime(busiest.start)} → ${formatTime(busiest.end)}` : 'Fully booked' },
        { label: 'Service span', value: `${formatTime(firstStart)} — ${formatTime(lastEnd)}` },
        { label: 'Distinct times', value: `${coverage}` }
      ];

      metrics.forEach((metric) => {
        const div = document.createElement('div');
        div.className = 'metric';
        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = metric.label;
        const value = document.createElement('span');
        value.className = 'value';
        value.textContent = metric.value;
        div.appendChild(label);
        div.appendChild(value);
        snapshotEl.appendChild(div);
      });

      slotSummaryEl.textContent = available.length
        ? `Showing ${available.length} open slot${available.length === 1 ? '' : 's'} with ${totalFreeTables} table${totalFreeTables === 1 ? '' : 's'} free`
        : 'Currently fully booked for this day';
      availabilityMetaEl.textContent = `Last check ${formatClock(new Date())}`;
    }

    function renderAvailability(slots) {
      availabilityEl.innerHTML = '';
      if (!slots.length) {
        availabilityEl.innerHTML = '<div class="empty">No tables are open right now. Try another time or date.</div>';
        return;
      }
      slots.forEach((slot, index) => {
        const card = document.createElement('article');
        card.className = 'slot-card';
        card.dataset.slotIndex = String(index);
        card.setAttribute('tabindex', '0');
        card.addEventListener('click', (event) => {
          const target = event.target;
          if (target instanceof HTMLElement && target.closest('button')) {
            return;
          }
          setSelectedSlot(index, { log: true });
        });
        card.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            setSelectedSlot(index, { log: true });
          }
        });

        const header = document.createElement('h3');
        header.textContent = `${formatTime(slot.start)} → ${formatTime(slot.end)}`;
        card.appendChild(header);

        const tableIds = Array.isArray(slot.available_table_ids) ? slot.available_table_ids : [];
        const metaLine = document.createElement('div');
        metaLine.className = 'meta-line';
        const openCount = tableIds.length || slot.count || 0;
        metaLine.textContent = `${openCount} table${openCount === 1 ? '' : 's'} open · party up to ${state.party}`;
        card.appendChild(metaLine);

        const tables = document.createElement('div');
        tables.className = 'tables';
        for (const tid of tableIds) {
          const btn = document.createElement('button');
          btn.type = 'button';
          const label = tid.slice(0, 6).toUpperCase();
          btn.textContent = `Book ${label}`;
          btn.addEventListener('click', (event) => {
            event.stopPropagation();
            setSelectedSlot(index, { log: false });
            selectTable(tid, { log: false });
            bookSlot(slot, tid);
          });
          tables.appendChild(btn);
        }
        card.appendChild(tables);
        availabilityEl.appendChild(card);
      });
      updateSlotCardStates();
    }

    async function bookSlot(slot, tableId) {
      try {
        const tableInfo = tableId ? state.tableById.get(tableId) : null;
        const tableLabel = tableInfo?.label || (tableId ? tableId.slice(0, 6).toUpperCase() : 'auto-assigned table');
        setStatus(`Booking ${formatTime(slot.start)} · ${tableLabel}…`, 'info');
        logActivity(`Booking ${formatTime(slot.start)} slot${tableId ? ` for ${tableLabel}` : ''}`, 'meta');
        const payload = {
          restaurant_id: state.rid,
          party_size: state.party,
          start: slot.start,
          end: slot.end,
          guest_name: guestNameInput.value || 'Web Guest',
          guest_phone: guestPhoneInput.value || undefined,
          table_id: tableId
        };
        if (!payload.guest_phone) delete payload.guest_phone;
        const created = await fetchJson('/reservations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const shortId = created.id.slice(0, 8);
        setStatus(`Booked reservation ${shortId} · ${tableLabel}. Refreshing availability…`, 'success');
        logActivity(`Reservation ${shortId} confirmed`, 'meta');
        await loadAvailability();
      } catch (err) {
        setStatus(`Booking failed: ${err.message || err}`, 'error');
        logActivity(`Booking failed: ${err.message || err}`, 'error');
      }
    }

    async function loadAvailability() {
      if (!state.rid || !state.date) {
        return;
      }
      try {
        setStatus(`Checking availability for ${state.date} (party ${state.party})…`, 'info');
        const data = await fetchJson(`/restaurants/${state.rid}/availability?date=${state.date}&party_size=${state.party}`);
        const slots = Array.isArray(data.slots) ? data.slots : [];
        state.lastSlots = slots;
        state.usableSlots = slots.filter((slot) => Array.isArray(slot.available_table_ids) && slot.available_table_ids.length > 0);
        renderAvailability(state.usableSlots);
        renderSnapshot(slots);
        restoreSlotSelection();
        updateSeatSelectionMeta();
        updateSelectionButtons();
        lastUpdatedEl.textContent = new Date().toLocaleString();
        setStatus(`Showing availability for ${state.date}.`, 'success');
        logActivity('Availability refreshed', 'meta');
      } catch (err) {
        state.lastSlots = [];
        state.usableSlots = [];
        renderAvailability([]);
        renderSnapshot([]);
        resetSlotSelection();
        setStatus(`Could not load availability: ${err.message || err}`, 'error');
        logActivity(`Availability failed: ${err.message || err}`, 'error');
      }
    }

    async function loadRestaurantDetail() {
      if (!state.rid) return;
      try {
        const detail = await fetchJson(`/restaurants/${state.rid}`);
        renderRestaurant(detail);
        await loadAvailability();
      } catch (err) {
        restaurantInfoEl.innerHTML = '<div class="empty">Could not load restaurant details.</div>';
        setStatus(`Could not load restaurant detail: ${err.message || err}`, 'error');
        logActivity(`Restaurant detail failed: ${err.message || err}`, 'error');
      }
    }

    async function loadRestaurants() {
      try {
        setStatus('Loading restaurants…', 'info');
        state.restaurants = await fetchJson('/restaurants');
        if (!state.restaurants.length) {
          setStatus('No restaurants available.', 'error');
          restaurantSelect.innerHTML = '';
          restaurantInfoEl.innerHTML = '<div class="empty">No restaurants configured.</div>';
          return;
        }
        restaurantSelect.innerHTML = state.restaurants
          .map((r) => `<option value="${r.id}">${r.name} (${r.city || 'Unknown'})</option>`)
          .join('');
        if (state.rid && !state.restaurants.some((r) => r.id === state.rid)) {
          state.rid = null;
        }
        if (!state.rid) {
          state.rid = state.restaurants[0].id;
        }
        restaurantSelect.value = state.rid;
        syncQuery();
        await loadRestaurantDetail();
      } catch (err) {
        setStatus(`Failed to load restaurants: ${err.message || err}`, 'error');
        logActivity(`Restaurant load failed: ${err.message || err}`, 'error');
      }
    }

    function initFromQuery() {
      state.rid = params.get('rid');
      const dateParam = params.get('date');
      const today = new Date();
      const isoDate = dateParam || today.toISOString().slice(0, 10);
      state.date = isoDate;
      dateInput.value = isoDate;
      const partyParam = parseInt(params.get('party') || String(defaultParty), 10);
      state.party = Number.isFinite(partyParam) && partyParam > 0 ? partyParam : defaultParty;
      partyInput.value = state.party;
    }

    function scheduleAutoRefresh() {
      if (autoRefreshHandle) {
        clearInterval(autoRefreshHandle);
        autoRefreshHandle = 0;
      }
      if (autoRefreshToggle.checked) {
        autoRefreshHandle = window.setInterval(() => {
          if (document.visibilityState === 'visible') {
            logActivity('Auto-refresh triggered', 'meta');
            loadAvailability();
          }
        }, 60000);
      }
    }

    function adjustDate(days) {
      const current = new Date(`${state.date}T00:00:00`);
      if (Number.isNaN(current.getTime())) return;
      current.setDate(current.getDate() + days);
      const next = current.toISOString().slice(0, 10);
      state.date = next;
      dateInput.value = next;
      syncQuery();
      resetSlotSelection();
      loadAvailability();
    }

    restaurantSelect.addEventListener('change', () => {
      state.rid = restaurantSelect.value;
      syncQuery();
      resetSlotSelection();
      loadRestaurantDetail();
    });
    dateInput.addEventListener('change', () => {
      state.date = dateInput.value;
      syncQuery();
      resetSlotSelection();
      loadAvailability();
    });
    partyInput.addEventListener('change', () => {
      const parsed = parseInt(partyInput.value || String(defaultParty), 10);
      state.party = Number.isFinite(parsed) && parsed > 0 ? parsed : defaultParty;
      partyInput.value = state.party;
      syncQuery();
      renderSeatMap();
      updateSeatSelectionMeta();
      updateSelectionButtons();
      loadAvailability();
    });
    refreshBtn.addEventListener('click', () => {
      logActivity('Manual refresh requested', 'meta');
      syncQuery();
      loadAvailability();
    });
    prevDayBtn.addEventListener('click', () => adjustDate(-1));
    nextDayBtn.addEventListener('click', () => adjustDate(1));
    todayBtn.addEventListener('click', () => {
      const todayIso = new Date().toISOString().slice(0, 10);
      state.date = todayIso;
      dateInput.value = todayIso;
      syncQuery();
      resetSlotSelection();
      loadAvailability();
    });
    autoRefreshToggle.addEventListener('change', () => {
      scheduleAutoRefresh();
      logActivity(`Auto-refresh ${autoRefreshToggle.checked ? 'enabled' : 'disabled'}`, 'meta');
    });
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && autoRefreshToggle.checked) {
        logActivity('Window focused; refreshing data', 'meta');
        loadAvailability();
      }
    });
    downloadBtn.addEventListener('click', () => {
      if (!state.lastSlots.length) {
        setStatus('There is no availability to download yet.', 'error');
        return;
      }
      const serialized = JSON.stringify(state.lastSlots, null, 2);
      const blob = new Blob([serialized], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `availability-${state.rid}-${state.date}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      logActivity('Availability snapshot downloaded', 'meta');
      setStatus('Downloaded current availability snapshot.', 'success');
    });
    copyLinkBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(window.location.href);
        setStatus('Sharable link copied to clipboard.', 'success');
        logActivity('Sharable link copied', 'meta');
      } catch (err) {
        setStatus(`Copy failed: ${err.message || err}`, 'error');
        logActivity(`Copy failed: ${err.message || err}`, 'error');
      }
    });
    clearSelectionBtn.addEventListener('click', () => clearSeatSelection());
    bookSelectionBtn.addEventListener('click', () => {
      if (!state.selectedSlot || !state.selectedTableId) {
        return;
      }
      const slot = state.selectedSlot;
      const tableId = state.selectedTableId;
      bookSlot(slot, tableId);
    });

    document.addEventListener('DOMContentLoaded', () => {
      initFromQuery();
      logActivity('Bootstrapping booking console', 'meta');
      loadRestaurants();
      scheduleAutoRefresh();
    });
  </script>
</body>
</html>
