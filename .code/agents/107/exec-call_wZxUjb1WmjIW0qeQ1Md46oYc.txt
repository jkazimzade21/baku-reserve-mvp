diff --git a/.env.example b/.env.example
index 8d101fc..7b6c1c6 100644
--- a/.env.example
+++ b/.env.example
@@ -11,6 +11,12 @@ DATA_DIR=
 # Comma-separated list of allowed CORS origins (leave blank to disable cross-origin)
 CORS_ALLOW_ORIGINS=http://localhost:8081,http://localhost:19006
 
+# GoMap (routing + search)
+GOMAP_BASE_URL=https://api.gomap.az/Main.asmx
+GOMAP_GUID=
+GOMAP_DEFAULT_LANGUAGE=az
+GOMAP_TIMEOUT_SECONDS=4.0
+
 # Auth0 (set AUTH0_BYPASS=false in staging/prod)
 AUTH0_DOMAIN=dev-qsgi082lyfxd6efi.eu.auth0.com
 AUTH0_AUDIENCE=https://api.bakureserve.az
diff --git a/AGENTS.md b/AGENTS.md
index 4c579f5..032f3de 100644
--- a/AGENTS.md
+++ b/AGENTS.md
@@ -39,3 +39,25 @@
 - Backend seeds live in `backend/app/data/restaurants.json`. After editing, sync them into the runtime store (`~/.baku-reserve-data/restaurants.json`) using the helper Python snippet from `scripts/dev_backend.sh` docs so FastAPI returns the new data.
 - The concierge stack relies on OpenAI (`OPENAI_API_KEY`, `CONCIERGE_GPT_MODEL`, `CONCIERGE_EMBED_MODEL`) and caches embeddings at `~/.baku-reserve-data/concierge_embeddings.json`; make sure those env vars are present before enabling concierge mode.
 - The enrichment workflow (`tools/baku_enricher/`, `tools/update_restaurant_photos.py`) is the source of truth for adding venues—run it to regenerate assets and manifests instead of editing JSON/WebP files manually.
+
+## 2025-11-12 GoMap integration notes
+- `gomap_az/` now stores the official API PDF and onboarding email for reference. Keep new correspondence or credentials in that folder.
+- `.env` contains the temporary GoMap GUID provided by SINAM. Update it when the one-month window lapses and mirror values in `.env.example`.
+- Mobile Prep Notify screen now talks to the backend arrival-intent location endpoint (Expo Location + GoMap ETA). If the "Use my location" button regresses, check `mobile/src/utils/location.ts` and the new tests in `mobile/__tests__/experience.ui.test.tsx`.
+- Added `/reservations/{id}/arrival_intent/suggestions` powered by GoMap search + routing; it drives the new manual pickers in `ReservationsScreen` and `PrepNotifyScreen`. Keep latency low by limiting `limit` to ≤8 per request.
+- Manual typeahead lives in `mobile/src/hooks/useArrivalSuggestions.ts` with a shared UI card in `mobile/src/components/ArrivalInsightCard.tsx`. Both screens now show live distance/ETA/traffic pulled from the arrival intent payload.
+- Created `.venv` (Python 3.11) and installed backend deps there; rerun `source .venv/bin/activate && pytest backend/tests/test_gomap.py backend/tests/test_backend_system.py backend/tests/test_validation.py` plus `cd mobile && npm test -- --watchAll=false` to reproduce today’s verification.
+
+## 2025-02-15 MCP tooling pause
+- Commented out every Codex MCP server in `~/.codex/config.toml` except Ref docs and Chrome DevTools so those two remain usable. Re-enable others (Apify, Sentry, baku-enricher, etc.) by uncommenting their `[mcp_servers.*]` blocks.
+
+## 2025-11-13 Quick filter remediation
+- Reproduced Claude Code’s audit locally: search, booking validation, Auto-assign, and Auth flows already behave per code (`backend/app/storage.py` search path + `mobile/src/screens/SeatPicker.tsx` auth guard). Root cause for “broken filters” was the quick chips issuing literal search strings that never matched seed data.
+- Updated `mobile/src/screens/HomeScreen.tsx` so Tonight/Brunch/Live music/Terrace chips now toggle curated tag filters instead of brittle text queries; also expanded `tagFilterMap` and `vibeFilters` to cover the new tags.
+- Tests: `source .venv/bin/activate && pytest backend/tests/test_gomap.py backend/tests/test_backend_system.py backend/tests/test_validation.py` and `cd mobile && npm test -- --watchAll=false`.
+
+## 2025-11-13 Hook + timezone wave
+- Added richer cancellation + stale-state handling to `useArrivalSuggestions`, updated PrepNotify and Reservations screens to keep presets visible while live requests resolve, and expanded `experience.ui.test.tsx` coverage for the new behaviors.
+- Propagated per-restaurant `timezone` through backend seeds, schemas, serializers, and availability responses (synced to `~/.baku-reserve-data/restaurants.json`). Mobile API types now expose the field, and availability utilities/book flows consume it to format labels and timestamps correctly (defaulting to `Asia/Baku`). SeatPicker and navigation params pass timezone through to floor/arrival cards.
+- Tests executed: `source .venv/bin/activate && pytest backend/tests/test_backend_system.py backend/tests/test_validation.py` and `cd mobile && npm test -- --watchAll=false`.
+- Terminal status @ handoff — A: idle (`./scripts/dev_backend.sh`), B: idle (`./scripts/dev_mobile.sh`), C: free for workflow (next step: verify concierge GoMap latency once services restart).
diff --git a/Makefile b/Makefile
index 2c23918..90c02e6 100644
--- a/Makefile
+++ b/Makefile
@@ -6,7 +6,7 @@ SENTRY_PROJECT ?= concierge-ai
 SENTRY_TEAM ?= platform
 SENTRY_PLATFORM ?= python
 
-.PHONY: enrich perf ref-docs sentry-bootstrap
+.PHONY: enrich perf ref-docs sentry-bootstrap doctor
 
 enrich:
 	@python3 scripts/enrich_baku.py $(if $(ENRICH_SLUGS),--slugs $(ENRICH_SLUGS),)
@@ -23,3 +23,6 @@ ref-docs:
 
 sentry-bootstrap:
 	@node scripts/sentry_bootstrap.mjs --org $(SENTRY_ORG) --project $(SENTRY_PROJECT) --team $(SENTRY_TEAM) --platform $(SENTRY_PLATFORM)
+
+doctor:
+	@scripts/dev_doctor.sh
diff --git a/README.md b/README.md
index 1591ecc..0ef10fc 100644
--- a/README.md
+++ b/README.md
@@ -93,8 +93,9 @@ falls back to API-provided URLs.
 - Payments default to the mock provider (`PAYMENTS_MODE=mock`, `PAYMENT_PROVIDER=mock`).
   Swap `PAYMENT_PROVIDER` to `paymentwall` or `azericard` once those integrations are
   implemented; no deposits are charged in the current build.
-- When `MAPS_API_KEY` is populated the mobile prep screen shows a "Use my location"
-  control; leave it blank to hide the location-based ETA helper.
+- When `GOMAP_GUID` is populated (and the backend can reach GoMap) the prep screen
+  shows a "Use my location" control that keeps ETA predictions in sync. Leave it
+  blank to hide the location-based helper entirely.
 - To demo: enable the flag, run the backend, start the Expo client, pick a confirmed
   reservation, tap **On My Way (Prep Food)**, choose ETA/scope, and confirm. The kitchen
   receives the alert instantly and the reservation card displays a "Prep" badge with the
@@ -135,3 +136,11 @@ The script will:
   still ignored via `.gitignore`.
 - Raw Instagram photos are now checked in under `IGPics/` so the team has a
   permanent archive of every curated shot that ships with the demo.
+
+### GoMap assets & reference
+
+- `gomap_az/` keeps the API PDF (`API_AZ.pdf`) and onboarding email from SINAM so
+  the contract, GUID, and pricing context ship with the repo.
+- Populate `GOMAP_GUID`/`GOMAP_BASE_URL` in `.env` (see `.env.example`) to enable live
+  routing, place search, and reverse geocoding; request a fresh GUID from info@gomap.az
+  when the temporary test token expires.
diff --git a/backend/app/auth.py b/backend/app/auth.py
index 4fba2cc..05110c3 100644
--- a/backend/app/auth.py
+++ b/backend/app/auth.py
@@ -46,7 +46,20 @@ class Auth0Verifier:
         self._jwks_expiry = now + 60 * 15  # cache for 15 minutes
         return jwks
 
-    def verify(self, token: str) -> dict[str, Any]:
+    def verify(self, token: str, required_scopes: list[str] | None = None) -> dict[str, Any]:
+        """
+        Verify and validate Auth0 JWT token with comprehensive security checks.
+
+        Args:
+            token: JWT token string
+            required_scopes: Optional list of required scopes for authorization
+
+        Returns:
+            Decoded token payload
+
+        Raises:
+            HTTPException: If token is invalid, expired, or lacks required permissions
+        """
         audience = settings.AUTH0_AUDIENCE
         issuer = settings.auth0_issuer
         if not audience or not issuer:
@@ -55,32 +68,153 @@ class Auth0Verifier:
                 detail="Auth0 audience/domain not configured",
             )
 
+        # Step 1: Verify token structure and get signing key
         jwks = self._get_jwks()
-        unverified_header = jwt.get_unverified_header(token)
+        try:
+            unverified_header = jwt.get_unverified_header(token)
+        except Exception as exc:
+            raise HTTPException(
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                detail="Malformed token header",
+            ) from exc
+
         kid = unverified_header.get("kid")
         if not kid:
             raise HTTPException(
-                status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token header"
+                status_code=status.HTTP_401_UNAUTHORIZED, detail="Missing key ID in token"
             )
+
+        # Verify algorithm is RS256 (prevent algorithm confusion attacks)
+        alg = unverified_header.get("alg")
+        if alg != "RS256":
+            raise HTTPException(
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                detail=f"Unsupported algorithm: {alg}. Only RS256 allowed.",
+            )
+
         key = next((k for k in jwks.get("keys", []) if k.get("kid") == kid), None)
         if not key:
             raise HTTPException(
-                status_code=status.HTTP_401_UNAUTHORIZED, detail="Unknown token signature"
+                status_code=status.HTTP_401_UNAUTHORIZED, detail="Unknown token signature key"
             )
+
+        # Step 2: Decode and validate token
         try:
             payload = jwt.decode(
                 token,
                 key,
-                algorithms=["RS256"],
+                algorithms=["RS256"],  # Explicitly only RS256
                 audience=audience,
                 issuer=issuer.rstrip("/") + "/",
             )
+        except jwt.ExpiredSignatureError as exc:
+            raise HTTPException(
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                detail="Token has expired",
+            ) from exc
+        except jwt.JWTClaimsError as exc:
+            raise HTTPException(
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                detail="Invalid token claims",
+            ) from exc
         except Exception as exc:  # pragma: no cover - jose already well-tested
             raise HTTPException(
                 status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token"
             ) from exc
+
+        # Step 3: Additional security validations
+        self._validate_token_security(payload)
+
+        # Step 4: Scope validation (if required)
+        if required_scopes:
+            self._validate_scopes(payload, required_scopes)
+
         return payload
 
+    def _validate_token_security(self, payload: dict[str, Any]) -> None:
+        """
+        Perform additional security validations on token payload.
+
+        Checks:
+        - Expiration with buffer (prevent near-expiry tokens)
+        - Subject claim presence
+        - Issued-at time reasonableness
+        """
+        # Check expiration with 60-second buffer
+        exp = payload.get("exp")
+        if exp:
+            import time
+            current_time = time.time()
+            # Reject tokens expiring within 60 seconds
+            if exp < current_time + 60:
+                raise HTTPException(
+                    status_code=status.HTTP_401_UNAUTHORIZED,
+                    detail="Token expired or expiring soon. Please refresh.",
+                )
+
+        # Ensure subject claim exists
+        if not payload.get("sub"):
+            raise HTTPException(
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                detail="Token missing subject claim",
+            )
+
+        # Validate issued-at time is not in the future
+        iat = payload.get("iat")
+        if iat:
+            import time
+            current_time = time.time()
+            # Allow 5 minutes of clock skew
+            if iat > current_time + 300:
+                raise HTTPException(
+                    status_code=status.HTTP_401_UNAUTHORIZED,
+                    detail="Token issued in the future",
+                )
+
+    def _validate_scopes(self, payload: dict[str, Any], required_scopes: list[str]) -> None:
+        """
+        Validate token has required scopes for authorization.
+
+        Args:
+            payload: Decoded token payload
+            required_scopes: List of required scope strings
+
+        Raises:
+            HTTPException: If token lacks required scopes
+        """
+        # Extract scopes from token (can be space-separated string or list)
+        token_scopes_raw = payload.get("scope", "")
+        if isinstance(token_scopes_raw, str):
+            token_scopes = set(token_scopes_raw.split())
+        elif isinstance(token_scopes_raw, list):
+            token_scopes = set(token_scopes_raw)
+        else:
+            token_scopes = set()
+
+        # Check all required scopes are present
+        missing_scopes = set(required_scopes) - token_scopes
+        if missing_scopes:
+            raise HTTPException(
+                status_code=status.HTTP_403_FORBIDDEN,
+                detail=f"Insufficient permissions. Missing scopes: {', '.join(missing_scopes)}",
+            )
+
+    def verify_with_scopes(self, token: str, *scopes: str) -> dict[str, Any]:
+        """
+        Convenience method to verify token with required scopes.
+
+        Args:
+            token: JWT token string
+            *scopes: Variable number of required scope strings
+
+        Returns:
+            Decoded token payload
+
+        Example:
+            payload = verifier.verify_with_scopes(token, "read:restaurants", "write:reservations")
+        """
+        return self.verify(token, required_scopes=list(scopes))
+
 
 auth0_verifier = Auth0Verifier()
 
diff --git a/backend/app/availability.py b/backend/app/availability.py
index 3c09953..81074d8 100644
--- a/backend/app/availability.py
+++ b/backend/app/availability.py
@@ -5,6 +5,7 @@ RES_DURATION = timedelta(minutes=90)
 INTERVAL = timedelta(minutes=30)
 OPEN = time(10, 0)
 CLOSE = time(23, 0)
+DEFAULT_TIMEZONE = "Asia/Baku"
 
 
 def _overlaps(a_start: datetime, a_end: datetime, b_start: datetime, b_end: datetime) -> bool:
@@ -20,7 +21,12 @@ def availability_for_day(restaurant: Any, party_size: int, day: date, db) -> dic
     Returns: {"slots":[{"start":iso,"end":iso,"available_table_ids":[...],"count":N}, ...]}
     Only considers reservations with status == "booked".
     """
-    rid = str(restaurant.get("id"))
+    if isinstance(restaurant, dict):
+        rid = str(restaurant.get("id"))
+        restaurant_tz = restaurant.get("timezone") or DEFAULT_TIMEZONE
+    else:
+        rid = str(getattr(restaurant, "id"))
+        restaurant_tz = getattr(restaurant, "timezone", DEFAULT_TIMEZONE) or DEFAULT_TIMEZONE
 
     # Tables that fit the party
     tables: list[dict[str, Any]] = db.eligible_tables(rid, party_size)
@@ -82,4 +88,4 @@ def availability_for_day(restaurant: Any, party_size: int, day: date, db) -> dic
         )
         cur += INTERVAL
 
-    return {"slots": slots}
+    return {"slots": slots, "restaurant_timezone": restaurant_tz}
diff --git a/backend/app/cache.py b/backend/app/cache.py
new file mode 100644
index 0000000..1b24500
--- /dev/null
+++ b/backend/app/cache.py
@@ -0,0 +1,393 @@
+"""Simple caching implementation for GoMap API responses."""
+from __future__ import annotations
+
+import hashlib
+import json
+import logging
+import time
+from dataclasses import dataclass, field
+from threading import Lock
+from typing import Any, Generic, TypeVar
+
+from .settings import settings
+
+logger = logging.getLogger(__name__)
+
+T = TypeVar("T")
+
+
+@dataclass
+class CacheEntry(Generic[T]):
+    """Single cache entry with value and expiry time."""
+    value: T
+    expires_at: float
+    hits: int = 0
+    created_at: float = field(default_factory=time.time)
+
+    def is_expired(self) -> bool:
+        """Check if this entry has expired."""
+        return time.time() >= self.expires_at
+
+    def increment_hits(self) -> None:
+        """Increment hit counter for this entry."""
+        self.hits += 1
+
+
+class TTLCache(Generic[T]):
+    """
+    Thread-safe TTL (Time To Live) cache with LRU eviction.
+
+    This cache stores values with an expiration time and automatically
+    removes expired entries. It also implements LRU eviction when the
+    cache reaches its maximum size.
+    """
+
+    def __init__(
+        self,
+        name: str,
+        max_size: int = 1000,
+        default_ttl: float = 900,  # 15 minutes default
+        enabled: bool = True,
+    ):
+        """
+        Initialize TTL cache.
+
+        Args:
+            name: Name of this cache instance
+            max_size: Maximum number of entries
+            default_ttl: Default time-to-live in seconds
+            enabled: Whether caching is enabled
+        """
+        self.name = name
+        self.max_size = max_size
+        self.default_ttl = default_ttl
+        self.enabled = enabled
+        self._cache: dict[str, CacheEntry[T]] = {}
+        self._access_order: list[str] = []  # For LRU tracking
+        self._lock = Lock()
+        self._stats = {
+            "hits": 0,
+            "misses": 0,
+            "evictions": 0,
+            "expirations": 0,
+        }
+
+    def get(self, key: str) -> T | None:
+        """
+        Get value from cache if it exists and hasn't expired.
+
+        Args:
+            key: Cache key
+
+        Returns:
+            Cached value or None if not found/expired
+        """
+        if not self.enabled:
+            return None
+
+        with self._lock:
+            entry = self._cache.get(key)
+            if entry is None:
+                self._stats["misses"] += 1
+                return None
+
+            if entry.is_expired():
+                self._stats["expirations"] += 1
+                self._remove_entry(key)
+                return None
+
+            # Move to end for LRU
+            self._access_order.remove(key)
+            self._access_order.append(key)
+
+            entry.increment_hits()
+            self._stats["hits"] += 1
+            logger.debug(
+                "Cache hit for '%s' in '%s' (hits: %d)",
+                key, self.name, entry.hits
+            )
+            return entry.value
+
+    def set(
+        self,
+        key: str,
+        value: T,
+        ttl: float | None = None,
+    ) -> None:
+        """
+        Store value in cache with expiration time.
+
+        Args:
+            key: Cache key
+            value: Value to cache
+            ttl: Time-to-live in seconds (uses default if None)
+        """
+        if not self.enabled:
+            return
+
+        if ttl is None:
+            ttl = self.default_ttl
+
+        with self._lock:
+            # Remove existing entry if present
+            if key in self._cache:
+                self._access_order.remove(key)
+
+            # Check if we need to evict
+            while len(self._cache) >= self.max_size:
+                self._evict_lru()
+
+            # Add new entry
+            expires_at = time.time() + ttl
+            self._cache[key] = CacheEntry(value, expires_at)
+            self._access_order.append(key)
+
+            logger.debug(
+                "Cached value for '%s' in '%s' (TTL: %.1fs)",
+                key, self.name, ttl
+            )
+
+    def _remove_entry(self, key: str) -> None:
+        """Remove entry from cache (internal, must be called with lock)."""
+        if key in self._cache:
+            del self._cache[key]
+            if key in self._access_order:
+                self._access_order.remove(key)
+
+    def _evict_lru(self) -> None:
+        """Evict least recently used entry (internal, must be called with lock)."""
+        if self._access_order:
+            lru_key = self._access_order[0]
+            self._remove_entry(lru_key)
+            self._stats["evictions"] += 1
+            logger.debug("Evicted LRU entry '%s' from '%s'", lru_key, self.name)
+
+    def clear(self) -> None:
+        """Clear all entries from cache."""
+        with self._lock:
+            self._cache.clear()
+            self._access_order.clear()
+            logger.info("Cleared cache '%s'", self.name)
+
+    def cleanup_expired(self) -> int:
+        """
+        Remove all expired entries from cache.
+
+        Returns:
+            Number of entries removed
+        """
+        with self._lock:
+            expired_keys = [
+                key for key, entry in self._cache.items()
+                if entry.is_expired()
+            ]
+            for key in expired_keys:
+                self._remove_entry(key)
+            if expired_keys:
+                logger.debug(
+                    "Cleaned up %d expired entries from '%s'",
+                    len(expired_keys), self.name
+                )
+            return len(expired_keys)
+
+    def get_stats(self) -> dict[str, Any]:
+        """Get cache statistics."""
+        with self._lock:
+            total_requests = self._stats["hits"] + self._stats["misses"]
+            hit_rate = (
+                self._stats["hits"] / total_requests if total_requests > 0 else 0
+            )
+            return {
+                "name": self.name,
+                "size": len(self._cache),
+                "max_size": self.max_size,
+                "hits": self._stats["hits"],
+                "misses": self._stats["misses"],
+                "hit_rate": round(hit_rate, 3),
+                "evictions": self._stats["evictions"],
+                "expirations": self._stats["expirations"],
+                "enabled": self.enabled,
+            }
+
+
+# Global cache instances
+_route_cache: TTLCache[Any] = TTLCache(
+    "gomap_routes",
+    max_size=500,
+    default_ttl=settings.GOMAP_CACHE_TTL_SECONDS,
+)
+
+_osrm_route_cache: TTLCache[Any] = TTLCache(
+    "osrm_routes",
+    max_size=500,
+    default_ttl=settings.GOMAP_CACHE_TTL_SECONDS,
+)
+
+_geocode_cache: TTLCache[Any] = TTLCache(
+    "gomap_geocoding",
+    max_size=1000,
+    default_ttl=settings.GOMAP_GEOCODE_CACHE_TTL_SECONDS,
+)
+
+_traffic_cache: TTLCache[Any] = TTLCache(
+    "gomap_traffic",
+    max_size=200,
+    default_ttl=settings.GOMAP_TRAFFIC_UPDATE_INTERVAL_SECONDS,
+)
+
+
+def make_cache_key(*args: Any) -> str:
+    """
+    Create a cache key from arguments.
+
+    Args:
+        *args: Values to include in key
+
+    Returns:
+        SHA-256 hash of the arguments
+    """
+    # Convert all arguments to strings and join
+    key_parts = [str(arg) for arg in args]
+    key_string = "|".join(key_parts)
+
+    # Use SHA-256 for consistent, collision-resistant keys
+    return hashlib.sha256(key_string.encode()).hexdigest()[:16]
+
+
+def cache_route(
+    origin_lat: float,
+    origin_lon: float,
+    dest_lat: float,
+    dest_lon: float,
+    result: Any,
+) -> None:
+    """Cache a route calculation result."""
+    # Round coordinates to reduce key variations
+    key = make_cache_key(
+        "route",
+        round(origin_lat, 5),
+        round(origin_lon, 5),
+        round(dest_lat, 5),
+        round(dest_lon, 5),
+    )
+    _route_cache.set(key, result)
+
+
+def get_cached_route(
+    origin_lat: float,
+    origin_lon: float,
+    dest_lat: float,
+    dest_lon: float,
+) -> Any | None:
+    """Get cached route calculation if available."""
+    key = make_cache_key(
+        "route",
+        round(origin_lat, 5),
+        round(origin_lon, 5),
+        round(dest_lat, 5),
+        round(dest_lon, 5),
+    )
+    return _route_cache.get(key)
+
+
+def cache_osrm_route(
+    origin_lat: float,
+    origin_lon: float,
+    dest_lat: float,
+    dest_lon: float,
+    result: Any,
+) -> None:
+    key = make_cache_key(
+        "osrm",
+        round(origin_lat, 5),
+        round(origin_lon, 5),
+        round(dest_lat, 5),
+        round(dest_lon, 5),
+    )
+    _osrm_route_cache.set(key, result)
+
+
+def get_cached_osrm_route(
+    origin_lat: float,
+    origin_lon: float,
+    dest_lat: float,
+    dest_lon: float,
+) -> Any | None:
+    key = make_cache_key(
+        "osrm",
+        round(origin_lat, 5),
+        round(origin_lon, 5),
+        round(dest_lat, 5),
+        round(dest_lon, 5),
+    )
+    return _osrm_route_cache.get(key)
+
+
+def cache_geocode(query: str, results: list[Any]) -> None:
+    """Cache geocoding results."""
+    key = make_cache_key("geocode", query.lower().strip())
+    _geocode_cache.set(key, results)
+
+
+def get_cached_geocode(query: str) -> list[Any] | None:
+    """Get cached geocoding results if available."""
+    key = make_cache_key("geocode", query.lower().strip())
+    return _geocode_cache.get(key)
+
+
+def cache_traffic(lat: float, lon: float, radius_km: float, result: Any) -> None:
+    """Cache traffic conditions."""
+    key = make_cache_key(
+        "traffic",
+        round(lat, 4),  # Less precision for traffic areas
+        round(lon, 4),
+        round(radius_km, 1),
+    )
+    _traffic_cache.set(key, result)
+
+
+def get_cached_traffic(lat: float, lon: float, radius_km: float) -> Any | None:
+    """Get cached traffic conditions if available."""
+    key = make_cache_key(
+        "traffic",
+        round(lat, 4),
+        round(lon, 4),
+        round(radius_km, 1),
+    )
+    return _traffic_cache.get(key)
+
+
+def get_all_cache_stats() -> dict[str, Any]:
+    """Get statistics for all cache instances."""
+    return {
+        "routes": _route_cache.get_stats(),
+        "osrm_routes": _osrm_route_cache.get_stats(),
+        "geocoding": _geocode_cache.get_stats(),
+        "traffic": _traffic_cache.get_stats(),
+    }
+
+
+def clear_all_caches() -> None:
+    """Clear all cache instances."""
+    _route_cache.clear()
+    _osrm_route_cache.clear()
+    _geocode_cache.clear()
+    _traffic_cache.clear()
+    logger.info("Cleared all GoMap caches")
+
+
+__all__ = [
+    "TTLCache",
+    "CacheEntry",
+    "make_cache_key",
+    "cache_route",
+    "get_cached_route",
+    "cache_osrm_route",
+    "get_cached_osrm_route",
+    "cache_geocode",
+    "get_cached_geocode",
+    "cache_traffic",
+    "get_cached_traffic",
+    "get_all_cache_stats",
+    "clear_all_caches",
+]
diff --git a/backend/app/circuit_breaker.py b/backend/app/circuit_breaker.py
new file mode 100644
index 0000000..34e59b5
--- /dev/null
+++ b/backend/app/circuit_breaker.py
@@ -0,0 +1,378 @@
+"""Circuit breaker pattern implementation for resilient API calls."""
+from __future__ import annotations
+
+import logging
+import time
+from dataclasses import dataclass, field
+from enum import Enum
+from threading import Lock
+from typing import Any, Callable, TypeVar
+
+from .settings import settings
+
+logger = logging.getLogger(__name__)
+
+# Import Redis client (lazy loaded)
+_redis_client_module = None
+
+
+def _get_redis():
+    """Lazy import of Redis client to avoid import errors if Redis is not available."""
+    global _redis_client_module
+    if _redis_client_module is None:
+        try:
+            from . import redis_client as _redis_client_module
+        except ImportError:
+            pass
+    return _redis_client_module
+
+T = TypeVar("T")
+
+
+class CircuitState(Enum):
+    """Circuit breaker states"""
+    CLOSED = "closed"  # Normal operation, requests allowed
+    OPEN = "open"  # Circuit broken, requests rejected
+    HALF_OPEN = "half_open"  # Testing if service recovered
+
+
+@dataclass
+class CircuitBreakerStats:
+    """Statistics for circuit breaker monitoring"""
+    total_calls: int = 0
+    successful_calls: int = 0
+    failed_calls: int = 0
+    rejected_calls: int = 0
+    last_failure_time: float | None = None
+    last_success_time: float | None = None
+    consecutive_failures: int = 0
+    circuit_opened_count: int = 0
+
+
+class CircuitBreaker:
+    """
+    Circuit breaker to protect against cascading failures.
+
+    The circuit breaker has three states:
+    - CLOSED: Normal operation, all requests pass through
+    - OPEN: After failure threshold, requests are immediately rejected
+    - HALF_OPEN: After cooldown, one test request is allowed
+    """
+
+    def __init__(
+        self,
+        name: str,
+        failure_threshold: int | None = None,
+        cooldown_seconds: float | None = None,
+        success_threshold: int = 1,
+        enabled: bool | None = None,
+    ):
+        """
+        Initialize circuit breaker.
+
+        Args:
+            name: Identifier for this circuit breaker
+            failure_threshold: Number of consecutive failures before opening circuit
+            cooldown_seconds: Time to wait before attempting recovery
+            success_threshold: Successes needed in half-open state to close circuit
+            enabled: Whether circuit breaker is active
+        """
+        self.name = name
+        self.failure_threshold = (
+            failure_threshold
+            if failure_threshold is not None
+            else settings.GOMAP_CIRCUIT_BREAKER_THRESHOLD
+        )
+        self.cooldown_seconds = (
+            cooldown_seconds
+            if cooldown_seconds is not None
+            else settings.GOMAP_CIRCUIT_BREAKER_COOLDOWN_SECONDS
+        )
+        self.success_threshold = success_threshold
+        self.enabled = (
+            enabled
+            if enabled is not None
+            else settings.GOMAP_CIRCUIT_BREAKER_ENABLED
+        )
+
+        self._state = CircuitState.CLOSED
+        self._stats = CircuitBreakerStats()
+        self._lock = Lock()
+        self._last_state_change = time.time()
+        self._half_open_successes = 0
+
+        # Attempt to restore state from Redis
+        self._restore_state()
+
+    @property
+    def state(self) -> CircuitState:
+        """Get current circuit state, checking for automatic transitions."""
+        with self._lock:
+            if self._state == CircuitState.OPEN:
+                # Check if cooldown period has passed
+                if time.time() - self._last_state_change >= self.cooldown_seconds:
+                    self._transition_to(CircuitState.HALF_OPEN)
+            return self._state
+
+    @property
+    def stats(self) -> CircuitBreakerStats:
+        """Get circuit breaker statistics."""
+        return self._stats
+
+    def _transition_to(self, new_state: CircuitState) -> None:
+        """Transition to a new state."""
+        old_state = self._state
+        self._state = new_state
+        self._last_state_change = time.time()
+
+        if new_state == CircuitState.OPEN:
+            self._stats.circuit_opened_count += 1
+            logger.warning(
+                "Circuit breaker '%s' opened after %d consecutive failures",
+                self.name,
+                self._stats.consecutive_failures,
+            )
+        elif new_state == CircuitState.CLOSED:
+            self._stats.consecutive_failures = 0
+            self._half_open_successes = 0
+            if old_state == CircuitState.HALF_OPEN:
+                logger.info("Circuit breaker '%s' closed after successful recovery", self.name)
+        elif new_state == CircuitState.HALF_OPEN:
+            self._half_open_successes = 0
+            logger.info("Circuit breaker '%s' entering half-open state for testing", self.name)
+
+        # Persist state to Redis if available
+        self._persist_state()
+
+    def _persist_state(self) -> None:
+        """Persist circuit breaker state to Redis (if available)."""
+        redis_module = _get_redis()
+        if not redis_module:
+            return
+
+        redis = redis_module.get_redis_client()
+        if not redis:
+            return
+
+        try:
+            key = f"circuit_breaker:{self.name}:state"
+            ttl = int(self.cooldown_seconds * 2)  # Keep state for 2x cooldown period
+
+            # Store state as a hash
+            redis.hset(
+                key,
+                mapping={
+                    "state": self._state.value,
+                    "consecutive_failures": str(self._stats.consecutive_failures),
+                    "last_state_change": str(self._last_state_change),
+                    "circuit_opened_count": str(self._stats.circuit_opened_count),
+                },
+            )
+            redis.expire(key, ttl)
+
+        except Exception as exc:
+            logger.warning(
+                "Failed to persist circuit breaker state to Redis",
+                circuit=self.name,
+                error=str(exc),
+            )
+
+    def _restore_state(self) -> None:
+        """Restore circuit breaker state from Redis (if available)."""
+        redis_module = _get_redis()
+        if not redis_module:
+            return
+
+        redis = redis_module.get_redis_client()
+        if not redis:
+            return
+
+        try:
+            key = f"circuit_breaker:{self.name}:state"
+            state_data = redis.hgetall(key)
+
+            if not state_data:
+                return  # No persisted state
+
+            # Restore state
+            state_value = state_data.get("state")
+            if state_value:
+                self._state = CircuitState(state_value)
+
+            consecutive_failures = state_data.get("consecutive_failures")
+            if consecutive_failures:
+                self._stats.consecutive_failures = int(consecutive_failures)
+
+            last_state_change = state_data.get("last_state_change")
+            if last_state_change:
+                self._last_state_change = float(last_state_change)
+
+            circuit_opened_count = state_data.get("circuit_opened_count")
+            if circuit_opened_count:
+                self._stats.circuit_opened_count = int(circuit_opened_count)
+
+            logger.info(
+                "Restored circuit breaker state from Redis",
+                circuit=self.name,
+                state=self._state.value,
+                consecutive_failures=self._stats.consecutive_failures,
+            )
+
+        except Exception as exc:
+            logger.warning(
+                "Failed to restore circuit breaker state from Redis",
+                circuit=self.name,
+                error=str(exc),
+            )
+
+    def call(self, func: Callable[..., T], *args: Any, **kwargs: Any) -> T:
+        """
+        Execute a function through the circuit breaker.
+
+        Args:
+            func: Function to execute
+            *args: Positional arguments for func
+            **kwargs: Keyword arguments for func
+
+        Returns:
+            Result of func execution
+
+        Raises:
+            CircuitOpenError: If circuit is open
+            Original exception: If func fails
+        """
+        if not self.enabled:
+            # Circuit breaker disabled, execute normally
+            return func(*args, **kwargs)
+
+        # Check if circuit allows request
+        if not self._can_execute():
+            self._stats.rejected_calls += 1
+            raise CircuitOpenError(
+                f"Circuit breaker '{self.name}' is open. "
+                f"Service will be retried after {self.cooldown_seconds} seconds."
+            )
+
+        # Execute the function
+        try:
+            result = func(*args, **kwargs)
+            self._on_success()
+            return result
+        except Exception as exc:
+            self._on_failure()
+            raise
+
+    def _can_execute(self) -> bool:
+        """Check if execution is allowed based on circuit state."""
+        current_state = self.state  # This checks for automatic transitions
+        return current_state != CircuitState.OPEN
+
+    def _on_success(self) -> None:
+        """Handle successful execution."""
+        with self._lock:
+            self._stats.total_calls += 1
+            self._stats.successful_calls += 1
+            self._stats.last_success_time = time.time()
+            self._stats.consecutive_failures = 0
+
+            if self._state == CircuitState.HALF_OPEN:
+                self._half_open_successes += 1
+                if self._half_open_successes >= self.success_threshold:
+                    self._transition_to(CircuitState.CLOSED)
+
+    def _on_failure(self) -> None:
+        """Handle failed execution."""
+        with self._lock:
+            self._stats.total_calls += 1
+            self._stats.failed_calls += 1
+            self._stats.last_failure_time = time.time()
+            self._stats.consecutive_failures += 1
+
+            if self._state == CircuitState.HALF_OPEN:
+                # Failure in half-open state immediately opens circuit
+                self._transition_to(CircuitState.OPEN)
+            elif (
+                self._state == CircuitState.CLOSED
+                and self._stats.consecutive_failures >= self.failure_threshold
+            ):
+                # Threshold reached, open circuit
+                self._transition_to(CircuitState.OPEN)
+
+    def reset(self) -> None:
+        """Manually reset the circuit breaker to closed state."""
+        with self._lock:
+            self._state = CircuitState.CLOSED
+            self._stats.consecutive_failures = 0
+            self._half_open_successes = 0
+            self._last_state_change = time.time()
+            logger.info("Circuit breaker '%s' manually reset", self.name)
+
+    def is_open(self) -> bool:
+        """Check if circuit is currently open."""
+        return self.state == CircuitState.OPEN
+
+    def is_closed(self) -> bool:
+        """Check if circuit is currently closed."""
+        return self.state == CircuitState.CLOSED
+
+
+class CircuitOpenError(Exception):
+    """Exception raised when circuit breaker is open."""
+    pass
+
+
+# Global circuit breakers for different services
+_circuit_breakers: dict[str, CircuitBreaker] = {}
+_breakers_lock = Lock()
+
+
+def get_circuit_breaker(name: str = "gomap_api") -> CircuitBreaker:
+    """
+    Get or create a circuit breaker instance.
+
+    Args:
+        name: Name of the circuit breaker
+
+    Returns:
+        CircuitBreaker instance
+    """
+    with _breakers_lock:
+        if name not in _circuit_breakers:
+            _circuit_breakers[name] = CircuitBreaker(name)
+        return _circuit_breakers[name]
+
+
+def with_circuit_breaker(
+    func: Callable[..., T],
+    circuit_name: str = "gomap_api",
+    *args: Any,
+    **kwargs: Any,
+) -> T:
+    """
+    Execute a function with circuit breaker protection.
+
+    Args:
+        func: Function to execute
+        circuit_name: Name of the circuit breaker to use
+        *args: Positional arguments for func
+        **kwargs: Keyword arguments for func
+
+    Returns:
+        Result of func execution
+
+    Raises:
+        CircuitOpenError: If circuit is open
+        Original exception: If func fails
+    """
+    breaker = get_circuit_breaker(circuit_name)
+    return breaker.call(func, *args, **kwargs)
+
+
+__all__ = [
+    "CircuitBreaker",
+    "CircuitOpenError",
+    "CircuitState",
+    "CircuitBreakerStats",
+    "get_circuit_breaker",
+    "with_circuit_breaker",
+]
\ No newline at end of file
diff --git a/backend/app/data/restaurants.json b/backend/app/data/restaurants.json
index 94ff35a..cec6a59 100644
--- a/backend/app/data/restaurants.json
+++ b/backend/app/data/restaurants.json
@@ -30,12 +30,12 @@
     "map_images": [
       "https://images.unsplash.com/photo-1528605248644-14dd04022da1?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3657,
-    "longitude": 49.837,
+    "latitude": 40.369683,
+    "longitude": 49.845642,
     "menu_url": "https://sahil.az/menu",
     "instagram": "https://www.instagram.com/sahilrestaurantbaku/",
     "whatsapp": "+994515001122",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -382,7 +382,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3657,49.837",
-    "call_url": "tel:+994124048212"
+    "call_url": "tel:+994124048212",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Sumakh Restaurant",
@@ -413,11 +414,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1517248135467-4c7edcad34c4?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3707,
-    "longitude": 49.8559,
+    "latitude": 40.381974,
+    "longitude": 49.868534,
     "menu_url": "https://sumakh.az/menu",
     "instagram": "https://www.instagram.com/sumakhrestaurant/",
-    "average_spend": "AZN 65–115 per guest",
+    "average_spend": "AZN 65\u2013115 per guest",
     "dress_code": "Smart elegant",
     "experiences": [],
     "areas": [
@@ -645,7 +646,8 @@
     "city": "Baku",
     "id": "a20bb41e-4dad-513b-afb0-9eadc54e02a4",
     "directions_url": "https://maps.google.com/?q=40.3707,49.8559",
-    "call_url": "tel:+994123100220"
+    "call_url": "tel:+994123100220",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Chinar Dining",
@@ -680,7 +682,7 @@
     "longitude": 49.8375,
     "menu_url": "https://chinar-dining.az/menu",
     "instagram": "https://www.instagram.com/chinardining/",
-    "average_spend": "AZN 90–150 per guest",
+    "average_spend": "AZN 90\u2013150 per guest",
     "dress_code": "Smart chic",
     "experiences": [],
     "areas": [
@@ -908,7 +910,8 @@
     "city": "Baku",
     "id": "77d967f4-1ef0-5011-9412-f31df58392cf",
     "directions_url": "https://maps.google.com/?q=40.3659,49.8375",
-    "call_url": "tel:+994514048211"
+    "call_url": "tel:+994514048211",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Shirvanshah Museum Restaurant",
@@ -943,7 +946,7 @@
     "longitude": 49.8356,
     "menu_url": "https://shirvanshah.az/menu",
     "instagram": "https://www.instagram.com/shirvanshah_restaurant/",
-    "average_spend": "AZN 60–100 per guest",
+    "average_spend": "AZN 60\u2013100 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -1171,7 +1174,8 @@
     "city": "Baku",
     "id": "173b0b00-829c-52ff-b87e-af395418e9b1",
     "directions_url": "https://maps.google.com/?q=40.3683,49.8356",
-    "call_url": "tel:+994125950901"
+    "call_url": "tel:+994125950901",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Dolma Restaurant",
@@ -1202,11 +1206,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1498654896293-37aacf113fd9?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3698,
-    "longitude": 49.8363,
+    "latitude": 40.369914,
+    "longitude": 49.836945,
     "menu_url": "https://menu.az/en/dolma-restaurant",
     "instagram": "https://www.instagram.com/dolma.restaurant/",
-    "average_spend": "AZN 35–55 per guest",
+    "average_spend": "AZN 35\u201355 per guest",
     "dress_code": "Casual",
     "experiences": [],
     "areas": [
@@ -1434,7 +1438,8 @@
     "city": "Baku",
     "id": "4b5d8a1e-afc1-5bed-bc61-3b74be372a56",
     "directions_url": "https://maps.google.com/?q=40.3698,49.8363",
-    "call_url": "tel:+994124981938"
+    "call_url": "tel:+994124981938",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Firuze Restaurant",
@@ -1465,11 +1470,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1528605248644-14dd04022da1?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3701,
-    "longitude": 49.8358,
+    "latitude": 40.370491,
+    "longitude": 49.837707,
     "menu_url": "https://firuze.az/menu",
     "instagram": "https://www.instagram.com/firuzerestoran/",
-    "average_spend": "AZN 40–65 per guest",
+    "average_spend": "AZN 40\u201365 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -1697,7 +1702,8 @@
     "city": "Baku",
     "id": "4be8a017-0089-5866-92b2-4e5679ad4e05",
     "directions_url": "https://maps.google.com/?q=40.3701,49.8358",
-    "call_url": "tel:+994503186545"
+    "call_url": "tel:+994503186545",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Nergiz Restaurant",
@@ -1732,7 +1738,7 @@
     "longitude": 49.8352,
     "menu_url": "https://nergizrestoran.az/menu",
     "instagram": "https://www.instagram.com/nergizrestoran/",
-    "average_spend": "AZN 35–60 per guest",
+    "average_spend": "AZN 35\u201360 per guest",
     "dress_code": "Casual",
     "experiences": [],
     "areas": [
@@ -1960,7 +1966,8 @@
     "city": "Baku",
     "id": "13edc326-a18c-5010-9651-891e8fa77fd9",
     "directions_url": "https://maps.google.com/?q=40.3702,49.8352",
-    "call_url": "tel:+994505476545"
+    "call_url": "tel:+994505476545",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Shah Restaurant & Gallery",
@@ -1995,7 +2002,7 @@
     "longitude": 49.8297,
     "menu_url": "https://shahrestaurant.az/menu",
     "instagram": "https://www.instagram.com/shahrestaurant/",
-    "average_spend": "AZN 70–120 per guest",
+    "average_spend": "AZN 70\u2013120 per guest",
     "dress_code": "Smart elegant",
     "experiences": [],
     "areas": [
@@ -2223,7 +2230,8 @@
     "city": "Baku",
     "id": "07d62433-5290-5553-b74c-783b2d12e2c3",
     "directions_url": "https://maps.google.com/?q=40.3655,49.8297",
-    "call_url": "tel:+994557723833"
+    "call_url": "tel:+994557723833",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Qala Divari",
@@ -2254,11 +2262,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3668,
-    "longitude": 49.8373,
+    "latitude": 40.368509,
+    "longitude": 49.835139,
     "menu_url": "https://qaladivari.az/menu",
     "instagram": "https://www.instagram.com/qala_divari/",
-    "average_spend": "AZN 40–70 per guest",
+    "average_spend": "AZN 40\u201370 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -2486,7 +2494,8 @@
     "city": "Baku",
     "id": "fdb388a9-a4fc-5653-84d9-a8bf71345f01",
     "directions_url": "https://maps.google.com/?q=40.3668,49.8373",
-    "call_url": "tel:+994505555051"
+    "call_url": "tel:+994505555051",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Qaynana Restaurant",
@@ -2505,7 +2514,7 @@
       "/assets/restaurants/qaynana/5.jpg"
     ],
     "cover_photo": "/assets/restaurants/qaynana/1.jpg",
-    "short_description": "Cozy ‘mother-in-law’ kitchen serving dolma, piti, and generous breakfast trays.",
+    "short_description": "Cozy \u2018mother-in-law\u2019 kitchen serving dolma, piti, and generous breakfast trays.",
     "neighborhood": "Icherisheher",
     "price_level": "AZN 2/4",
     "tags": [
@@ -2517,11 +2526,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1470337458703-46ad1756a187?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3665,
-    "longitude": 49.8379,
+    "latitude": 40.368625,
+    "longitude": 49.835968,
     "menu_url": "https://taplink.cc/qaynana_restaurant/menu",
     "instagram": "https://www.instagram.com/qaynana_restaurant/",
-    "average_spend": "AZN 30–55 per guest",
+    "average_spend": "AZN 30\u201355 per guest",
     "dress_code": "Casual",
     "experiences": [],
     "areas": [
@@ -2749,7 +2758,8 @@
     "city": "Baku",
     "id": "c1c03f77-481b-55e4-9251-f66966697521",
     "directions_url": "https://maps.google.com/?q=40.3665,49.8379",
-    "call_url": "tel:+994704340013"
+    "call_url": "tel:+994704340013",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Art Club Restaurant",
@@ -2780,11 +2790,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1527515637462-cff94eecc1ac?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.366,
-    "longitude": 49.8381,
+    "latitude": 40.364298,
+    "longitude": 49.833776,
     "menu_url": "https://artclub.az/menu",
     "instagram": "https://www.instagram.com/artclubrestaurant/",
-    "average_spend": "AZN 85–140 per guest",
+    "average_spend": "AZN 85\u2013140 per guest",
     "dress_code": "Smart elegant",
     "experiences": [],
     "areas": [
@@ -3012,7 +3022,8 @@
     "city": "Baku",
     "id": "917cea2c-73ba-572d-9c38-6ef7d2bbb90b",
     "directions_url": "https://maps.google.com/?q=40.366,49.8381",
-    "call_url": "tel:+994505258707"
+    "call_url": "tel:+994505258707",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Mugam Club Restaurant",
@@ -3043,11 +3054,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3659,
-    "longitude": 49.8384,
+    "latitude": 40.365657,
+    "longitude": 49.836729,
     "menu_url": "https://mugamclub.az/menu",
     "instagram": "https://www.instagram.com/mugamclub/",
-    "average_spend": "AZN 55–90 per guest",
+    "average_spend": "AZN 55\u201390 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -3275,7 +3286,8 @@
     "city": "Baku",
     "id": "4d74974e-1e42-5079-9f10-2560889767ac",
     "directions_url": "https://maps.google.com/?q=40.3659,49.8384",
-    "call_url": "tel:+994504402050"
+    "call_url": "tel:+994504402050",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Mari Vanna Baku",
@@ -3306,11 +3318,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1498654896293-37aacf113fd9?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3705,
-    "longitude": 49.845,
+    "latitude": 40.372957,
+    "longitude": 49.849614,
     "menu_url": "https://ginzaproj.com/en/restaurants/mari-vanna-baku/menu",
     "instagram": "https://www.instagram.com/marivannabaku/",
-    "average_spend": "AZN 70–120 per guest",
+    "average_spend": "AZN 70\u2013120 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -3538,7 +3550,8 @@
     "city": "Baku",
     "id": "0111b572-99be-518a-80e3-e0f6ac8cbf70",
     "directions_url": "https://maps.google.com/?q=40.3705,49.845",
-    "call_url": "tel:+994124049595"
+    "call_url": "tel:+994124049595",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Mangal Steak House",
@@ -3569,11 +3582,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1504674900247-0877df9cc836?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3521,
-    "longitude": 49.8209,
+    "latitude": 40.343132,
+    "longitude": 49.841416,
     "menu_url": "https://mangalsteakhouse.az/menu",
     "instagram": "https://www.instagram.com/mangal_steak_house/",
-    "average_spend": "AZN 80–140 per guest",
+    "average_spend": "AZN 80\u2013140 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -3801,10 +3814,11 @@
     "city": "Baku",
     "id": "cdedf570-3bb5-5cde-959f-351210b59d8b",
     "directions_url": "https://maps.google.com/?q=40.3521,49.8209",
-    "call_url": "tel:+994502281011"
+    "call_url": "tel:+994502281011",
+    "timezone": "Asia/Baku"
   },
   {
-    "name": "Paulaner Bräuhaus Baku",
+    "name": "Paulaner Br\u00e4uhaus Baku",
     "slug": "paulaner",
     "cuisine": [
       "German",
@@ -3834,7 +3848,7 @@
     "longitude": 49.8651,
     "menu_url": "https://paulaner-brauhaus-baku.com/menu",
     "instagram": "https://www.instagram.com/paulanerbaku/",
-    "average_spend": "AZN 55–85 per guest",
+    "average_spend": "AZN 55\u201385 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -4062,10 +4076,11 @@
     "city": "Baku",
     "id": "d721f224-f5d5-5f05-bbb6-84d77e8d7bf3",
     "directions_url": "https://maps.google.com/?q=40.3597,49.8651",
-    "call_url": "tel:+994124979797"
+    "call_url": "tel:+994124979797",
+    "timezone": "Asia/Baku"
   },
   {
-    "name": "Zafferano – Four Seasons Baku",
+    "name": "Zafferano \u2013 Four Seasons Baku",
     "slug": "zafferano",
     "cuisine": [
       "Italian",
@@ -4097,7 +4112,7 @@
     "longitude": 49.8408,
     "menu_url": "https://www.fourseasons.com/baku/dining/zafferano/menu",
     "instagram": "https://www.instagram.com/zafferanobaku/",
-    "average_spend": "AZN 120–200 per guest",
+    "average_spend": "AZN 120\u2013200 per guest",
     "dress_code": "Elegant",
     "experiences": [],
     "areas": [
@@ -4325,7 +4340,8 @@
     "city": "Baku",
     "id": "b4a9f7e7-7669-55ea-a9b7-d756c39a23f6",
     "directions_url": "https://maps.google.com/?q=40.3654,49.8408",
-    "call_url": "tel:+994124042424"
+    "call_url": "tel:+994124042424",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "OroNero Bar & Ristorante",
@@ -4360,7 +4376,7 @@
     "longitude": 49.8531,
     "menu_url": "https://oronero.az/menu",
     "instagram": "https://www.instagram.com/oronerobaku/",
-    "average_spend": "AZN 110–190 per guest",
+    "average_spend": "AZN 110\u2013190 per guest",
     "dress_code": "Elegant",
     "experiences": [],
     "areas": [
@@ -4588,7 +4604,8 @@
     "city": "Baku",
     "id": "7eeffd08-c7d2-54f3-9b5b-8ab0c61ff84e",
     "directions_url": "https://maps.google.com/?q=40.3723,49.8531",
-    "call_url": "tel:+994124998888"
+    "call_url": "tel:+994124998888",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "360 Bar",
@@ -4623,7 +4640,7 @@
     "longitude": 49.8379,
     "menu_url": "https://www.hilton.com/en/hotels/gydhbhi-hilton-baku/dining/360-bar",
     "instagram": "https://www.instagram.com/hiltonbaku/",
-    "average_spend": "AZN 65–95 per guest",
+    "average_spend": "AZN 65\u201395 per guest",
     "dress_code": "Smart chic",
     "experiences": [],
     "areas": [
@@ -4851,7 +4868,8 @@
     "city": "Baku",
     "id": "08238a17-ddcb-5e74-a4bc-8a4741ae78d5",
     "directions_url": "https://maps.google.com/?q=40.3692,49.8379",
-    "call_url": "tel:+994124645000"
+    "call_url": "tel:+994124645000",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Sky Grill",
@@ -4886,7 +4904,7 @@
     "longitude": 49.8379,
     "menu_url": "https://www.hilton.com/en/hotels/gydhbhi-hilton-baku/dining/sky-grill",
     "instagram": "https://www.instagram.com/hiltonbaku/",
-    "average_spend": "AZN 80–130 per guest",
+    "average_spend": "AZN 80\u2013130 per guest",
     "dress_code": "Smart chic",
     "experiences": [],
     "areas": [
@@ -5114,7 +5132,8 @@
     "city": "Baku",
     "id": "3b63d5eb-22d6-56a1-80a8-d6ff47ed82f3",
     "directions_url": "https://maps.google.com/?q=40.3692,49.8379",
-    "call_url": "tel:+994124645000"
+    "call_url": "tel:+994124645000",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Riviera Restaurant",
@@ -5145,11 +5164,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1470339000060-1f86b25eed17?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3542,
-    "longitude": 49.8236,
+    "latitude": 40.350001,
+    "longitude": 49.835068,
     "menu_url": "https://rivierabaku.az/menu",
     "instagram": "https://www.instagram.com/rivierabaku/",
-    "average_spend": "AZN 75–125 per guest",
+    "average_spend": "AZN 75\u2013125 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -5377,10 +5396,11 @@
     "city": "Baku",
     "id": "81554dc0-d0cd-51ca-ab72-eb3f8d5da646",
     "directions_url": "https://maps.google.com/?q=40.3542,49.8236",
-    "call_url": "tel:+994505444402"
+    "call_url": "tel:+994505444402",
+    "timezone": "Asia/Baku"
   },
   {
-    "name": "Novikov Café Baku",
+    "name": "Novikov Caf\u00e9 Baku",
     "slug": "novikov",
     "cuisine": [
       "European",
@@ -5408,11 +5428,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1470337458703-46ad1756a187?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3703,
-    "longitude": 49.8382,
+    "latitude": 40.368066,
+    "longitude": 49.838399,
     "menu_url": "https://novikov-cafe.com/menu",
     "instagram": "https://www.instagram.com/novikovcafe/",
-    "average_spend": "AZN 30–55 per guest",
+    "average_spend": "AZN 30\u201355 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -5640,7 +5660,8 @@
     "city": "Baku",
     "id": "a961f3a9-67fb-5689-a521-06c2b5d4edad",
     "directions_url": "https://maps.google.com/?q=40.3703,49.8382",
-    "call_url": "tel:+994512068543"
+    "call_url": "tel:+994512068543",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Nakhchivan Restaurant",
@@ -5661,7 +5682,7 @@
     ],
     "cover_photo": "/assets/restaurants/nakhchivan-restaurant/1.jpg",
     "short_description": "Regional dining room near Parliament Avenue serving piti, Ordubad kebabs and a samovar tea table in a vintage oil-boom interior.",
-    "neighborhood": "Parliament Avenue · Yasamal",
+    "neighborhood": "Parliament Avenue \u00b7 Yasamal",
     "price_level": "AZN 2/4",
     "tags": [
       "heritage",
@@ -5682,13 +5703,14 @@
     "menu_url": "https://baku.cafe/en/nakhchivan",
     "instagram": "https://www.instagram.com/nakhchivanrestaurant/",
     "whatsapp": "+994 51 385 85 58",
-    "average_spend": "AZN 30–60 per guest",
+    "average_spend": "AZN 30\u201360 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3638898,49.8193296",
-    "call_url": "tel:+994124808585"
+    "call_url": "tel:+994124808585",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Syrovarnya Baku",
@@ -5719,11 +5741,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1543353071-10c8ba85a904?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3709,
-    "longitude": 49.8446,
+    "latitude": 40.368453,
+    "longitude": 49.839537,
     "menu_url": "https://syrovarnya.com/menus/baku",
     "instagram": "https://www.instagram.com/syrovarnya.baku/",
-    "average_spend": "AZN 55–95 per guest",
+    "average_spend": "AZN 55\u201395 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -5951,7 +5973,8 @@
     "city": "Baku",
     "id": "eb7cd2b5-5e85-5ca4-b647-12e2a571f46e",
     "directions_url": "https://maps.google.com/?q=40.3709,49.8446",
-    "call_url": "tel:+994125250025"
+    "call_url": "tel:+994125250025",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Vapiano Baku",
@@ -5982,11 +6005,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1504674900247-0877df9cc836?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3725,
-    "longitude": 49.8491,
+    "latitude": 40.371001,
+    "longitude": 49.840997,
     "menu_url": "https://www.vapiano.az/menu",
     "instagram": "https://www.instagram.com/vapiano.baku/",
-    "average_spend": "AZN 25–40 per guest",
+    "average_spend": "AZN 25\u201340 per guest",
     "dress_code": "Casual",
     "experiences": [],
     "areas": [
@@ -6214,7 +6237,8 @@
     "city": "Baku",
     "id": "ba9f7284-ccee-5044-9786-fafda66ce184",
     "directions_url": "https://maps.google.com/?q=40.3725,49.8491",
-    "call_url": "tel:+994125988118"
+    "call_url": "tel:+994125988118",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Passage 145",
@@ -6245,11 +6269,11 @@
     "map_images": [
       "https://images.unsplash.com/photo-1470337458703-46ad1756a187?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3712,
-    "longitude": 49.8378,
+    "latitude": 40.371997,
+    "longitude": 49.83868,
     "menu_url": "https://145group.az/passage/menu",
     "instagram": "https://www.instagram.com/passage145/",
-    "average_spend": "AZN 35–60 per guest",
+    "average_spend": "AZN 35\u201360 per guest",
     "dress_code": "Casual",
     "experiences": [],
     "areas": [
@@ -6477,10 +6501,11 @@
     "city": "Baku",
     "id": "4b546ac5-7687-56a8-8d0c-d13cdb9e4b0a",
     "directions_url": "https://maps.google.com/?q=40.3712,49.8378",
-    "call_url": "tel:+994517000145"
+    "call_url": "tel:+994517000145",
+    "timezone": "Asia/Baku"
   },
   {
-    "name": "Çay Bağı 145",
+    "name": "\u00c7ay Ba\u011f\u0131 145",
     "slug": "caybagi145",
     "cuisine": [
       "Tea House",
@@ -6512,7 +6537,7 @@
     "longitude": 49.8368,
     "menu_url": "https://145group.az/caybagi/menu",
     "instagram": "https://www.instagram.com/caybagi145/",
-    "average_spend": "AZN 25–40 per guest",
+    "average_spend": "AZN 25\u201340 per guest",
     "dress_code": "Casual",
     "experiences": [],
     "areas": [
@@ -6740,7 +6765,8 @@
     "city": "Baku",
     "id": "e84ca3c6-a14f-5bc9-99f8-ad5d0d0e2caa",
     "directions_url": "https://maps.google.com/?q=40.3664,49.8368",
-    "call_url": "tel:+994506000145"
+    "call_url": "tel:+994506000145",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Baku Cafe",
@@ -6750,7 +6776,7 @@
       "Azerbaijani",
       "Seafood"
     ],
-    "address": "153 Neftçilər Prospekti, Bakı, Azerbaijan",
+    "address": "153 Neft\u00e7il\u0259r Prospekti, Bak\u0131, Azerbaijan",
     "phone": "+994 12 310 08 08",
     "photos": [
       "/assets/restaurants/baku-cafe/1.jpg",
@@ -6781,12 +6807,12 @@
     "map_images": [
       "https://images.unsplash.com/photo-1504674900247-0877df9cc836?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.376193,
-    "longitude": 49.861214,
+    "latitude": 40.375772,
+    "longitude": 49.862096,
     "menu_url": null,
     "instagram": "https://www.instagram.com/bakucafe.miami/",
     "whatsapp": "+994 12 310 08 08",
-    "average_spend": "AZN 110–160 per guest",
+    "average_spend": "AZN 110\u2013160 per guest",
     "dress_code": "Chic evening",
     "experiences": [],
     "areas": [
@@ -7194,7 +7220,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.376193,49.861214",
-    "call_url": "tel:+994123100808"
+    "call_url": "tel:+994123100808",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Baku Convention Center",
@@ -7203,7 +7230,7 @@
     "cuisine": [
       "Azerbaijani"
     ],
-    "address": "130 Təbriz küçəsi, Bakı, Azerbaijan",
+    "address": "130 T\u0259briz k\u00fc\u00e7\u0259si, Bak\u0131, Azerbaijan",
     "phone": "+994 12 404 18 81",
     "photos": [
       "/assets/restaurants/baku-convention-center/1.jpg",
@@ -7234,7 +7261,7 @@
     "menu_url": "http://bakuconventioncenter.com/",
     "instagram": "https://www.instagram.com/baku_convention_center/",
     "whatsapp": "+994 12 404 18 81",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -7642,7 +7669,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3974915,49.8654521",
-    "call_url": "tel:+994124041881"
+    "call_url": "tel:+994124041881",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Balcon Cafe",
@@ -7652,7 +7680,7 @@
       "Cafe",
       "Bar & Lounge"
     ],
-    "address": "Alov Qülleleri, Mehdi Hüseyn Street, Bakı, Azerbaijan",
+    "address": "Alov Q\u00fclleleri, Mehdi H\u00fcseyn Street, Bak\u0131, Azerbaijan",
     "phone": "+994 55 505 04 20",
     "photos": [
       "/assets/restaurants/balcon-cafe/1.jpg",
@@ -7685,7 +7713,7 @@
     "menu_url": "https://www.fairmont.com/en/hotels/barbados/fairmont-royal-pavilion.html",
     "instagram": "https://www.instagram.com/fairmonthotels/",
     "whatsapp": "+994 55 505 04 20",
-    "average_spend": "AZN 45–75 per guest",
+    "average_spend": "AZN 45\u201375 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -8093,7 +8121,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3598572,49.8266265",
-    "call_url": "tel:+994555050420"
+    "call_url": "tel:+994555050420",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "BESH Gastropub",
@@ -8103,7 +8132,7 @@
       "Cafe",
       "Patisserie"
     ],
-    "address": "300-303 quarter, intersection of M. Fuzuli and A. Topchubashov streets Nasimi district Baku, Bakı 1009, Azerbaijan",
+    "address": "300-303 quarter, intersection of M. Fuzuli and A. Topchubashov streets Nasimi district Baku, Bak\u0131 1009, Azerbaijan",
     "phone": "",
     "photos": [
       "/assets/restaurants/besh-gastropub/1.jpg",
@@ -8138,7 +8167,7 @@
     "menu_url": "https://www.marriott.com/en-us/destinations/united-states/california/santa-barbara.mi",
     "instagram": "https://www.instagram.com/courtyardbaku/",
     "whatsapp": "",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart nightlife",
     "experiences": [],
     "areas": [
@@ -8546,7 +8575,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3764701,49.83453489999999",
-    "call_url": ""
+    "call_url": "",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Black City Lounge & Terrace",
@@ -8556,7 +8586,7 @@
       "Patisserie",
       "Bar & Lounge"
     ],
-    "address": "4C Xəqani Rüstəmov, Bakı 1010, Azerbaijan",
+    "address": "4C X\u0259qani R\u00fcst\u0259mov, Bak\u0131 1010, Azerbaijan",
     "phone": "+994 12 310 00 40",
     "photos": [
       "/assets/restaurants/black-city-lounge-terrace/1.jpg",
@@ -8589,7 +8619,7 @@
     "menu_url": null,
     "instagram": "https://www.instagram.com/blackcitylounge/",
     "whatsapp": "+994 12 310 00 40",
-    "average_spend": "AZN 45–75 per guest",
+    "average_spend": "AZN 45\u201375 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -8997,7 +9027,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3749473,49.8836592",
-    "call_url": "tel:+994123100040"
+    "call_url": "tel:+994123100040",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Cafe City Fountain",
@@ -9007,7 +9038,7 @@
       "Azerbaijani",
       "Italian"
     ],
-    "address": "1 Islam Safarli Street, Bakı 1005, Azerbaijan",
+    "address": "1 Islam Safarli Street, Bak\u0131 1005, Azerbaijan",
     "phone": "+994 12 598 86 86",
     "photos": [
       "/assets/restaurants/cafe-city-fountain/1.jpg",
@@ -9043,7 +9074,7 @@
     "menu_url": "https://cafecity.az/products/cafecity-fountain/poke-bowl-menu",
     "instagram": "https://www.instagram.com/cafecitybaku/",
     "whatsapp": "+994 12 598 86 86",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart nightlife",
     "experiences": [],
     "areas": [
@@ -9451,7 +9482,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3703845,49.83580190000001",
-    "call_url": "tel:+994125988686"
+    "call_url": "tel:+994125988686",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Fireworks Urban Kitchen",
@@ -9461,7 +9493,7 @@
       "Japanese",
       "Steakhouse"
     ],
-    "address": "JW Marriott AZ1010, 674 Azadlıq Prospekti, Bakı, Azerbaijan",
+    "address": "JW Marriott AZ1010, 674 Azadl\u0131q Prospekti, Bak\u0131, Azerbaijan",
     "phone": "+994 12 499 88 88",
     "photos": [
       "/assets/restaurants/fireworks-urban-kitchen/1.jpg",
@@ -9497,7 +9529,7 @@
     "menu_url": "https://www.fireworks.az/en/",
     "instagram": "https://www.instagram.com/fireworksbaku/",
     "whatsapp": "+994 12 499 88 88",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart nightlife",
     "experiences": [],
     "areas": [
@@ -9905,7 +9937,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3742262,49.8564452",
-    "call_url": "tel:+994124998888"
+    "call_url": "tel:+994124998888",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Green House Asian Kitchen",
@@ -9915,7 +9948,7 @@
       "Patisserie",
       "Bar & Lounge"
     ],
-    "address": "Baku Marriott Hotel Bouelvard, Bakı, Azerbaijan",
+    "address": "Baku Marriott Hotel Bouelvard, Bak\u0131, Azerbaijan",
     "phone": "+994 12 310 00 10",
     "photos": [
       "/assets/restaurants/green-house-asian-kitchen/1.jpg",
@@ -9948,7 +9981,7 @@
     "menu_url": null,
     "instagram": "https://www.instagram.com/greenhouseasiankitchen/",
     "whatsapp": "+994 12 310 00 10",
-    "average_spend": "AZN 45–75 per guest",
+    "average_spend": "AZN 45\u201375 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -10356,7 +10389,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3751629,49.8836466",
-    "call_url": "tel:+994123100010"
+    "call_url": "tel:+994123100010",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Harbour Tap and Grill",
@@ -10365,7 +10399,7 @@
     "cuisine": [
       "Bar & Lounge"
     ],
-    "address": "153 Neftçilər Prospekti, Bakı 1010, Azerbaijan",
+    "address": "153 Neft\u00e7il\u0259r Prospekti, Bak\u0131 1010, Azerbaijan",
     "phone": "+994 12 404 82 05",
     "photos": [
       "/assets/restaurants/harbour-tap-and-grill/1.jpg",
@@ -10396,7 +10430,7 @@
     "menu_url": "https://drive.google.com/file/d/15-q-OFS03fOt60x1aQB3JX5x1ekn9HOm/view?usp=sharing",
     "instagram": "https://www.instagram.com/harbourbaku/",
     "whatsapp": "+994 12 404 82 05",
-    "average_spend": "AZN 45–75 per guest",
+    "average_spend": "AZN 45\u201375 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -10804,7 +10838,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3761593,49.8612501",
-    "call_url": "tel:+994124048205"
+    "call_url": "tel:+994124048205",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Hard Rock Cafe",
@@ -10814,7 +10849,7 @@
       "Japanese",
       "Bar & Lounge"
     ],
-    "address": "Fountain Square, 8 Əziz Əliyev küçəsi, Bakı 1000, Azerbaijan",
+    "address": "Fountain Square, 8 \u018fziz \u018fliyev k\u00fc\u00e7\u0259si, Bak\u0131 1000, Azerbaijan",
     "phone": "+994 12 404 82 28",
     "photos": [
       "/assets/restaurants/hard-rock-cafe/1.jpg",
@@ -10846,7 +10881,7 @@
     "menu_url": "https://cafe.hardrock.com/menu.aspx",
     "instagram": "https://www.instagram.com/hardrockcafe/",
     "whatsapp": "+994 12 404 82 28",
-    "average_spend": "AZN 45–75 per guest",
+    "average_spend": "AZN 45\u201375 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -11254,7 +11289,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.369031,49.837363",
-    "call_url": "tel:+994124048228"
+    "call_url": "tel:+994124048228",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "KEFLI Local Wine & Snacks",
@@ -11264,7 +11300,7 @@
       "Azerbaijani",
       "Seafood"
     ],
-    "address": "Tərlan Əliyarbəyov, Bakı, Azerbaijan",
+    "address": "T\u0259rlan \u018fliyarb\u0259yov, Bak\u0131, Azerbaijan",
     "phone": "+994 51 308 99 09",
     "photos": [
       "/assets/restaurants/kefli-local-wine-snacks/1.jpg",
@@ -11298,7 +11334,7 @@
     "menu_url": "https://www.facebook.com/kefliwinebar/?fref=ts",
     "instagram": "https://www.instagram.com/kefliwinebar/",
     "whatsapp": "+994 51 308 99 09",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart nightlife",
     "experiences": [],
     "areas": [
@@ -11706,10 +11742,11 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3684516,49.8398031",
-    "call_url": "tel:+994513089909"
+    "call_url": "tel:+994513089909",
+    "timezone": "Asia/Baku"
   },
   {
-    "name": "La Kükü",
+    "name": "La K\u00fck\u00fc",
     "slug": "la-kuku",
     "id": "5284ca0c-3c4a-4b42-a052-e33249045fc4",
     "cuisine": [
@@ -11726,7 +11763,7 @@
       "/assets/restaurants/la-kuku/5.jpg"
     ],
     "cover_photo": "/assets/restaurants/la-kuku/1.jpg",
-    "short_description": "La Kükü pairs modern Azeri flavors with third-wave coffee service in Downtown.",
+    "short_description": "La K\u00fck\u00fc pairs modern Azeri flavors with third-wave coffee service in Downtown.",
     "neighborhood": "Downtown",
     "price_level": "AZN 2/4",
     "tags": [
@@ -11747,7 +11784,7 @@
     "menu_url": "https://www.instagram.com/La_K%C3%BCk%C3%BC",
     "instagram": "https://www.instagram.com/la_kuku_baku/",
     "whatsapp": "+994 70 565 01 78",
-    "average_spend": "AZN 45–75 per guest",
+    "average_spend": "AZN 45\u201375 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -12155,7 +12192,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3653647,49.8315394",
-    "call_url": "tel:+994705650178"
+    "call_url": "tel:+994705650178",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "La Maison Patisserie&Cafe",
@@ -12164,7 +12202,7 @@
     "cuisine": [
       "International"
     ],
-    "address": "Nəsimi Rayonu, Nəsib bəy Yusifbəyli küçəsi, 9RWJ+G75, Bakı, Azerbaijan",
+    "address": "N\u0259simi Rayonu, N\u0259sib b\u0259y Yusifb\u0259yli k\u00fc\u00e7\u0259si, 9RWJ+G75, Bak\u0131, Azerbaijan",
     "phone": "+994 50 242 42 28",
     "photos": [],
     "cover_photo": "",
@@ -12189,7 +12227,7 @@
     "menu_url": null,
     "instagram": null,
     "whatsapp": "+994 50 242 42 28",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -12597,7 +12635,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3962712,49.8307464",
-    "call_url": "tel:+994502424228"
+    "call_url": "tel:+994502424228",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Latitude & Longitude Bar Lounge",
@@ -12607,7 +12646,7 @@
       "Azerbaijani",
       "Patisserie"
     ],
-    "address": "4, 6 Əziz Əliyev küçəsi, Bakı 1005, Azerbaijan",
+    "address": "4, 6 \u018fziz \u018fliyev k\u00fc\u00e7\u0259si, Bak\u0131 1005, Azerbaijan",
     "phone": "+994 51 206 85 81",
     "photos": [
       "/assets/restaurants/latitude-longitude-bar-lounge/1.jpg",
@@ -12640,7 +12679,7 @@
     "menu_url": "https://themerchantbaku.com/dining/",
     "instagram": "https://www.instagram.com/lalobarlounge/",
     "whatsapp": "+994 51 206 85 81",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart nightlife",
     "experiences": [],
     "areas": [
@@ -13048,7 +13087,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3683929,49.8380957",
-    "call_url": "tel:+994512068581"
+    "call_url": "tel:+994512068581",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Merci Baku",
@@ -13058,7 +13098,7 @@
       "Azerbaijani",
       "Seafood"
     ],
-    "address": "Asaf Zeynalli,16, AZ1000 Baku, Azerbaijan, Kichik Qala, Bakı 1000, Azerbaijan",
+    "address": "Asaf Zeynalli,16, AZ1000 Baku, Azerbaijan, Kichik Qala, Bak\u0131 1000, Azerbaijan",
     "phone": "+994 50 266 26 68",
     "photos": [
       "/assets/restaurants/merci-baku/1.jpg",
@@ -13092,7 +13132,7 @@
     "menu_url": "https://mercibaku.co/",
     "instagram": "https://www.instagram.com/merci_baku/",
     "whatsapp": "+994 50 266 26 68",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -13500,7 +13540,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.36452070000001,49.8349875",
-    "call_url": "tel:+994502662668"
+    "call_url": "tel:+994502662668",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Movida Lounge and Dining",
@@ -13510,7 +13551,7 @@
       "Seafood",
       "Italian"
     ],
-    "address": "Port Baku Towers, 153 Neftçilər Prospekti, Bakı 1010, Azerbaijan",
+    "address": "Port Baku Towers, 153 Neft\u00e7il\u0259r Prospekti, Bak\u0131 1010, Azerbaijan",
     "phone": "+994 50 229 10 60",
     "photos": [
       "/assets/restaurants/movida-lounge-and-dining/1.jpg",
@@ -13546,7 +13587,7 @@
     "menu_url": "https://drive.google.com/file/d/1-baXozOzQh0Me3IJDecBj8DjmVO7cQoi/view?usp=sharing",
     "instagram": "https://www.instagram.com/movidabaku/",
     "whatsapp": "+994 50 229 10 60",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart nightlife",
     "experiences": [],
     "areas": [
@@ -13954,7 +13995,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3758162,49.8614013",
-    "call_url": "tel:+994502291060"
+    "call_url": "tel:+994502291060",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Nur Lounge",
@@ -13964,7 +14006,7 @@
       "Seafood",
       "Japanese"
     ],
-    "address": "Fairmont Baku Azərbaycan, 1A, 1006 Mehdi Hüseyn Küçəsi, Bakı 1006, Azerbaijan",
+    "address": "Fairmont Baku Az\u0259rbaycan, 1A, 1006 Mehdi H\u00fcseyn K\u00fc\u00e7\u0259si, Bak\u0131 1006, Azerbaijan",
     "phone": "+994 55 505 04 30",
     "photos": [
       "/assets/restaurants/nur-lounge/1.jpg",
@@ -14000,7 +14042,7 @@
     "menu_url": "https://www.fairmont.com/en/hotels/barbados/fairmont-royal-pavilion.html",
     "instagram": "https://www.instagram.com/fairmontbaku/",
     "whatsapp": "+994 55 505 04 30",
-    "average_spend": "AZN 110–160 per guest",
+    "average_spend": "AZN 110\u2013160 per guest",
     "dress_code": "Chic evening",
     "experiences": [],
     "areas": [
@@ -14408,7 +14450,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3601143,49.8262438",
-    "call_url": "tel:+994555050430"
+    "call_url": "tel:+994555050430",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Paris Bistro",
@@ -14448,7 +14491,7 @@
     "menu_url": "https://monyo.az/?r=parisbistro",
     "instagram": "https://www.instagram.com/parisbistrobaku/",
     "whatsapp": "+994 10 265 44 94",
-    "average_spend": "AZN 45–75 per guest",
+    "average_spend": "AZN 45\u201375 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -14856,7 +14899,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3679021,49.8381549",
-    "call_url": "tel:+994102654494"
+    "call_url": "tel:+994102654494",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Pasifico Lounge and Dining",
@@ -14866,7 +14910,7 @@
       "Seafood",
       "Japanese"
     ],
-    "address": "Seaside Boulevard, 34 Neftçilər Prospekti, Bakı 1010, Azerbaijan",
+    "address": "Seaside Boulevard, 34 Neft\u00e7il\u0259r Prospekti, Bak\u0131 1010, Azerbaijan",
     "phone": "+994 50 285 00 21",
     "photos": [
       "/assets/restaurants/pasifico-lounge-and-dining/1.jpg",
@@ -14900,7 +14944,7 @@
     "menu_url": "http://pasifico.az/menu",
     "instagram": "https://www.instagram.com/pasificobaku/",
     "whatsapp": "+994 50 285 00 21",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart nightlife",
     "experiences": [],
     "areas": [
@@ -15308,7 +15352,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3696618,49.8454942",
-    "call_url": "tel:+994502850021"
+    "call_url": "tel:+994502850021",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "People Livebar",
@@ -15344,7 +15389,7 @@
     "menu_url": null,
     "instagram": "https://www.instagram.com/p/",
     "whatsapp": "+994 50 710 00 11",
-    "average_spend": "AZN 45–75 per guest",
+    "average_spend": "AZN 45\u201375 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -15752,7 +15797,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3724107,49.837528",
-    "call_url": "tel:+994507100011"
+    "call_url": "tel:+994507100011",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Porterhouse Grill & Wine",
@@ -15761,7 +15807,7 @@
     "cuisine": [
       "Steakhouse"
     ],
-    "address": "National Flag Square Complex, Bakı 1010, Azerbaijan",
+    "address": "National Flag Square Complex, Bak\u0131 1010, Azerbaijan",
     "phone": "+994 51 999 99 11",
     "photos": [
       "/assets/restaurants/porterhouse-grill-wine/1.jpg",
@@ -15789,7 +15835,7 @@
     "menu_url": null,
     "instagram": "https://www.instagram.com/porterhousebaku/",
     "whatsapp": "+994 51 999 99 11",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -16197,7 +16243,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3393445,49.8398498",
-    "call_url": "tel:+994519999911"
+    "call_url": "tel:+994519999911",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Prive Steak Gallery Baku",
@@ -16207,7 +16254,7 @@
       "Steakhouse",
       "Bar & Lounge"
     ],
-    "address": "14/a Xaqani Küçəsi, Bakı, Azerbaijan",
+    "address": "14/a Xaqani K\u00fc\u00e7\u0259si, Bak\u0131, Azerbaijan",
     "phone": "+994 12 598 05 55",
     "photos": [
       "/assets/restaurants/prive-steak-gallery-baku/1.jpg",
@@ -16238,7 +16285,7 @@
     "menu_url": "http://privebaku.com/az/menu/",
     "instagram": "https://www.instagram.com/prive_steak_gallery/",
     "whatsapp": "+994 12 598 05 55",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -16646,7 +16693,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3721495,49.8416105",
-    "call_url": "tel:+994125980555"
+    "call_url": "tel:+994125980555",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Scalini",
@@ -16686,12 +16734,12 @@
     "map_images": [
       "https://images.unsplash.com/photo-1498654896293-37aacf113fd9?auto=format&fit=crop&w=1200&q=80"
     ],
-    "latitude": 40.3755332,
-    "longitude": 49.8615678,
+    "latitude": 40.38627,
+    "longitude": 49.82526,
     "menu_url": "http://www.scalini.az/#menu",
     "instagram": "https://www.instagram.com/scalini_baku/",
     "whatsapp": "+994 12 404 82 07",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -17099,7 +17147,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3755332,49.8615678",
-    "call_url": "tel:+994124048207"
+    "call_url": "tel:+994124048207",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "SHUR",
@@ -17142,7 +17191,7 @@
     "menu_url": "https://www.facebook.com/shurbaku",
     "instagram": "https://www.instagram.com/shur.restaurant/",
     "whatsapp": "+994 12 493 02 72",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -17550,7 +17599,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3770909,49.8450813",
-    "call_url": "tel:+994124930272"
+    "call_url": "tel:+994124930272",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "SUSHI ROOM BAKU",
@@ -17592,7 +17642,7 @@
     "menu_url": "http://www.sushiroom.az/",
     "instagram": "https://www.instagram.com/sushiroom.az/",
     "whatsapp": "+994 55 587 90 30",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -18000,7 +18050,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3742065,49.844619",
-    "call_url": "tel:+994555879030"
+    "call_url": "tel:+994555879030",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "WOOGA Korean Steakhouse",
@@ -18010,7 +18061,7 @@
       "Seafood",
       "Steakhouse"
     ],
-    "address": "5 1-ci yaşıl ada, Bakı, Azerbaijan",
+    "address": "5 1-ci ya\u015f\u0131l ada, Bak\u0131, Azerbaijan",
     "phone": "+994 51 310 40 00",
     "photos": [
       "/assets/restaurants/wooga-korean-steakhouse/1.jpg",
@@ -18042,7 +18093,7 @@
     "menu_url": null,
     "instagram": "https://www.instagram.com/woogakoreansteakhouse/",
     "whatsapp": "+994 51 310 40 00",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart casual",
     "experiences": [],
     "areas": [
@@ -18450,7 +18501,8 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3811711,49.8836991",
-    "call_url": "tel:+994513104000"
+    "call_url": "tel:+994513104000",
+    "timezone": "Asia/Baku"
   },
   {
     "name": "Zest Lifestyle Cafe",
@@ -18460,7 +18512,7 @@
       "Azerbaijani",
       "Steakhouse"
     ],
-    "address": "107A Zarifa Aliyeva, Bakı 1010, Azerbaijan",
+    "address": "107A Zarifa Aliyeva, Bak\u0131 1010, Azerbaijan",
     "phone": "+994 12 499 88 88",
     "photos": [
       "/assets/restaurants/zest-lifestyle-cafe/1.jpg",
@@ -18496,7 +18548,7 @@
     "menu_url": "https://www.marriott.com/en-us/destinations/united-states/california/santa-barbara.mi",
     "instagram": "https://www.instagram.com/jwmarriottbaku/",
     "whatsapp": "+994 12 499 88 88",
-    "average_spend": "AZN 70–110 per guest",
+    "average_spend": "AZN 70\u2013110 per guest",
     "dress_code": "Smart nightlife",
     "experiences": [],
     "areas": [
@@ -18904,6 +18956,7 @@
     ],
     "city": "Baku",
     "directions_url": "https://maps.google.com/?q=40.3747401,49.856475",
-    "call_url": "tel:+994124998888"
+    "call_url": "tel:+994124998888",
+    "timezone": "Asia/Baku"
   }
 ]
diff --git a/backend/app/gomap.py b/backend/app/gomap.py
index 74a58f6..7282a74 100644
--- a/backend/app/gomap.py
+++ b/backend/app/gomap.py
@@ -10,6 +10,13 @@ from typing import Any
 import httpx
 
 from .settings import settings
+from .circuit_breaker import with_circuit_breaker, CircuitOpenError
+from .cache import (
+    cache_route, get_cached_route,
+    cache_geocode, get_cached_geocode,
+    cache_traffic, get_cached_traffic,
+)
+from .input_validation import InputValidator
 
 logger = logging.getLogger(__name__)
 
@@ -25,6 +32,30 @@ class GoMapRoute:
     raw: dict[str, Any] | None = None
 
 
+@dataclass(slots=True)
+class GoMapTraffic:
+    """Traffic conditions from GoMap API"""
+    severity: int | None  # 0-4 scale: 0=no data, 1=smooth, 2=moderate, 3=heavy, 4=severe
+    speed_kmh: float | None  # Current traffic speed if available
+    delay_minutes: int | None  # Estimated delay due to traffic
+    congestion_level: float | None  # 0.0-1.0 congestion percentage
+    raw: dict[str, Any] | None = None
+
+    @property
+    def condition(self) -> str:
+        """Convert severity to human-readable condition"""
+        if self.severity is None or self.severity == 0:
+            return "unknown"
+        elif self.severity == 1:
+            return "smooth"
+        elif self.severity == 2:
+            return "moderate"
+        elif self.severity == 3:
+            return "heavy"
+        else:
+            return "severe"
+
+
 def gomap_enabled() -> bool:
     return bool(settings.GOMAP_GUID and settings.GOMAP_BASE_URL)
 
@@ -68,14 +99,8 @@ def _parse_wrapped_json(text: str) -> dict[str, Any]:
         return {"success": False, "msg": stripped}
 
 
-def _post(path: str, data: dict[str, Any], *, language: str | None = None) -> dict[str, Any]:
-    if not gomap_enabled():
-        raise RuntimeError("GoMap API is not configured")
-    payload = {
-        **data,
-        "guid": settings.GOMAP_GUID,
-        "lng": _resolve_language(language),
-    }
+def _post_internal(path: str, payload: dict[str, Any]) -> dict[str, Any]:
+    """Internal post function that actually makes the HTTP request."""
     response = httpx.post(
         _endpoint(path),
         data=payload,
@@ -93,15 +118,84 @@ def _post(path: str, data: dict[str, Any], *, language: str | None = None) -> di
     return body
 
 
+def _post_with_retry(path: str, payload: dict[str, Any]) -> dict[str, Any]:
+    """Execute post with retry logic and exponential backoff."""
+    import time
+
+    last_error = None
+    backoff = settings.GOMAP_RETRY_BACKOFF_SECONDS
+
+    for attempt in range(settings.GOMAP_RETRY_ATTEMPTS + 1):
+        if attempt > 0:
+            # Exponential backoff for retries
+            sleep_time = backoff * (2 ** (attempt - 1))
+            logger.debug(
+                "Retrying GoMap %s after %.1f seconds (attempt %d/%d)",
+                path, sleep_time, attempt + 1, settings.GOMAP_RETRY_ATTEMPTS + 1
+            )
+            time.sleep(sleep_time)
+
+        try:
+            # Use circuit breaker for the actual HTTP call
+            return with_circuit_breaker(
+                _post_internal,
+                "gomap_api",
+                path,
+                payload
+            )
+        except CircuitOpenError:
+            # Circuit is open, don't retry
+            raise
+        except Exception as exc:
+            last_error = exc
+            if attempt < settings.GOMAP_RETRY_ATTEMPTS:
+                logger.warning(
+                    "GoMap %s failed (attempt %d/%d): %s",
+                    path, attempt + 1, settings.GOMAP_RETRY_ATTEMPTS + 1, exc
+                )
+            else:
+                # Final attempt failed
+                logger.error("GoMap %s failed after all retry attempts: %s", path, exc)
+
+    # All retries exhausted
+    raise last_error
+
+
+def _post(path: str, data: dict[str, Any], *, language: str | None = None) -> dict[str, Any]:
+    """Post to GoMap API with circuit breaker and retry logic."""
+    if not gomap_enabled():
+        raise RuntimeError("GoMap API is not configured")
+    payload = {
+        **data,
+        "guid": settings.GOMAP_GUID,
+        "lng": _resolve_language(language),
+    }
+    return _post_with_retry(path, payload)
+
+
 def search_objects(
     term: str, *, limit: int = 10, language: str | None = None
 ) -> list[dict[str, Any]]:
+    """
+    Search for objects by name with input validation.
+
+    Sanitizes the search term to prevent injection attacks.
+    """
     if not gomap_enabled():
         return []
-    query = term.strip()
-    if not query:
-        return []
+
+    # Validate and sanitize inputs (defense in depth)
+    query = InputValidator.validate_search_query(term, context="object search")
+    language = InputValidator.sanitize_language_code(language)
     limit = max(1, min(limit, 10))
+
+    # Check cache first
+    cache_key = f"{query}|{limit}|{_resolve_language(language)}"
+    cached_results = get_cached_geocode(cache_key)
+    if cached_results is not None:
+        logger.debug("Using cached geocode results for '%s'", query)
+        return cached_results[:limit]
+
     try:
         payload = _post("searchObj", {"name": query}, language=language)
     except Exception as exc:  # pragma: no cover - network/runtime
@@ -131,9 +225,324 @@ def search_objects(
         )
         if len(results) >= limit:
             break
+
+    # Cache the results
+    if results:
+        cache_key = f"{query}|{limit}|{_resolve_language(language)}"
+        cache_geocode(cache_key, results)
+
+    return results
+
+
+def search_objects_with_distance(
+    term: str,
+    origin_lat: float,
+    origin_lon: float,
+    *,
+    limit: int = 10,
+    language: str | None = None
+) -> list[dict[str, Any]]:
+    """Search for objects with distance calculations from a specific origin point.
+
+    Uses GoMap's searchObjWithDistance API which provides built-in distance calculations,
+    eliminating the need for manual Haversine calculations.
+
+    Args:
+        term: Search query
+        origin_lat: Origin latitude for distance calculations
+        origin_lon: Origin longitude for distance calculations
+        limit: Maximum number of results (1-50)
+        language: Language for results
+
+    Returns:
+        List of search results with distances from origin
+    """
+    if not gomap_enabled():
+        return []
+    query = term.strip()
+    if not query:
+        return []
+    limit = max(1, min(limit, 50))  # searchObjWithDistance supports more results
+
+    # Validate coordinates
+    if not (-90 <= origin_lat <= 90) or not (-180 <= origin_lon <= 180):
+        logger.warning("Invalid coordinates for distance search: lat=%f, lon=%f", origin_lat, origin_lon)
+        return []
+
+    # Check cache with origin coordinates included
+    cache_key = f"dist|{query}|{origin_lat:.4f}|{origin_lon:.4f}|{limit}|{_resolve_language(language)}"
+    cached_results = get_cached_geocode(cache_key)
+    if cached_results is not None:
+        logger.debug("Using cached distance search results for '%s'", query)
+        return cached_results[:limit]
+
+    try:
+        payload = _post(
+            "searchObjWithDistance",
+            {
+                "name": query,
+                "lat": f"{float(origin_lat):.6f}",
+                "lon": f"{float(origin_lon):.6f}",
+                "limit": str(limit),
+            },
+            language=language
+        )
+
+        # Log response structure for debugging
+        import json
+        logger.debug(
+            "searchObjWithDistance response sample: %s",
+            json.dumps(payload, indent=2, ensure_ascii=False)[:500]
+        )
+    except Exception as exc:
+        logger.warning("GoMap distance search failed: %s", exc)
+        # Fallback to regular search without distances
+        return search_objects(term, limit=limit, language=language)
+
+    if payload.get("success") is False:
+        logger.warning("Distance search failed: %s", payload.get("msg", "Unknown error"))
+        # Fallback to regular search
+        return search_objects(term, limit=limit, language=language)
+
+    rows: Iterable[dict[str, Any]] = payload.get("rows") or payload.get("result") or []
+    results: list[dict[str, Any]] = []
+
+    for row in rows:
+        lat = _coerce_float(row.get("y") or row.get("lat"))
+        lon = _coerce_float(row.get("x") or row.get("lon"))
+        if lat is None or lon is None:
+            continue
+
+        name = row.get("nm") or row.get("name") or row.get("poiName")
+        address = row.get("addr") or row.get("address") or row.get("fullAddress")
+        place_name = address or name
+
+        # Extract distance information - GoMap provides this directly!
+        distance_meters = None
+        distance_text = None
+
+        # Try multiple possible field names for distance
+        if "distance" in row:
+            distance_meters = _coerce_float(row["distance"])
+        elif "dist" in row:
+            distance_meters = _coerce_float(row["dist"])
+        elif "distanceMeters" in row:
+            distance_meters = _coerce_float(row["distanceMeters"])
+        elif "distance_m" in row:
+            distance_meters = _coerce_float(row["distance_m"])
+
+        # Try to get formatted distance text
+        if "distanceText" in row:
+            distance_text = row["distanceText"]
+        elif "dist_text" in row:
+            distance_text = row["dist_text"]
+        elif distance_meters is not None:
+            # Format distance ourselves if not provided
+            if distance_meters < 1000:
+                distance_text = f"{int(distance_meters)} m"
+            else:
+                distance_text = f"{distance_meters / 1000:.1f} km"
+
+        results.append(
+            {
+                "id": row.get("id") or row.get("object_id") or row.get("poiGuid") or name,
+                "name": name or place_name or query,
+                "place_name": place_name or name or query,
+                "address": address,
+                "latitude": lat,
+                "longitude": lon,
+                "distance_meters": distance_meters,
+                "distance_text": distance_text,
+                "provider": "gomap",
+                "raw": row,
+            }
+        )
+
+        if len(results) >= limit:
+            break
+
+    # Sort by distance if we have distance data
+    if results and results[0].get("distance_meters") is not None:
+        results.sort(key=lambda x: x.get("distance_meters", float('inf')))
+
+    # Cache the results
+    if results:
+        cache_geocode(cache_key, results)
+
+    return results
+
+
+def search_objects_fuzzy(
+    term: str,
+    *,
+    limit: int = 10,
+    language: str | None = None
+) -> list[dict[str, Any]]:
+    """Search for objects with fuzzy matching for typo tolerance.
+
+    Uses GoMap's makeSearchCitySettlementFuzzy API which handles misspellings
+    and typos using fuzzy string matching algorithms.
+
+    Args:
+        term: Search query (can contain typos)
+        limit: Maximum number of results
+        language: Language for results
+
+    Returns:
+        List of fuzzy-matched search results
+    """
+    if not gomap_enabled():
+        return []
+    query = term.strip()
+    if not query:
+        return []
+    limit = max(1, min(limit, 20))
+
+    # Check cache
+    cache_key = f"fuzzy|{query}|{limit}|{_resolve_language(language)}"
+    cached_results = get_cached_geocode(cache_key)
+    if cached_results is not None:
+        logger.debug("Using cached fuzzy search results for '%s'", query)
+        return cached_results[:limit]
+
+    try:
+        payload = _post(
+            "makeSearchCitySettlementFuzzy",
+            {
+                "q": query,  # Different parameter name for fuzzy search
+                "limit": str(limit),
+            },
+            language=language
+        )
+
+        logger.debug("Fuzzy search for '%s' returned %d results", query, len(payload.get("rows", [])))
+    except Exception as exc:
+        logger.warning("GoMap fuzzy search failed: %s", exc)
+        return []
+
+    if payload.get("success") is False:
+        logger.debug("Fuzzy search returned no results for '%s'", query)
+        return []
+
+    rows: Iterable[dict[str, Any]] = payload.get("rows") or payload.get("result") or []
+    results: list[dict[str, Any]] = []
+
+    for row in rows:
+        lat = _coerce_float(row.get("y") or row.get("lat"))
+        lon = _coerce_float(row.get("x") or row.get("lon"))
+        if lat is None or lon is None:
+            continue
+
+        name = row.get("nm") or row.get("name") or row.get("poiName")
+        address = row.get("addr") or row.get("address") or row.get("fullAddress")
+        place_name = address or name
+
+        # Fuzzy search may include a similarity score
+        similarity = row.get("similarity") or row.get("score") or row.get("confidence")
+
+        results.append(
+            {
+                "id": row.get("id") or row.get("object_id") or row.get("poiGuid") or name,
+                "name": name or place_name or query,
+                "place_name": place_name or name or query,
+                "address": address,
+                "latitude": lat,
+                "longitude": lon,
+                "similarity": similarity,  # How closely it matched
+                "provider": "gomap_fuzzy",
+                "raw": row,
+            }
+        )
+
+        if len(results) >= limit:
+            break
+
+    # Sort by similarity score if available
+    if results and results[0].get("similarity") is not None:
+        results.sort(key=lambda x: x.get("similarity", 0), reverse=True)
+
+    # Cache the results
+    if results:
+        cache_geocode(cache_key, results)
+
     return results
 
 
+def search_objects_smart(
+    term: str,
+    *,
+    origin_lat: float | None = None,
+    origin_lon: float | None = None,
+    limit: int = 10,
+    use_fuzzy_fallback: bool = True,
+    language: str | None = None
+) -> list[dict[str, Any]]:
+    """Smart search that combines distance-aware, exact, and fuzzy matching.
+
+    Tries search strategies in this order:
+    1. Distance-aware search (if origin provided)
+    2. Exact search
+    3. Fuzzy search (if enabled and previous searches return few results)
+
+    All inputs are validated to prevent injection attacks and API abuse.
+
+    Args:
+        term: Search query (sanitized)
+        origin_lat: Optional origin latitude (validated)
+        origin_lon: Optional origin longitude (validated)
+        limit: Maximum number of results
+        use_fuzzy_fallback: Whether to use fuzzy search as fallback
+        language: Language for results
+
+    Returns:
+        Best available search results
+    """
+    # Validate and sanitize inputs
+    term = InputValidator.validate_search_query(term, context="search term")
+    language = InputValidator.sanitize_language_code(language)
+
+    # Validate coordinates if provided
+    if origin_lat is not None and origin_lon is not None:
+        origin_lat, origin_lon = InputValidator.validate_coordinates(
+            origin_lat, origin_lon,
+            allow_outside_baku=True,
+            context="search origin coordinates"
+        )
+
+    results = []
+
+    # Try distance-aware search if we have origin
+    if origin_lat is not None and origin_lon is not None:
+        logger.debug("Trying distance-aware search for '%s'", term)
+        results = search_objects_with_distance(
+            term, origin_lat, origin_lon,
+            limit=limit, language=language
+        )
+        if len(results) >= min(3, limit):  # Got decent results
+            return results
+
+    # Try exact search if distance search failed or wasn't available
+    if not results:
+        logger.debug("Trying exact search for '%s'", term)
+        results = search_objects(term, limit=limit, language=language)
+        if len(results) >= min(3, limit):  # Got decent results
+            return results
+
+    # Try fuzzy search as fallback
+    if use_fuzzy_fallback and len(results) < min(3, limit):
+        logger.debug("Falling back to fuzzy search for '%s' (only %d exact results)", term, len(results))
+        fuzzy_results = search_objects_fuzzy(term, limit=limit - len(results), language=language)
+
+        # Merge fuzzy results with exact results, avoiding duplicates
+        seen_ids = {r.get("id") for r in results}
+        for fuzzy_result in fuzzy_results:
+            if fuzzy_result.get("id") not in seen_ids:
+                results.append(fuzzy_result)
+                seen_ids.add(fuzzy_result.get("id"))
+
+    return results[:limit]
+
+
 def reverse_geocode(
     latitude: float, longitude: float, *, language: str | None = None
 ) -> dict[str, Any] | None:
@@ -177,7 +586,7 @@ def _parse_geometry(points: Any) -> list[tuple[float, float]] | None:
         if isinstance(item, dict):
             lon = _coerce_float(item.get("x") or item.get("lon"))
             lat = _coerce_float(item.get("y") or item.get("lat"))
-        elif isinstance(item, list | tuple) and len(item) >= 2:
+        elif isinstance(item, (list, tuple)) and len(item) >= 2:
             lon = _coerce_float(item[0])
             lat = _coerce_float(item[1])
         elif isinstance(item, str) and "," in item:
@@ -188,20 +597,70 @@ def _parse_geometry(points: Any) -> list[tuple[float, float]] | None:
     return coords or None
 
 
+def _extract_number(value: str) -> float | None:
+    match = re.search(r"(-?\d+(?:[.,]\d+)?)", value)
+    if not match:
+        return None
+    try:
+        return float(match.group(1).replace(",", "."))
+    except ValueError:
+        return None
+
+
 def _normalize_distance(value: Any) -> float | None:
+    if value is None:
+        return None
+    if isinstance(value, str):
+        # Common GoMap fields like "Ümumi məsafə: 5.29 km."
+        extracted = _extract_number(value)
+        if extracted is not None:
+            value = extracted
+        elif "_" in value:
+            parts = value.split("_")
+            try:
+                value = float(parts[-1])
+            except ValueError:
+                value = None
     distance = _coerce_float(value)
     if distance is None:
         return None
-    if distance > 500:  # likely meters
+    if distance > 500:  # treat as meters
         return round(distance / 1000.0, 3)
     return round(distance, 3)
 
 
 def _normalize_duration_seconds(value: Any) -> int | None:
+    if value is None:
+        return None
+    if isinstance(value, str):
+        normalized = value.strip()
+        # Patterns: "Ümumi vaxt: 00 s. 06dəq.", "0_6", "6 dəq"
+        if "_" in value:
+            hours_str, minutes_str = value.split("_", 1)
+            try:
+                hours = float(hours_str)
+                minutes = float(minutes_str)
+                return max(1, int(round(hours * 3600 + minutes * 60)))
+            except ValueError:
+                pass
+        minute_match = re.search(r"(\d+)\s*(?:dəq|min)", normalized, re.IGNORECASE)
+        second_match = re.search(r"(\d+)\s*(?:s|san)", normalized, re.IGNORECASE)
+        total_seconds = 0
+        if minute_match:
+            total_seconds += int(minute_match.group(1)) * 60
+        if second_match:
+            total_seconds += int(second_match.group(1))
+        if total_seconds > 0:
+            return total_seconds
+        extracted = _extract_number(normalized)
+        if extracted is not None:
+            value = extracted
+        else:
+            value = normalized
     duration = _coerce_float(value)
     if duration is None:
         return None
-    if duration > 200:  # assume already seconds
+    if duration > 200:  # already seconds
         return max(1, int(round(duration)))
     return max(1, int(round(duration * 60)))
 
@@ -214,8 +673,36 @@ def route_directions(
     *,
     language: str | None = None,
 ) -> GoMapRoute | None:
+    """
+    Get route directions from GoMap API with input validation.
+
+    All inputs are validated to prevent injection attacks and API abuse.
+    """
     if not gomap_enabled():
         return None
+
+    # Validate and sanitize coordinates
+    origin_lat, origin_lon = InputValidator.validate_coordinates(
+        origin_lat, origin_lon,
+        allow_outside_baku=True,
+        context="origin coordinates"
+    )
+    dest_lat, dest_lon = InputValidator.validate_coordinates(
+        dest_lat, dest_lon,
+        allow_outside_baku=True,
+        context="destination coordinates"
+    )
+
+    # Validate language code
+    language = InputValidator.sanitize_language_code(language)
+
+    # Check cache first
+    cached = get_cached_route(origin_lat, origin_lon, dest_lat, dest_lon)
+    if cached is not None:
+        logger.debug("Using cached route for %.4f,%.4f to %.4f,%.4f",
+                    origin_lat, origin_lon, dest_lat, dest_lon)
+        return cached
+
     try:
         payload = _post(
             "getRoute",
@@ -233,8 +720,24 @@ def route_directions(
     if payload.get("success") is False:
         return None
 
-    distance_keys = ("distance", "Distance", "len", "length", "route_distance", "path_length")
-    duration_keys = ("time", "Time", "duration", "eta", "travel_time")
+    distance_keys = (
+        "distance",
+        "Distance",
+        "len",
+        "length",
+        "route_distance",
+        "path_length",
+        "ttllength",
+        "ttllength1",
+    )
+    duration_keys = (
+        "time1",
+        "time",
+        "Time",
+        "duration",
+        "eta",
+        "travel_time",
+    )
 
     distance_km = None
     for key in distance_keys:
@@ -257,7 +760,7 @@ def route_directions(
 
     notice = payload.get("msg") or payload.get("message") or payload.get("comment")
 
-    return GoMapRoute(
+    route = GoMapRoute(
         distance_km=distance_km,
         duration_seconds=duration_seconds,
         geometry=geometry,
@@ -265,11 +768,804 @@ def route_directions(
         raw=payload,
     )
 
+    # Cache the result
+    cache_route(origin_lat, origin_lon, dest_lat, dest_lon, route)
+
+    return route
+
+
+def route_directions_by_type(
+    origin_lat: float,
+    origin_lon: float,
+    dest_lat: float,
+    dest_lon: float,
+    *,
+    route_type: Literal["fastest", "shortest", "pedestrian"] = "fastest",
+    language: str | None = None,
+) -> GoMapRoute | None:
+    """Calculate route with specific routing preference.
+
+    Uses getRouteByType API to calculate different types of routes:
+    - fastest: Optimized for travel time (considers traffic, road speeds)
+    - shortest: Optimized for distance (may take longer)
+    - pedestrian: Walking directions (uses footpaths, avoids highways)
+
+    Args:
+        origin_lat: Origin latitude
+        origin_lon: Origin longitude
+        dest_lat: Destination latitude
+        dest_lon: Destination longitude
+        route_type: Type of route calculation
+        language: Language for instructions
+
+    Returns:
+        GoMapRoute optimized for the specified type
+    """
+    if not gomap_enabled():
+        return None
+
+    # Validate coordinates
+    if not (-90 <= origin_lat <= 90) or not (-180 <= origin_lon <= 180):
+        logger.warning("Invalid origin coordinates: lat=%f, lon=%f", origin_lat, origin_lon)
+        return None
+    if not (-90 <= dest_lat <= 90) or not (-180 <= dest_lon <= 180):
+        logger.warning("Invalid destination coordinates: lat=%f, lon=%f", dest_lat, dest_lon)
+        return None
+
+    # Check cache with route type
+    cache_key = f"{route_type}|{origin_lat:.5f}|{origin_lon:.5f}|{dest_lat:.5f}|{dest_lon:.5f}"
+    from .cache import get_cached_route, cache_route
+
+    # Try to get from cache (need to extend cache to support route type)
+    # For now, we'll proceed without cache for typed routes
+
+    try:
+        payload = _post(
+            "getRouteByType",
+            {
+                "Ax": f"{float(origin_lon):.6f}",
+                "Ay": f"{float(origin_lat):.6f}",
+                "Bx": f"{float(dest_lon):.6f}",
+                "By": f"{float(dest_lat):.6f}",
+                "type": route_type,
+            },
+            language=language,
+        )
+
+        logger.debug("Route by type '%s' response received", route_type)
+    except Exception as exc:
+        logger.warning("GoMap route by type failed: %s", exc)
+        # Fallback to basic route
+        return route_directions(origin_lat, origin_lon, dest_lat, dest_lon, language=language)
+
+    if payload.get("success") is False:
+        logger.warning("Route by type failed: %s", payload.get("msg", "Unknown error"))
+        # Fallback to basic route
+        return route_directions(origin_lat, origin_lon, dest_lat, dest_lon, language=language)
+
+    # Parse response (similar structure to basic route)
+    distance_keys = (
+        "distance",
+        "Distance",
+        "len",
+        "length",
+        "route_distance",
+        "path_length",
+        "ttllength",
+        "ttllength1",
+    )
+    duration_keys = (
+        "time1",
+        "time",
+        "Time",
+        "duration",
+        "eta",
+        "travel_time",
+    )
+
+    distance_km = None
+    for key in distance_keys:
+        distance_km = _normalize_distance(payload.get(key))
+        if distance_km is not None:
+            break
+
+    duration_seconds = None
+    for key in duration_keys:
+        duration_seconds = _normalize_duration_seconds(payload.get(key))
+        if duration_seconds is not None:
+            break
+
+    # Adjust duration for pedestrian routes (walking is slower)
+    if route_type == "pedestrian" and distance_km and not duration_seconds:
+        # Assume 5 km/h walking speed if duration not provided
+        duration_seconds = int((distance_km / 5.0) * 3600)
+
+    geometry = _parse_geometry(
+        payload.get("route") or
+        payload.get("geometry") or
+        payload.get("points") or
+        payload.get("coords")
+    )
+
+    notice = payload.get("msg") or payload.get("message") or payload.get("comment")
+    if route_type == "pedestrian":
+        notice = f"Walking route: {notice}" if notice else "Walking route"
+    elif route_type == "shortest":
+        notice = f"Shortest route: {notice}" if notice else "Shortest route"
+
+    route = GoMapRoute(
+        distance_km=distance_km,
+        duration_seconds=duration_seconds,
+        geometry=geometry,
+        notice=notice,
+        raw=payload,
+    )
+
+    return route
+
+
+def route_directions_detailed(
+    origin_lat: float,
+    origin_lon: float,
+    dest_lat: float,
+    dest_lon: float,
+    *,
+    include_polyline: bool = True,
+    language: str | None = None,
+) -> GoMapRoute | None:
+    """Get detailed route with full polyline coordinates.
+
+    Uses getRouteCoords API to get dense coordinate data for smooth map rendering.
+
+    Args:
+        origin_lat: Origin latitude
+        origin_lon: Origin longitude
+        dest_lat: Destination latitude
+        dest_lon: Destination longitude
+        include_polyline: Whether to fetch full polyline coordinates
+        language: Language for instructions
+
+    Returns:
+        GoMapRoute with detailed geometry for visualization
+    """
+    if not gomap_enabled():
+        return None
+
+    # Get base route first
+    route = route_directions(origin_lat, origin_lon, dest_lat, dest_lon, language=language)
+    if not route or not include_polyline:
+        return route
+
+    # Fetch detailed polyline coordinates
+    try:
+        payload = _post(
+            "getRouteCoords",
+            {
+                "Ax": f"{float(origin_lon):.6f}",
+                "Ay": f"{float(origin_lat):.6f}",
+                "Bx": f"{float(dest_lon):.6f}",
+                "By": f"{float(dest_lat):.6f}",
+            },
+            language=language,
+        )
+
+        # Parse detailed coordinates
+        if payload.get("success") is not False:
+            detailed_geometry = _parse_geometry(
+                payload.get("coordinates") or
+                payload.get("coords") or
+                payload.get("polyline") or
+                payload.get("points")
+            )
+
+            if detailed_geometry and len(detailed_geometry) > len(route.geometry or []):
+                # Use the more detailed geometry
+                route.geometry = detailed_geometry
+                logger.debug(
+                    "Enhanced route with %d polyline points (was %d)",
+                    len(detailed_geometry),
+                    len(route.geometry) if route.geometry else 0
+                )
+    except Exception as exc:
+        logger.warning("Failed to fetch detailed route coordinates: %s", exc)
+        # Continue with basic route
+
+    return route
+
+
+def search_nearby_pois(
+    latitude: float,
+    longitude: float,
+    *,
+    radius_km: float = 2.0,
+    limit: int = 10,
+    category: str | None = None,
+    language: str | None = None
+) -> list[dict[str, Any]]:
+    """Discover POIs near a specific location.
+
+    Uses searchNearBy/searchNearBy50 APIs to find places within a radius,
+    sorted by distance from the origin point.
+
+    Args:
+        latitude: Center point latitude
+        longitude: Center point longitude
+        radius_km: Search radius in kilometers (default 2km)
+        limit: Maximum results (10 or 50)
+        category: Optional category filter (restaurant, cafe, etc.)
+        language: Language for results
+
+    Returns:
+        List of nearby POIs sorted by distance
+    """
+    if not gomap_enabled():
+        return []
+
+    # Validate and sanitize inputs
+    latitude, longitude = InputValidator.validate_coordinates(
+        latitude, longitude,
+        allow_outside_baku=True,
+        context="nearby POI search coordinates"
+    )
+    radius_km = InputValidator.validate_radius(radius_km, max_km=50.0)
+    language = InputValidator.sanitize_language_code(language)
+
+    # Determine which API to use based on limit
+    api_method = "searchNearBy50" if limit > 10 else "searchNearBy"
+    actual_limit = min(50 if limit > 10 else 10, limit)
+
+    # Cache key includes location and radius
+    cache_key = f"nearby|{latitude:.4f}|{longitude:.4f}|{radius_km:.1f}|{actual_limit}|{category}|{_resolve_language(language)}"
+    cached_results = get_cached_geocode(cache_key)
+    if cached_results is not None:
+        logger.debug("Using cached nearby POI results")
+        return cached_results[:actual_limit]
+
+    try:
+        request_data = {
+            "lat": f"{float(latitude):.6f}",
+            "lon": f"{float(longitude):.6f}",
+            "radius": str(int(radius_km * 1000)),  # Convert to meters
+        }
+
+        # Add category filter if specified
+        if category:
+            request_data["category"] = category
+
+        payload = _post(api_method, request_data, language=language)
+
+        logger.debug(
+            "Nearby POI search at %.4f,%.4f (radius %.1fkm) returned %d results",
+            latitude, longitude, radius_km, len(payload.get("rows", []))
+        )
+    except Exception as exc:
+        logger.warning("GoMap nearby search failed: %s", exc)
+        return []
+
+    if payload.get("success") is False:
+        logger.debug("Nearby search returned no results")
+        return []
+
+    rows: Iterable[dict[str, Any]] = payload.get("rows") or payload.get("result") or []
+    results: list[dict[str, Any]] = []
+
+    for row in rows:
+        lat = _coerce_float(row.get("y") or row.get("lat"))
+        lon = _coerce_float(row.get("x") or row.get("lon"))
+        if lat is None or lon is None:
+            continue
+
+        name = row.get("nm") or row.get("name") or row.get("poiName")
+        address = row.get("addr") or row.get("address") or row.get("fullAddress")
+        place_name = address or name
+
+        # Extract distance (should be provided by nearby API)
+        distance_meters = None
+        distance_text = None
+
+        if "distance" in row:
+            distance_meters = _coerce_float(row["distance"])
+        elif "dist" in row:
+            distance_meters = _coerce_float(row["dist"])
+        elif "distanceMeters" in row:
+            distance_meters = _coerce_float(row["distanceMeters"])
+
+        # Format distance text
+        if distance_meters is not None:
+            if distance_meters < 1000:
+                distance_text = f"{int(distance_meters)} m"
+            else:
+                distance_text = f"{distance_meters / 1000:.1f} km"
+
+        # Extract category/type if available
+        poi_category = row.get("category") or row.get("type") or row.get("poi_type")
+
+        results.append(
+            {
+                "id": row.get("id") or row.get("object_id") or row.get("poiGuid") or name,
+                "name": name or place_name,
+                "place_name": place_name or name,
+                "address": address,
+                "latitude": lat,
+                "longitude": lon,
+                "distance_meters": distance_meters,
+                "distance_text": distance_text,
+                "category": poi_category,
+                "provider": "gomap_nearby",
+                "raw": row,
+            }
+        )
+
+        if len(results) >= actual_limit:
+            break
+
+    # Results should already be sorted by distance from the API
+    # But ensure they are sorted if distance data exists
+    if results and results[0].get("distance_meters") is not None:
+        results.sort(key=lambda x: x.get("distance_meters", float('inf')))
+
+    # Cache the results
+    if results:
+        cache_geocode(cache_key, results)
+
+    return results[:actual_limit]
+
+
+def search_nearby_pois_paginated(
+    latitude: float,
+    longitude: float,
+    *,
+    radius_km: float = 2.0,
+    page: int = 1,
+    per_page: int = 20,
+    category: str | None = None,
+    language: str | None = None
+) -> dict[str, Any]:
+    """Discover POIs near a location with pagination support.
+
+    Uses searchNearByPage API for paginated results.
+
+    Args:
+        latitude: Center point latitude
+        longitude: Center point longitude
+        radius_km: Search radius in kilometers
+        page: Page number (1-indexed)
+        per_page: Results per page
+        category: Optional category filter
+        language: Language for results
+
+    Returns:
+        Dict with 'items', 'total', 'page', 'pages' keys
+    """
+    if not gomap_enabled():
+        return {"items": [], "total": 0, "page": page, "pages": 0}
+
+    # Validate inputs
+    if not (-90 <= latitude <= 90) or not (-180 <= longitude <= 180):
+        logger.warning("Invalid coordinates for paginated nearby search")
+        return {"items": [], "total": 0, "page": page, "pages": 0}
+
+    page = max(1, page)
+    per_page = max(1, min(50, per_page))
+
+    try:
+        request_data = {
+            "lat": f"{float(latitude):.6f}",
+            "lon": f"{float(longitude):.6f}",
+            "radius": str(int(radius_km * 1000)),
+            "page": str(page),
+            "limit": str(per_page),
+        }
+
+        if category:
+            request_data["category"] = category
+
+        payload = _post("searchNearByPage", request_data, language=language)
+
+        logger.debug(
+            "Paginated nearby search (page %d) returned results",
+            page
+        )
+    except Exception as exc:
+        logger.warning("GoMap paginated nearby search failed: %s", exc)
+        return {"items": [], "total": 0, "page": page, "pages": 0}
+
+    if payload.get("success") is False:
+        return {"items": [], "total": 0, "page": page, "pages": 0}
+
+    # Parse pagination info
+    total_results = int(payload.get("total", 0))
+    total_pages = int(payload.get("pages", 0))
+
+    # If pagination info not provided, calculate it
+    if not total_pages and total_results:
+        total_pages = (total_results + per_page - 1) // per_page
+
+    # Parse results (same as non-paginated version)
+    rows: Iterable[dict[str, Any]] = payload.get("rows") or payload.get("result") or []
+    items: list[dict[str, Any]] = []
+
+    for row in rows:
+        lat = _coerce_float(row.get("y") or row.get("lat"))
+        lon = _coerce_float(row.get("x") or row.get("lon"))
+        if lat is None or lon is None:
+            continue
+
+        name = row.get("nm") or row.get("name") or row.get("poiName")
+        address = row.get("addr") or row.get("address")
+        distance_meters = _coerce_float(row.get("distance") or row.get("dist"))
+
+        distance_text = None
+        if distance_meters is not None:
+            if distance_meters < 1000:
+                distance_text = f"{int(distance_meters)} m"
+            else:
+                distance_text = f"{distance_meters / 1000:.1f} km"
+
+        items.append({
+            "id": row.get("id") or row.get("object_id") or name,
+            "name": name,
+            "address": address,
+            "latitude": lat,
+            "longitude": lon,
+            "distance_meters": distance_meters,
+            "distance_text": distance_text,
+            "category": row.get("category") or row.get("type"),
+            "provider": "gomap_nearby",
+        })
+
+    return {
+        "items": items,
+        "total": total_results,
+        "page": page,
+        "pages": total_pages,
+        "per_page": per_page,
+    }
+
+
+def get_poi_details(
+    poi_guid: str,
+    *,
+    include_images: bool = False,
+    language: str | None = None
+) -> dict[str, Any] | None:
+    """Get detailed information about a specific POI.
+
+    Uses getDetailsByPoi_GUID API to fetch comprehensive POI metadata including:
+    - Full name and description
+    - Complete address
+    - Contact information (phone, email, website)
+    - Opening hours
+    - Category/type
+    - Ratings and reviews count (if available)
+
+    Args:
+        poi_guid: Unique identifier of the POI
+        include_images: Whether to fetch POI images
+        language: Language for descriptions
+
+    Returns:
+        Detailed POI information or None if not found
+    """
+    if not gomap_enabled():
+        return None
+
+    if not poi_guid:
+        return None
+
+    # Cache key for POI details
+    cache_key = f"poi_details|{poi_guid}|{_resolve_language(language)}"
+    cached = get_cached_geocode(cache_key)
+    if cached is not None:
+        logger.debug("Using cached POI details for GUID %s", poi_guid)
+        # Add images if requested and not in cache
+        if include_images and "images" not in cached:
+            images = get_poi_images(poi_guid)
+            if images:
+                cached["images"] = images
+        return cached
+
+    try:
+        payload = _post(
+            "getDetailsByPoi_GUID",
+            {"guid": poi_guid},
+            language=language
+        )
+
+        logger.debug("POI details fetched for GUID %s", poi_guid)
+    except Exception as exc:
+        logger.warning("Failed to fetch POI details for %s: %s", poi_guid, exc)
+        return None
+
+    if payload.get("success") is False:
+        logger.debug("No POI details found for GUID %s", poi_guid)
+        return None
+
+    # Parse POI details
+    poi_data = payload.get("poi") or payload.get("data") or payload
+
+    # Extract all available information
+    details = {
+        "guid": poi_guid,
+        "name": poi_data.get("name") or poi_data.get("nm"),
+        "description": poi_data.get("description") or poi_data.get("desc"),
+        "address": poi_data.get("address") or poi_data.get("addr"),
+        "latitude": _coerce_float(poi_data.get("lat") or poi_data.get("y")),
+        "longitude": _coerce_float(poi_data.get("lon") or poi_data.get("x")),
+        "category": poi_data.get("category") or poi_data.get("type"),
+        "subcategory": poi_data.get("subcategory"),
+        "phone": poi_data.get("phone") or poi_data.get("tel"),
+        "email": poi_data.get("email"),
+        "website": poi_data.get("website") or poi_data.get("url"),
+        "opening_hours": poi_data.get("opening_hours") or poi_data.get("hours"),
+        "rating": _coerce_float(poi_data.get("rating")),
+        "reviews_count": _coerce_int(poi_data.get("reviews_count") or poi_data.get("reviews")),
+        "price_level": poi_data.get("price_level") or poi_data.get("price"),
+        "features": poi_data.get("features") or poi_data.get("amenities"),
+        "provider": "gomap",
+        "raw": poi_data,
+    }
+
+    # Clean up None values
+    details = {k: v for k, v in details.items() if v is not None}
+
+    # Fetch images if requested
+    if include_images:
+        images = get_poi_images(poi_guid)
+        if images:
+            details["images"] = images
+
+    # Cache the result
+    cache_geocode(cache_key, details)
+
+    return details
+
+
+def get_poi_images(
+    poi_guid: str,
+    *,
+    limit: int = 10
+) -> list[dict[str, Any]] | None:
+    """Get images for a specific POI.
+
+    Uses getImageByPoi_GUID API to fetch POI photos.
+
+    Args:
+        poi_guid: Unique identifier of the POI
+        limit: Maximum number of images to return
+
+    Returns:
+        List of image information or None if no images
+    """
+    if not gomap_enabled():
+        return None
+
+    if not poi_guid:
+        return None
+
+    try:
+        payload = _post(
+            "getImageByPoi_GUID",
+            {
+                "guid": poi_guid,
+                "limit": str(limit),
+            }
+        )
+
+        logger.debug("POI images fetched for GUID %s", poi_guid)
+    except Exception as exc:
+        logger.warning("Failed to fetch POI images for %s: %s", poi_guid, exc)
+        return None
+
+    if payload.get("success") is False:
+        return None
+
+    # Parse image data
+    images_data = payload.get("images") or payload.get("photos") or payload.get("result") or []
+    if not isinstance(images_data, list):
+        images_data = [images_data]
+
+    images = []
+    for img in images_data:
+        if isinstance(img, dict):
+            image_info = {
+                "url": img.get("url") or img.get("src"),
+                "thumbnail": img.get("thumbnail") or img.get("thumb"),
+                "caption": img.get("caption") or img.get("title"),
+                "width": _coerce_int(img.get("width")),
+                "height": _coerce_int(img.get("height")),
+                "size": img.get("size"),
+            }
+        elif isinstance(img, str):
+            # Simple URL string
+            image_info = {"url": img}
+        else:
+            continue
+
+        # Clean up None values
+        image_info = {k: v for k, v in image_info.items() if v is not None}
+        if image_info.get("url"):
+            images.append(image_info)
+
+        if len(images) >= limit:
+            break
+
+    return images if images else None
+
+
+def get_poi_description(
+    poi_guid: str,
+    *,
+    language: str | None = None
+) -> str | None:
+    """Get detailed description for a POI.
+
+    Uses getDescriptionByPoi_GUID API for longer descriptions.
+
+    Args:
+        poi_guid: Unique identifier of the POI
+        language: Language for description
+
+    Returns:
+        POI description text or None
+    """
+    if not gomap_enabled():
+        return None
+
+    try:
+        payload = _post(
+            "getDescriptionByPoi_GUID",
+            {"guid": poi_guid},
+            language=language
+        )
+
+        return payload.get("description") or payload.get("text")
+    except Exception as exc:
+        logger.warning("Failed to fetch POI description for %s: %s", poi_guid, exc)
+        return None
+
+
+def _coerce_int(value: Any) -> int | None:
+    """Convert value to int if possible."""
+    if value is None:
+        return None
+    try:
+        return int(value)
+    except (TypeError, ValueError):
+        return None
+
+
+def get_traffic_conditions(
+    latitude: float,
+    longitude: float,
+    radius_km: float = 2.0,
+    *,
+    language: str | None = None,
+) -> GoMapTraffic | None:
+    """Get traffic conditions for a specific coordinate from GoMap API.
+
+    Args:
+        latitude: Latitude of the point
+        longitude: Longitude of the point
+        radius_km: Radius in km to check traffic (default 2km)
+        language: Language for response
+
+    Returns:
+        GoMapTraffic object with traffic severity and conditions, or None if unavailable
+    """
+    if not gomap_enabled():
+        return None
+
+    if not settings.GOMAP_TRAFFIC_ENABLED:
+        return None
+
+    # Check cache first
+    cached = get_cached_traffic(latitude, longitude, radius_km)
+    if cached is not None:
+        logger.debug("Using cached traffic for %.4f,%.4f", latitude, longitude)
+        return cached
+
+    try:
+        # Call GoMap traffic API
+        payload = _post(
+            "getTrafficTilesByCoord",
+            {
+                "lat": f"{float(latitude):.6f}",
+                "lon": f"{float(longitude):.6f}",
+                "radius": str(int(radius_km * 1000)),  # Convert to meters
+            },
+            language=language,
+        )
+
+        # DEBUG: Log the actual API response structure
+        import json
+        logger.info(
+            "Traffic API raw response for lat=%.4f, lon=%.4f: %s",
+            latitude, longitude,
+            json.dumps(payload, indent=2, ensure_ascii=False)[:1000]  # Truncate for logging
+        )
+    except Exception as exc:
+        logger.warning("GoMap traffic check failed: %s", exc)
+        return None
+
+    if payload.get("success") is False:
+        logger.warning("Traffic API returned success=false: %s", payload.get("msg", "Unknown error"))
+        return None
+
+    # Parse traffic response - enhanced parsing with multiple fallback strategies
+    # Try multiple possible response structures
+    traffic_data = (
+        payload.get("traffic") or
+        payload.get("data") or
+        payload.get("result") or
+        payload.get("trafficInfo") or
+        payload.get("tiles") or
+        {}
+    )
+
+    # If traffic_data is a list, try to get the first item or aggregate
+    if isinstance(traffic_data, list) and traffic_data:
+        traffic_data = traffic_data[0] if len(traffic_data) == 1 else {"items": traffic_data}
+
+    # Extract traffic severity (usually on a scale)
+    severity = None
+    if "severity" in traffic_data:
+        severity = int(traffic_data["severity"])
+    elif "level" in traffic_data:
+        severity = int(traffic_data["level"])
+    elif "congestion" in traffic_data:
+        # Convert congestion percentage to severity scale
+        congestion = float(traffic_data["congestion"])
+        if congestion < 0.2:
+            severity = 1  # smooth
+        elif congestion < 0.4:
+            severity = 2  # moderate
+        elif congestion < 0.7:
+            severity = 3  # heavy
+        else:
+            severity = 4  # severe
+
+    # Extract speed if available
+    speed_kmh = None
+    if "speed" in traffic_data:
+        speed_kmh = _coerce_float(traffic_data["speed"])
+    elif "avgSpeed" in traffic_data:
+        speed_kmh = _coerce_float(traffic_data["avgSpeed"])
+
+    # Extract delay if available
+    delay_minutes = None
+    if "delay" in traffic_data:
+        delay_minutes = int(traffic_data["delay"])
+    elif "delayMinutes" in traffic_data:
+        delay_minutes = int(traffic_data["delayMinutes"])
+
+    # Extract congestion level
+    congestion_level = None
+    if "congestion" in traffic_data:
+        congestion_level = _coerce_float(traffic_data["congestion"])
+    elif "congestionLevel" in traffic_data:
+        congestion_level = _coerce_float(traffic_data["congestionLevel"])
+
+    traffic = GoMapTraffic(
+        severity=severity,
+        speed_kmh=speed_kmh,
+        delay_minutes=delay_minutes,
+        congestion_level=congestion_level,
+        raw=payload,
+    )
+
+    # Cache the result
+    cache_traffic(latitude, longitude, radius_km, traffic)
+
+    return traffic
+
 
 __all__ = [
     "GoMapRoute",
+    "GoMapTraffic",
     "gomap_enabled",
     "route_directions",
     "search_objects",
     "reverse_geocode",
+    "get_traffic_conditions",
 ]
diff --git a/backend/app/main.py b/backend/app/main.py
index 571891f..a463049 100644
--- a/backend/app/main.py
+++ b/backend/app/main.py
@@ -5,14 +5,27 @@ from typing import Annotated, Any
 from uuid import UUID
 
 import sentry_sdk
-from fastapi import Body, Depends, FastAPI, HTTPException, Query, Request
+from fastapi import APIRouter, Body, Depends, FastAPI, HTTPException, Query, Request
 from fastapi.responses import RedirectResponse
 from fastapi.staticfiles import StaticFiles
 from sentry_sdk.integrations.fastapi import FastApiIntegration
 
+from .api.routes import gomap as gomap_routes
+from .api.routes import reservations as reservations_routes
+from .api.routes import restaurants as restaurants_routes
+from .api.types import CoordinateString, DateQuery, RestaurantSearch
+from .api.utils import haversine_km, parse_coordinate_string
 from .auth import require_auth
 from .availability import availability_for_day
 from .concierge_service import concierge_service
+from .gomap import (
+    route_directions,
+    route_directions_by_type,
+    route_directions_detailed,
+    search_nearby_pois,
+    search_nearby_pois_paginated,
+    search_objects_smart,
+)
 from .maps import build_fallback_eta, compute_eta_with_traffic, search_places
 from .models import (
     ArrivalEtaConfirmation,
@@ -20,6 +33,7 @@ from .models import (
     ArrivalIntentDecision,
     ArrivalIntentRequest,
     ArrivalLocationPing,
+    ArrivalLocationSuggestion,
     GeocodeResult,
     Reservation,
     ReservationCreate,
@@ -36,30 +50,20 @@ from .serializers import get_attr, restaurant_to_detail, restaurant_to_list_item
 from .settings import settings
 from .storage import DB
 from .ui import router as ui_router
-from .utils import add_cors, add_rate_limiting, add_security_headers
-
-DateQuery = Annotated[date, Query(alias="date")]
-AuthClaims = Annotated[dict[str, Any], Depends(require_auth)]
-CoordinateString = Annotated[
-    str,
-    Query(
-        ...,
-        min_length=3,
-        max_length=64,
-        description="Latitude,Longitude (e.g., 40.4093,49.8671)",
-    ),
-]
-RestaurantSearch = Annotated[
-    str | None,
-    Query(
-        min_length=1,
-        max_length=80,
-        description="Optional search term for restaurants",
-    ),
-]
+from .utils import add_cors, add_rate_limiting, add_request_id_tracing, add_security_headers
+from .cache import clear_all_caches, get_all_cache_stats
+from .metrics import PrometheusMiddleware, get_metrics
+from .health import health_checker
+from .api_v1 import v1_router
+from .versioning import APIVersionMiddleware
+from .logging_config import configure_structlog, get_logger
+from .backup import backup_manager
 REPO_ROOT = Path(__file__).resolve().parents[2]
 PHOTO_DIR = (REPO_ROOT / "IGPics").resolve()
 
+# Configure structured logging (must be done before any logging calls)
+configure_structlog(json_logs=not settings.DEBUG)
+
 if settings.SENTRY_DSN:
     sentry_sdk.init(
         dsn=settings.SENTRY_DSN,
@@ -69,39 +73,68 @@ if settings.SENTRY_DSN:
         traces_sample_rate=settings.SENTRY_TRACES_SAMPLE_RATE,
     )
 
-app = FastAPI(title="Baku Reserve API", version="0.1.0")
+app = FastAPI(
+    title="Baku Reserve API",
+    version="0.1.0",
+    description="Restaurant reservation system for Baku, Azerbaijan",
+)
 add_cors(app)
 add_security_headers(app)
+add_request_id_tracing(app)
 add_rate_limiting(app)
+app.add_middleware(APIVersionMiddleware, current_version="1.0", latest_version="1.0")
+app.add_middleware(PrometheusMiddleware)
+
+# Include v1 API router (versioned endpoints)
+def include_router_on_both(router: APIRouter):
+    app.include_router(router)
+    app.include_router(router, prefix="/v1")
+
+
+include_router_on_both(restaurants_routes.router)
+include_router_on_both(reservations_routes.router)
+include_router_on_both(gomap_routes.router)
+app.include_router(v1_router)
+
+# Include UI router (admin/booking console)
 app.include_router(ui_router)
 if PHOTO_DIR.exists():
     app.mount(
         "/assets/restaurants", StaticFiles(directory=str(PHOTO_DIR)), name="restaurant-photos"
     )
 
-logger = logging.getLogger(__name__)
+# Use structlog for structured logging
+logger = get_logger(__name__)
+
+
+def register_on_both(method: str, path: str, **kwargs):
+    """Register endpoint on legacy and versioned routers."""
+
+    def decorator(func):
+        getattr(app, method)(path, **kwargs)(func)
+        getattr(v1_router, method)(path, **kwargs)(func)
+        return func
+
+    return decorator
 
 
-def _parse_coordinates(raw: str) -> tuple[float, float]:
-    payload = (raw or "").strip()
-    parts = [p.strip() for p in payload.split(",", 1)]
-    if len(parts) != 2 or not parts[0] or not parts[1]:
-        raise ValueError("Invalid coordinate format. Use 'lat,lon'.")
-    try:
-        lat = float(parts[0])
-        lon = float(parts[1])
-    except ValueError as exc:  # pragma: no cover - Pydantic guards most cases
-        raise ValueError("Invalid coordinate format. Use 'lat,lon'.") from exc
-    if not (-90.0 <= lat <= 90.0) or not (-180.0 <= lon <= 180.0):
-        raise ValueError(
-            "Coordinates must be within latitude (-90 to 90) and longitude (-180 to 180) ranges."
-        )
-    return lat, lon
+@register_on_both("get", "/health")
+async def health():
+    """Return service health including upstream dependency checks."""
+    health_status = await health_checker.check_all()
+    status_code = 200 if health_status["status"] == "healthy" else 503
+    health_status["service"] = "baku-reserve"
+    health_status["version"] = "0.1.0"
 
+    from fastapi.responses import JSONResponse
 
-@app.get("/health")
-def health():
-    return {"ok": True, "service": "baku-reserve", "version": "0.1.0"}
+    return JSONResponse(content=health_status, status_code=status_code)
+
+
+@register_on_both("get", "/metrics")
+def metrics():
+    """Expose Prometheus metrics."""
+    return get_metrics()
 
 
 if settings.DEBUG:
@@ -111,6 +144,73 @@ if settings.DEBUG:
         sentry_sdk.capture_message(f"[dev-sentry-test] {message}")
         return {"ok": True, "message": message}
 
+    @app.post("/dev/cache/clear")
+    def dev_clear_caches():
+        clear_all_caches()
+        return {"ok": True, "cleared": True}
+
+    @app.get("/dev/cache/stats")
+    def dev_cache_stats():
+        return get_all_cache_stats()
+
+    @app.post("/dev/backup/create")
+    def dev_create_backup(description: str | None = None):
+        """Create a manual backup of the database."""
+        try:
+            backup_path = backup_manager.create_backup(description=description)
+            return {
+                "ok": True,
+                "backup_path": str(backup_path),
+                "message": "Backup created successfully",
+            }
+        except Exception as exc:
+            raise HTTPException(500, f"Backup failed: {exc}")
+
+    @app.get("/dev/backup/list")
+    def dev_list_backups():
+        """List all available backups."""
+        backups = backup_manager.list_backups()
+        return {"ok": True, "backups": backups, "count": len(backups)}
+
+    @app.post("/dev/backup/restore/{backup_name}")
+    def dev_restore_backup(backup_name: str):
+        """Restore database from a backup."""
+        try:
+            backup_manager.restore_backup(backup_name)
+            return {
+                "ok": True,
+                "message": f"Database restored from {backup_name}",
+            }
+        except FileNotFoundError:
+            raise HTTPException(404, f"Backup not found: {backup_name}")
+        except Exception as exc:
+            raise HTTPException(500, f"Restore failed: {exc}")
+
+    @app.get("/dev/routes/compare")
+    def dev_route_compare(
+        origin: CoordinateString,
+        destination: CoordinateString,
+    ):
+        o_lat, o_lon = parse_coordinate_string(origin)
+        d_lat, d_lon = parse_coordinate_string(destination)
+        from .gomap import route_directions as _gomap_route
+        from .osrm import route as _osrm_route
+        gomap_result = _gomap_route(o_lat, o_lon, d_lat, d_lon)
+        osrm_result = _osrm_route(o_lat, o_lon, d_lat, d_lon)
+        return {
+            "origin": {"lat": o_lat, "lon": o_lon},
+            "destination": {"lat": d_lat, "lon": d_lon},
+            "gomap": {
+                "distance_km": gomap_result.distance_km if gomap_result else None,
+                "duration_seconds": gomap_result.duration_seconds if gomap_result else None,
+            },
+            "osrm": {
+                "distance_km": osrm_result.distance_km if osrm_result else None,
+                "duration_seconds": osrm_result.duration_seconds if osrm_result else None,
+            },
+            "haversine_km": haversine_km(o_lat, o_lon, d_lat, d_lon),
+        }
+
 
 @app.get("/config/features")
 def feature_flags():
@@ -123,134 +223,6 @@ def feature_flags():
         "maps_api_key_present": gomap_ready,
         "gomap_ready": gomap_ready,
     }
-
-
-@app.get("/maps/geocode", response_model=list[GeocodeResult])
-def geocode(query: str = Query(..., min_length=2, max_length=80)):
-    results = search_places(query)
-    formatted: list[GeocodeResult] = []
-    for item in results[:10]:
-        try:
-            formatted.append(
-                GeocodeResult(
-                    id=str(item.get("id")),
-                    name=str(item.get("name")),
-                    place_name=str(item.get("place_name")),
-                    latitude=float(item.get("latitude")),
-                    longitude=float(item.get("longitude")),
-                    provider=item.get("provider"),
-                )
-            )
-        except Exception:
-            continue
-    return formatted
-
-
-def _maybe_datetime(value: Any) -> datetime | None:
-    if isinstance(value, datetime):
-        return value
-    if isinstance(value, str):
-        try:
-            return datetime.fromisoformat(value)
-        except ValueError:
-            return None
-    return None
-
-
-def _ensure_prep_feature_enabled() -> None:
-    if not settings.PREP_NOTIFY_ENABLED:
-        raise HTTPException(status_code=404, detail="Feature disabled")
-
-
-def _sanitize_items(items: list[str] | None) -> list[str] | None:
-    if not items:
-        return None
-    cleaned = [item.strip() for item in items if isinstance(item, str) and item.strip()]
-    return cleaned or None
-
-
-def _prep_policy(record: dict[str, Any]) -> str:
-    restaurant = DB.get_restaurant(str(record.get("restaurant_id")))
-    policy = None
-    if restaurant:
-        policy = restaurant.get("prep_policy") or restaurant.get("deposit_policy")
-    resolved = (policy or settings.PREP_POLICY_TEXT or "").strip()
-    return resolved or settings.PREP_POLICY_TEXT
-
-
-def _build_prep_plan(record: dict[str, Any], scope: str, minutes_away: int) -> tuple[int, str]:
-    policy = _prep_policy(record)
-    recommended = max(5, min(int(minutes_away or 5), 90))
-    if scope == "full":
-        recommended = max(recommended, 10)
-    return recommended, policy
-
-
-def notify_restaurant(reservation: dict[str, Any], context: dict[str, Any]) -> None:
-    logger.info(
-        "Pre-arrival prep notify triggered",
-        extra={
-            "reservation_id": reservation.get("id"),
-            "minutes_away": context.get("minutes_away"),
-            "scope": context.get("scope"),
-        },
-    )
-
-
-def _haversine_km(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
-    from math import asin, cos, radians, sin, sqrt
-
-    r = 6371.0
-    dlat = radians(lat2 - lat1)
-    dlon = radians(lon2 - lon1)
-    a = sin(dlat / 2) ** 2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2) ** 2
-    c = 2 * asin(sqrt(a))
-    return r * c
-
-
-def _estimate_eta_minutes(distance_km: float, buffer_min: int = 3) -> int:
-    # Assume city driving average 32 km/h.
-    travel_minutes = (distance_km / 32) * 60 if distance_km else 0
-    return max(5, int(travel_minutes + buffer_min))
-
-
-def rec_to_reservation(rec: dict[str, Any]) -> Reservation:
-    arrival_payload = rec.get("arrival_intent") or {}
-    arrival_intent = None
-    try:
-        arrival_intent = ArrivalIntent(**arrival_payload)
-    except Exception:
-        arrival_intent = None
-    raw_items = rec.get("prep_items")
-    prep_items = None
-    if isinstance(raw_items, list):
-        prep_items = [str(item) for item in raw_items if isinstance(item, str)] or None
-    elif isinstance(raw_items, str):
-        prep_items = [raw_items]
-    return Reservation(
-        id=str(rec["id"]),
-        restaurant_id=str(rec["restaurant_id"]),
-        table_id=str(rec.get("table_id")) if rec.get("table_id") else None,
-        party_size=int(rec["party_size"]),
-        start=(
-            datetime.fromisoformat(str(rec["start"]))
-            if isinstance(rec["start"], str)
-            else rec["start"]
-        ),
-        end=datetime.fromisoformat(str(rec["end"])) if isinstance(rec["end"], str) else rec["end"],
-        guest_name=str(rec.get("guest_name", "")),
-        guest_phone=str(rec.get("guest_phone", "")) if rec.get("guest_phone") else None,
-        status=str(rec.get("status", "booked")),
-        arrival_intent=arrival_intent,
-        prep_eta_minutes=rec.get("prep_eta_minutes"),
-        prep_request_time=_maybe_datetime(rec.get("prep_request_time")),
-        prep_items=prep_items,
-        prep_scope=rec.get("prep_scope"),
-        prep_status=rec.get("prep_status"),
-        prep_policy=rec.get("prep_policy"),
-    )
-
-
 # ---------- root redirect to docs ----------
 @app.get("/", include_in_schema=False)
 def root_redirect():
@@ -259,183 +231,10 @@ def root_redirect():
 
 
 # ---------- endpoints ----------
-@app.get("/restaurants", response_model=list[RestaurantListItem])
-def list_restaurants(request: Request, q: RestaurantSearch = None):
-    items = DB.list_restaurants(q)
-    return [restaurant_to_list_item(r, request) for r in items]
-
-
-@app.post("/concierge/recommendations", response_model=ConciergeResponse)
-def concierge_recommendations(
-    payload: ConciergeRequest, request: Request, mode: str | None = Query(None)
-):
-    return concierge_service.recommend(payload, request, mode)
-
-
-@app.get("/restaurants/{rid}")
-def get_restaurant(rid: UUID, request: Request):
-    r = DB.get_restaurant(str(rid))
-    if not r:
-        raise HTTPException(404, "Restaurant not found")
-    return restaurant_to_detail(r, request)
-
-
-@app.get("/directions")
-def get_directions(origin: CoordinateString, destination: CoordinateString):
-    try:
-        origin_lat, origin_lon = _parse_coordinates(origin)
-        dest_lat, dest_lon = _parse_coordinates(destination)
-    except ValueError as exc:
-        raise HTTPException(400, str(exc)) from exc
-
-    eta = compute_eta_with_traffic(origin_lat, origin_lon, dest_lat, dest_lon)
-    if not eta:
-        distance_km = _haversine_km(origin_lat, origin_lon, dest_lat, dest_lon)
-        fallback_minutes = max(5, int(round(distance_km / 0.35)))
-        eta = build_fallback_eta(distance_km or 1.0, fallback_minutes)
-
-    return {
-        "eta_minutes": eta.eta_minutes,
-        "eta_seconds": eta.eta_seconds,
-        "route_distance_km": eta.route_distance_km,
-        "provider": eta.provider,
-        "route_summary": eta.route_summary,
-    }
-
-
-@app.get("/restaurants/{rid}/floorplan")
-def get_floorplan(rid: UUID):
-    r = DB.get_restaurant(str(rid))
-    if not r:
-        raise HTTPException(404, "Restaurant not found")
-    canvas = {"width": 1000, "height": 1000}
-    areas = []
-    for a in get_attr(r, "areas", []) or []:
-        tables = []
-        for t in get_attr(a, "tables", []) or []:
-            geometry = get_attr(t, "geometry") or {}
-            tables.append(
-                {
-                    "id": str(get_attr(t, "id")),
-                    "name": get_attr(t, "name"),
-                    "capacity": int(get_attr(t, "capacity", 2) or 2),
-                    "position": (
-                        get_attr(t, "position") or geometry.get("position")
-                        if isinstance(geometry, dict)
-                        else None
-                    ),
-                    "shape": get_attr(t, "shape"),
-                    "tags": list(get_attr(t, "tags", []) or []),
-                    "rotation": get_attr(t, "rotation"),
-                    "footprint": get_attr(t, "footprint")
-                    or (geometry.get("footprint") if isinstance(geometry, dict) else None),
-                    "geometry": geometry if isinstance(geometry, dict) and geometry else None,
-                }
-            )
-        areas.append(
-            {
-                "id": str(get_attr(a, "id")),
-                "name": get_attr(a, "name"),
-                "tables": tables,
-                "theme": get_attr(a, "theme"),
-                "landmarks": get_attr(a, "landmarks"),
-            }
-        )
-    return {"canvas": canvas, "areas": areas}
-
-
-@app.post("/reservations", response_model=Reservation, status_code=201)
-def create_reservation(payload: ReservationCreate, _: AuthClaims):
-    try:
-        res = DB.create_reservation(payload)
-        return res
-    except HTTPException as e:
-        raise e
-    except ValueError as e:
-        raise HTTPException(409, str(e)) from e
-
-
-@app.post("/reservations/{resid}/cancel", response_model=Reservation)
-def soft_cancel_reservation(resid: UUID, _: AuthClaims):
-    rec = DB.set_status(str(resid), "cancelled")
-    if not rec:
-        raise HTTPException(404, "Reservation not found")
-    return rec_to_reservation(rec)
-
-
-@app.post("/reservations/{resid}/confirm", response_model=Reservation)
-def confirm_reservation(resid: UUID, _: AuthClaims):
-    rec = DB.set_status(str(resid), "booked")
-    if not rec:
-        raise HTTPException(404, "Reservation not found")
-    return rec_to_reservation(rec)
-
-
-@app.post("/reservations/{resid}/preorder/quote", response_model=PreorderQuoteResponse)
-def preorder_quote(resid: UUID, payload: PreorderRequest, _: AuthClaims):
-    _ensure_prep_feature_enabled()
-    record = _require_reservation(resid)
-    recommended, policy = _build_prep_plan(record, payload.scope, payload.minutes_away)
-    return PreorderQuoteResponse(
-        policy=policy,
-        recommended_prep_minutes=recommended,
-    )
-
-
-@app.post("/reservations/{resid}/preorder/confirm", response_model=Reservation)
-def preorder_confirm(resid: UUID, payload: PreorderConfirmRequest, _: AuthClaims):
-    _ensure_prep_feature_enabled()
-    record = _require_reservation(resid)
-    _, policy = _build_prep_plan(record, payload.scope, payload.minutes_away)
-
-    items = _sanitize_items(payload.normalized_items)
-    now = datetime.utcnow()
-    updated = DB.update_reservation(
-        str(resid),
-        prep_eta_minutes=payload.minutes_away,
-        prep_scope=payload.scope,
-        prep_request_time=now,
-        prep_items=items,
-        prep_status="accepted",
-        prep_policy=policy,
-    )
-    if not updated:
-        raise HTTPException(404, "Reservation not found")
-
-    notify_restaurant(
-        updated,
-        {
-            "minutes_away": payload.minutes_away,
-            "scope": payload.scope,
-            "items": items or [],
-        },
-    )
-    return rec_to_reservation(updated)
-
-
-@app.delete("/reservations/{resid}", response_model=Reservation)
-def hard_delete_reservation(resid: UUID, _: AuthClaims):
-    r = DB.cancel_reservation(str(resid))
-    if not r:
-        raise HTTPException(404, "Reservation not found")
-    return rec_to_reservation(r)
-
-
-@app.get("/restaurants/{rid}/availability")
-def availability(rid: UUID, date_: DateQuery, party_size: int = 2):
-    r = DB.get_restaurant(str(rid))
-    if not r:
-        raise HTTPException(404, "Restaurant not found")
-    return availability_for_day(r, party_size, date_, DB)
-
-
-@app.get("/reservations")
-def list_reservations(_: AuthClaims):
-    return DB.list_reservations()
 
 
 @app.get("/auth/session", response_model=dict)
-def session_info(claims: AuthClaims):
+def session_info(claims: dict[str, Any] = Depends(require_auth)):
     return {
         "user": {
             "sub": claims.get("sub"),
@@ -452,97 +251,3 @@ def _require_reservation(resid: UUID) -> dict[str, Any]:
     if record.get("status") != "booked":
         raise HTTPException(409, "Reservation is not active")
     return record
-
-
-@app.post("/reservations/{resid}/arrival_intent", response_model=Reservation)
-def request_arrival_intent(resid: UUID, payload: ArrivalIntentRequest, _: AuthClaims):
-    _require_reservation(resid)
-    intent = ArrivalIntent(
-        status="requested",
-        lead_minutes=payload.lead_minutes,
-        prep_scope=payload.prep_scope,
-        eta_source=payload.eta_source,
-        share_location=payload.share_location,
-        last_signal=datetime.utcnow(),
-        notes=payload.notes,
-        auto_charge=payload.auto_charge,
-    )
-    updated = DB.set_arrival_intent(str(resid), intent)
-    return rec_to_reservation(updated)
-
-
-@app.post("/reservations/{resid}/arrival_intent/decision", response_model=Reservation)
-def decide_arrival_intent(resid: UUID, payload: ArrivalIntentDecision, _: AuthClaims):
-    record = _require_reservation(resid)
-    current_payload = record.get("arrival_intent") or {}
-    current = ArrivalIntent(**current_payload) if current_payload else ArrivalIntent()
-    if current.status == "idle":
-        raise HTTPException(409, "No arrival intent to update")
-    status_map = {
-        "approve": "approved",
-        "queue": "queued",
-        "reject": "rejected",
-        "cancel": "cancelled",
-    }
-    intent = current.model_copy(
-        update={
-            "status": status_map[payload.action],
-            "notes": payload.notes or current.notes,
-            "last_signal": datetime.utcnow(),
-        }
-    )
-    updated = DB.set_arrival_intent(str(resid), intent)
-    return rec_to_reservation(updated)
-
-
-@app.post("/reservations/{resid}/arrival_intent/location", response_model=Reservation)
-def arrival_location_ping(resid: UUID, payload: ArrivalLocationPing, _: AuthClaims):
-    record = _require_reservation(resid)
-    restaurant = DB.get_restaurant(record["restaurant_id"])
-    if not restaurant:
-        raise HTTPException(404, "Restaurant not found")
-    if not restaurant.get("latitude") or not restaurant.get("longitude"):
-        raise HTTPException(422, "Restaurant is missing coordinates")
-    dest_lat = float(restaurant["latitude"])
-    dest_lon = float(restaurant["longitude"])
-    distance = _haversine_km(payload.latitude, payload.longitude, dest_lat, dest_lon)
-    eta_result = compute_eta_with_traffic(payload.latitude, payload.longitude, dest_lat, dest_lon)
-    if not eta_result:
-        eta_result = build_fallback_eta(distance, _estimate_eta_minutes(distance))
-    current = ArrivalIntent(**(record.get("arrival_intent") or {}))
-    signal_time = datetime.utcnow()
-    intent = current.model_copy(
-        update={
-            "predicted_eta_minutes": eta_result.eta_minutes,
-            "predicted_eta_seconds": eta_result.eta_seconds,
-            "typical_eta_minutes": eta_result.typical_eta_minutes,
-            "eta_source": "location",
-            "share_location": True,
-            "last_signal": signal_time,
-            "last_location": {"latitude": payload.latitude, "longitude": payload.longitude},
-            "route_distance_km": eta_result.route_distance_km or round(distance, 2),
-            "route_summary": eta_result.route_summary,
-            "traffic_condition": eta_result.traffic_condition,
-            "traffic_source": eta_result.provider,
-            "traffic_updated_at": signal_time,
-        }
-    )
-    updated = DB.set_arrival_intent(str(resid), intent)
-    return rec_to_reservation(updated)
-
-
-@app.post("/reservations/{resid}/arrival_intent/eta", response_model=Reservation)
-def confirm_arrival_eta(resid: UUID, payload: ArrivalEtaConfirmation, _: AuthClaims):
-    record = _require_reservation(resid)
-    current = ArrivalIntent(**(record.get("arrival_intent") or {}))
-    if current.status == "idle":
-        raise HTTPException(409, "No arrival intent to confirm")
-    intent = current.model_copy(
-        update={
-            "confirmed_eta_minutes": payload.eta_minutes,
-            "eta_source": current.eta_source or "user",
-            "last_signal": datetime.utcnow(),
-        }
-    )
-    updated = DB.set_arrival_intent(str(resid), intent)
-    return rec_to_reservation(updated)
diff --git a/backend/app/maps.py b/backend/app/maps.py
index 2a4c656..6546ef5 100644
--- a/backend/app/maps.py
+++ b/backend/app/maps.py
@@ -3,13 +3,19 @@ from __future__ import annotations
 import logging
 import math
 from dataclasses import dataclass
-from typing import Any
+from math import asin, cos, radians, sin, sqrt
+from typing import Any, Literal, Union
 
-from .gomap import route_directions as gomap_route
+from .gomap import GoMapRoute, route_directions as gomap_route
 from .gomap import search_objects as gomap_search
+from .gomap import get_traffic_conditions as gomap_traffic
+from .osrm import OsrmRoute, route as osrm_route
+from .settings import settings
 
 logger = logging.getLogger(__name__)
 
+RouteCandidate = Union[GoMapRoute, OsrmRoute]
+
 
 @dataclass
 class EtaComputation:
@@ -17,9 +23,21 @@ class EtaComputation:
     eta_seconds: int
     route_distance_km: float | None = None
     typical_eta_minutes: int | None = None
-    traffic_condition: str | None = None
+    traffic_condition: Literal["smooth", "moderate", "heavy", "severe", "unknown"] | None = None
     route_summary: str | None = None
     provider: str = "gomap"
+    traffic_delay_minutes: int | None = None
+    route_geometry: list[tuple[float, float]] | None = None
+    calibration_note: str | None = None
+
+
+def _haversine(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
+    r = 6371.0
+    dlat = radians(lat2 - lat1)
+    dlon = radians(lon2 - lon1)
+    a = sin(dlat / 2) ** 2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2) ** 2
+    c = 2 * asin(sqrt(a))
+    return r * c
 
 
 def compute_eta_with_traffic(
@@ -28,23 +46,144 @@ def compute_eta_with_traffic(
     dest_lat: float,
     dest_lon: float,
 ) -> EtaComputation | None:
-    """Call GoMap routing to fetch a driving ETA (ideal conditions)."""
+    """Call GoMap routing to fetch driving ETA with optional traffic conditions."""
 
-    route = gomap_route(origin_lat, origin_lon, dest_lat, dest_lon)
-    if not route or route.duration_seconds is None:
+    # Get base route information
+    gomap = gomap_route(origin_lat, origin_lon, dest_lat, dest_lon)
+    osrm = osrm_route(origin_lat, origin_lon, dest_lat, dest_lon)
+
+    if not gomap and not osrm:
         return None
 
-    eta_seconds = max(1, route.duration_seconds)
-    eta_minutes = max(1, math.ceil(eta_seconds / 60))
+    haversine_km = _haversine(origin_lat, origin_lon, dest_lat, dest_lon)
+
+    def _distance_error(distance: float | None) -> float | None:
+        if distance is None or not haversine_km:
+            return None
+        return abs(distance - haversine_km) / max(haversine_km, 0.001)
+
+    gomap_error = _distance_error(gomap.distance_km if gomap else None)
+    osrm_error = _distance_error(osrm.distance_km if osrm else None)
+
+    base_route: RouteCandidate | None = gomap or osrm
+    base_provider = "gomap" if base_route is gomap else "osrm"
+    calibration_note = None
+
+    if gomap and osrm and gomap.distance_km and osrm.distance_km:
+        dist_diff = abs(gomap.distance_km - osrm.distance_km) / max(osrm.distance_km, 1e-3)
+        gomap_far = gomap_error is not None and gomap_error > settings.MAP_HAVERSINE_TOLERANCE
+        osrm_far = osrm_error is not None and osrm_error > settings.MAP_HAVERSINE_TOLERANCE
+
+        if gomap_far and not osrm_far:
+            base_route = osrm
+            base_provider = "osrm"
+            calibration_note = "calibrated via OSRM (GoMap distance high)"
+        elif dist_diff > settings.MAP_DISTANCE_TOLERANCE and osrm.distance_km < gomap.distance_km:
+            base_route = osrm
+            base_provider = "osrm"
+            calibration_note = f"calibrated via OSRM (Δ{int(dist_diff * 100)}%)"
+        else:
+            if gomap.duration_seconds and osrm.duration_seconds:
+                avg_seconds = int(round((gomap.duration_seconds + osrm.duration_seconds) / 2))
+                base_route = GoMapRoute(
+                    distance_km=gomap.distance_km,
+                    duration_seconds=avg_seconds,
+                    geometry=gomap.geometry,
+                    notice=gomap.notice,
+                )
+                base_provider = "gomap"
+
+    distance_km = (
+        base_route.distance_km
+        if base_route and base_route.distance_km is not None
+        else (osrm.distance_km if osrm else None)
+    )
+    duration_seconds = (
+        base_route.duration_seconds
+        if base_route and base_route.duration_seconds
+        else (osrm.duration_seconds if osrm else gomap.duration_seconds if gomap else None)
+    )
+    if duration_seconds is None:
+        return None
+
+    # Calculate base ETA
+    base_eta_seconds = max(1, duration_seconds)
+    base_eta_minutes = max(1, math.ceil(base_eta_seconds / 60))
+
+    # Initialize with base values
+    eta_minutes = base_eta_minutes
+    eta_seconds = base_eta_seconds
+    traffic_condition = None
+    traffic_delay_minutes = None
+
+    # Try to get traffic conditions if enabled
+    if settings.GOMAP_TRAFFIC_ENABLED and gomap:
+        try:
+            # Check traffic at origin
+            origin_traffic = gomap_traffic(origin_lat, origin_lon, radius_km=2.0)
+            # Check traffic at destination
+            dest_traffic = gomap_traffic(dest_lat, dest_lon, radius_km=2.0)
+
+            # Use the worse traffic condition between origin and destination
+            traffic_severity = 0
+            if origin_traffic and origin_traffic.severity:
+                traffic_severity = origin_traffic.severity
+            if dest_traffic and dest_traffic.severity:
+                traffic_severity = max(traffic_severity, dest_traffic.severity)
+
+            # Apply traffic adjustments based on severity
+            if traffic_severity > 0:
+                # Map severity to condition
+                delays = settings.parsed_traffic_delay_factors
+                if traffic_severity == 1:
+                    traffic_condition = "smooth"
+                elif traffic_severity == 2:
+                    traffic_condition = "moderate"
+                elif traffic_severity == 3:
+                    traffic_condition = "heavy"
+                else:
+                    traffic_condition = "severe"
+                delay_factor = delays.get(traffic_condition, 1.0)
+
+                # Calculate adjusted ETA with traffic
+                if delay_factor > 1.0:
+                    adjusted_seconds = int(base_eta_seconds * delay_factor)
+                    traffic_delay_minutes = max(0, math.ceil((adjusted_seconds - base_eta_seconds) / 60))
+                    eta_seconds = adjusted_seconds
+                    eta_minutes = max(1, math.ceil(eta_seconds / 60))
+
+                    logger.info(
+                        "Traffic adjustment: %s condition, %d min delay added to %d min base",
+                        traffic_condition, traffic_delay_minutes, base_eta_minutes
+                    )
+            else:
+                traffic_condition = "unknown"
+
+        except Exception as exc:
+            logger.warning("Failed to fetch traffic conditions: %s", exc)
+            # Continue with base ETA if traffic check fails
+
+    # Add configured buffer minutes
+    buffer_minutes = settings.ETA_BUFFER_MINUTES
+    if traffic_condition in {"heavy", "severe"}:
+        buffer_minutes += settings.ETA_HEAVY_BUFFER_MINUTES
+    if buffer_minutes > 0:
+        eta_minutes += buffer_minutes
+        eta_seconds += buffer_minutes * 60
+
+    geometry = gomap.geometry if gomap and gomap.geometry else osrm.geometry if osrm else None
 
     return EtaComputation(
         eta_minutes=eta_minutes,
         eta_seconds=eta_seconds,
-        route_distance_km=route.distance_km,
-        typical_eta_minutes=eta_minutes,
-        traffic_condition=None,
-        route_summary=route.notice,
-        provider="gomap",
+        route_distance_km=distance_km,
+        typical_eta_minutes=base_eta_minutes,
+        traffic_condition=traffic_condition,
+        traffic_delay_minutes=traffic_delay_minutes,
+        route_summary=gomap.notice if gomap else osrm.notice if osrm else None,
+        route_geometry=geometry,
+        provider=base_provider,
+        calibration_note=calibration_note,
     )
 
 
@@ -67,6 +206,40 @@ __all__ = [
 
 
 def search_places(
-    query: str, *, limit: int = 5, language: str | None = None
+    query: str,
+    *,
+    origin_lat: float | None = None,
+    origin_lon: float | None = None,
+    limit: int = 5,
+    use_fuzzy: bool = True,
+    language: str | None = None
 ) -> list[dict[str, Any]]:
-    return gomap_search(query, limit=limit, language=language)
+    """Smart search for places with distance calculations and fuzzy matching.
+
+    Uses an intelligent search strategy:
+    1. Distance-aware search if origin coordinates provided
+    2. Exact search as fallback
+    3. Fuzzy search for typo tolerance if enabled
+
+    Args:
+        query: Search query (can contain typos if fuzzy enabled)
+        origin_lat: Optional origin latitude for distance calculations
+        origin_lon: Optional origin longitude for distance calculations
+        limit: Maximum number of results
+        use_fuzzy: Whether to enable fuzzy search for typo tolerance
+        language: Language for results
+
+    Returns:
+        List of search results with best matching strategy
+    """
+    from .gomap import search_objects_smart
+
+    # Use smart search that combines all strategies
+    return search_objects_smart(
+        query,
+        origin_lat=origin_lat,
+        origin_lon=origin_lon,
+        limit=limit,
+        use_fuzzy_fallback=use_fuzzy,
+        language=language
+    )
diff --git a/backend/app/models.py b/backend/app/models.py
index 8122327..d132d39 100644
--- a/backend/app/models.py
+++ b/backend/app/models.py
@@ -34,6 +34,7 @@ class RestaurantListItem(BaseModel):
     city: str
     slug: str | None = None
     cover_photo: str | None = None
+    timezone: str | None = None
 
 
 class Restaurant(BaseModel):
@@ -42,6 +43,7 @@ class Restaurant(BaseModel):
     slug: str | None = None
     cuisine: list[str] = Field(default_factory=list)
     city: str = "Baku"
+    timezone: str = "Asia/Baku"
     address: str | None = None
     phone: str | None = None
     photos: list[str] = Field(default_factory=list)
@@ -100,8 +102,8 @@ class ArrivalIntent(BaseModel):
     last_location: dict[str, float] | None = None
     route_distance_km: float | None = None
     route_summary: str | None = None
-    traffic_condition: Literal["smooth", "moderate", "heavy", "severe"] | None = None
-    traffic_source: Literal["gomap", "fallback"] | None = None
+    traffic_condition: Literal["smooth", "moderate", "heavy", "severe", "unknown"] | None = None
+    traffic_source: Literal["gomap", "osrm", "fallback"] | None = None
     traffic_updated_at: datetime | None = None
 
     @field_validator("notes")
@@ -152,6 +154,19 @@ class GeocodeResult(BaseModel):
     provider: str | None = None
 
 
+class ArrivalLocationSuggestion(BaseModel):
+    id: str
+    name: str
+    address: str | None = None
+    latitude: float
+    longitude: float
+    distance_km: float | None = None
+    eta_minutes: int | None = None
+    eta_seconds: int | None = None
+    route_summary: str | None = None
+    provider: str = "gomap"
+
+
 class UserBase(BaseModel):
     name: str
     email: str
diff --git a/backend/app/schemas.py b/backend/app/schemas.py
index 9e575f1..2ee300a 100644
--- a/backend/app/schemas.py
+++ b/backend/app/schemas.py
@@ -27,6 +27,7 @@ class Restaurant(BaseModel):
     slug: str | None = None
     cuisine: list[str] = Field(default_factory=list)
     city: str = "Baku"
+    timezone: str = "Asia/Baku"
     address: str | None = None
     phone: str | None = None
     photos: list[str] = Field(default_factory=list)
@@ -55,6 +56,7 @@ class RestaurantListItem(BaseModel):
     slug: str | None = None
     cuisine: list[str]
     city: str
+    timezone: str | None = None
     neighborhood: str | None = None
     address: str | None = None
     cover_photo: str | None = None
diff --git a/backend/app/serializers.py b/backend/app/serializers.py
index e8b4e29..df0f519 100644
--- a/backend/app/serializers.py
+++ b/backend/app/serializers.py
@@ -38,6 +38,7 @@ def restaurant_to_list_item(r: Any, request: Request | None = None) -> dict[str,
         "slug": str(slug_value) if slug_value else None,
         "cuisine": list(get_attr(r, "cuisine", []) or []),
         "city": get_attr(r, "city"),
+        "timezone": get_attr(r, "timezone") or "Asia/Baku",
         "neighborhood": get_attr(r, "neighborhood"),
         "address": get_attr(r, "address"),
         "cover_photo": absolute_media_url(
@@ -109,6 +110,7 @@ def restaurant_to_detail(r: Any, request: Request | None = None) -> dict[str, An
         "slug": str(slug_value) if slug_value else None,
         "cuisine": list(get_attr(r, "cuisine", []) or []),
         "city": get_attr(r, "city"),
+        "timezone": get_attr(r, "timezone") or "Asia/Baku",
         "address": get_attr(r, "address") or "",
         "phone": get_attr(r, "phone") or "",
         "photos": list(get_attr(r, "photos", []) or []),
diff --git a/backend/app/settings.py b/backend/app/settings.py
index 32a48e2..d9757b1 100644
--- a/backend/app/settings.py
+++ b/backend/app/settings.py
@@ -49,6 +49,13 @@ class Settings(BaseSettings):
     RATE_LIMIT_REQUESTS: int = 300  # per window per client
     RATE_LIMIT_WINDOW_SECONDS: int = 60
 
+    # Trusted proxy configuration for X-Forwarded-For validation
+    # Only trust X-Forwarded-For headers from these proxies (comma-separated IPs/CIDRs)
+    # Examples: "127.0.0.1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
+    # Set to "*" to trust all (INSECURE - only for development behind trusted reverse proxy)
+    # Leave empty to never trust X-Forwarded-For (use direct client.host only)
+    TRUSTED_PROXIES: str = ""
+
     # Concierge AI
     OPENAI_API_KEY: str | None = None
     CONCIERGE_GPT_MODEL: str = "gpt-3.5-turbo-0125"
@@ -63,6 +70,40 @@ class Settings(BaseSettings):
     SENTRY_RELEASE: str | None = None
     SENTRY_TRACES_SAMPLE_RATE: float = 0.2
 
+    # GoMap API Resilience & Performance Settings
+    GOMAP_CIRCUIT_BREAKER_ENABLED: bool = True
+    GOMAP_CIRCUIT_BREAKER_THRESHOLD: int = 3  # failures before opening circuit
+    GOMAP_CIRCUIT_BREAKER_COOLDOWN_SECONDS: int = 300  # 5 minutes
+    GOMAP_RETRY_ATTEMPTS: int = 2
+    GOMAP_RETRY_BACKOFF_SECONDS: float = 1.0
+    GOMAP_CACHE_TTL_SECONDS: int = 900  # 15 minutes for route caching
+    GOMAP_GEOCODE_CACHE_TTL_SECONDS: int = 1800  # 30 minutes for geocoding
+
+    # Traffic API Configuration
+    GOMAP_TRAFFIC_ENABLED: bool = True
+    GOMAP_TRAFFIC_UPDATE_INTERVAL_SECONDS: int = 300  # 5 minutes
+
+    # Fallback ETA Calculation Settings
+    FALLBACK_CITY_SPEED_KMH: float = 28.0  # Realistic Baku city average speed
+    FALLBACK_HIGHWAY_SPEED_KMH: float = 60.0  # For longer distances
+    ETA_BUFFER_MINUTES: int = 0
+    ETA_HEAVY_BUFFER_MINUTES: int = 2
+    MAP_DISTANCE_TOLERANCE: float = 0.25
+    MAP_HAVERSINE_TOLERANCE: float = 0.35
+    TRAFFIC_DELAY_FACTORS: str = "smooth=1.0,moderate=1.12,heavy=1.25,severe=1.4"
+
+    # Location Ping Throttling
+    LOCATION_PING_MIN_DISTANCE_METERS: float = 100.0  # Minimum movement required
+    LOCATION_PING_MIN_INTERVAL_SECONDS: int = 30  # Rate limiting per reservation
+
+    # Arrival Intent Suggestions Configuration
+    MAX_SUGGESTION_ROUTE_DETAILS: int = 3  # Number of suggestions to calculate detailed routes for
+    MAX_SUGGESTION_DISTANCE_KM: float = 150.0  # Maximum distance for location suggestions
+
+    # Redis Configuration (Optional - for circuit breaker state persistence)
+    REDIS_URL: str | None = None  # e.g., "redis://localhost:6379/0"
+    REDIS_ENABLED: bool = False
+
     @property
     def allow_origins(self) -> list[str]:
         s = (self.CORS_ALLOW_ORIGINS or "").strip()
@@ -89,6 +130,29 @@ class Settings(BaseSettings):
     def parsed_concierge_weights(self) -> ConciergeWeights:
         return ConciergeWeights.from_string(self.CONCIERGE_WEIGHTS)
 
+    @property
+    def parsed_traffic_delay_factors(self) -> dict[str, float]:
+        defaults = {
+            "smooth": 1.0,
+            "moderate": 1.12,
+            "heavy": 1.25,
+            "severe": 1.4,
+        }
+        payload = (self.TRAFFIC_DELAY_FACTORS or "").strip()
+        if not payload:
+            return defaults
+        mapping = defaults.copy()
+        for part in payload.split(","):
+            if "=" not in part:
+                continue
+            key, value = part.split("=", 1)
+            key = key.strip().lower()
+            try:
+                mapping[key] = float(value.strip())
+            except ValueError:
+                continue
+        return mapping
+
 
 @dataclass(slots=True)
 class ConciergeWeights:
diff --git a/backend/app/storage.py b/backend/app/storage.py
index 544c06d..114f538 100644
--- a/backend/app/storage.py
+++ b/backend/app/storage.py
@@ -4,6 +4,7 @@ import json
 from datetime import datetime
 from pathlib import Path
 from shutil import copy2
+from threading import RLock
 from typing import Any
 from uuid import uuid4
 
@@ -11,6 +12,7 @@ from fastapi import HTTPException
 
 from .models import ArrivalIntent, Reservation, ReservationCreate
 from .settings import settings
+from .file_lock import FileLock
 
 DATA_DIR = settings.data_dir
 LEGACY_DATA_DIR = Path(__file__).resolve().parent / "data"
@@ -98,6 +100,7 @@ class Database:
             elif entry.get("name"):
                 entry["slug"] = str(entry["name"]).lower().replace(" ", "-")
             entry.setdefault("city", "Baku")
+            entry.setdefault("timezone", "Asia/Baku")
             normalised.append(entry)
 
         self.restaurants: dict[str, dict[str, Any]] = {r["id"]: r for r in normalised}
@@ -119,6 +122,7 @@ class Database:
                 "slug": r.get("slug"),
                 "cuisine": r.get("cuisine", []),
                 "city": r.get("city"),
+                "timezone": r.get("timezone") or "Asia/Baku",
                 "cover_photo": cover,
                 "short_description": r.get("short_description"),
                 "price_level": r.get("price_level"),
@@ -146,6 +150,7 @@ class Database:
             self._table_lookup_cache[rid] = {str(t.get("id")): t for t, _ in table_entries}
 
         self.reservations: dict[str, dict[str, Any]] = {}
+        self._lock = RLock()
         self._load()
 
     # -------- helpers --------
@@ -179,9 +184,14 @@ class Database:
 
     # -------- reservations --------
     def list_reservations(self) -> list[dict[str, Any]]:
-        return list(self.reservations.values())
+        with self._lock:
+            return list(self.reservations.values())
 
     def create_reservation(self, payload: ReservationCreate) -> Reservation:
+        with self._lock:
+            return self._create_reservation_locked(payload)
+
+    def _create_reservation_locked(self, payload: ReservationCreate) -> Reservation:
         rid = str(payload.restaurant_id)
 
         if payload.party_size < 1:
@@ -251,43 +261,52 @@ class Database:
         return Reservation(**{**rec, "start": start, "end": end, "arrival_intent": ArrivalIntent()})
 
     def set_status(self, resid: str, status: str) -> dict[str, Any] | None:
-        if resid not in self.reservations:
-            return None
-        if status not in ("booked", "cancelled"):
-            raise HTTPException(status_code=422, detail="invalid status")
-        self.reservations[resid]["status"] = status
-        self._save()
-        return self.reservations[resid]
+        with self._lock:
+            if resid not in self.reservations:
+                return None
+            if status not in ("booked", "cancelled"):
+                raise HTTPException(status_code=422, detail="invalid status")
+            self.reservations[resid]["status"] = status
+            self._save()
+            return self.reservations[resid]
 
     def cancel_reservation(self, resid: str) -> dict[str, Any] | None:
-        # Hard delete (used by existing DELETE route)
-        out = self.reservations.pop(str(resid), None)
-        if out is not None:
-            self._save()
-        return out
+        with self._lock:
+            out = self.reservations.pop(str(resid), None)
+            if out is not None:
+                self._save()
+            return out
 
     def get_reservation(self, resid: str) -> dict[str, Any] | None:
-        return self.reservations.get(str(resid))
+        with self._lock:
+            return self.reservations.get(str(resid))
 
     def set_arrival_intent(self, resid: str, intent: ArrivalIntent) -> dict[str, Any] | None:
-        record = self.reservations.get(str(resid))
-        if not record:
-            return None
-        record["arrival_intent"] = _dump_intent(intent) or {}
-        self._save()
-        return record
+        with self._lock:
+            record = self.reservations.get(str(resid))
+            if not record:
+                return None
+            record["arrival_intent"] = _dump_intent(intent) or {}
+            self._save()
+            return record
 
     def update_reservation(self, resid: str, **fields: Any) -> dict[str, Any] | None:
-        record = self.reservations.get(str(resid))
-        if not record:
-            return None
-        for key, value in fields.items():
-            record[key] = value
-        self._save()
-        return record
+        with self._lock:
+            record = self.reservations.get(str(resid))
+            if not record:
+                return None
+            for key, value in fields.items():
+                record[key] = value
+            self._save()
+            return record
 
     # -------- persistence --------
     def _save(self) -> None:
+        """
+        Save reservations to disk with file locking.
+
+        Uses exclusive file lock to prevent concurrent write conflicts.
+        """
         reservations: list[dict[str, Any]] = []
         for r in self.reservations.values():
             record = dict(r)
@@ -296,13 +315,27 @@ class Database:
                     record[key] = _iso(record[key])
             reservations.append(record)
         data = {"reservations": reservations}
-        RES_PATH.write_text(json.dumps(data, ensure_ascii=False, indent=2))
+
+        # Atomic write with file locking
+        with FileLock(RES_PATH, timeout=5.0):
+            RES_PATH.write_text(json.dumps(data, ensure_ascii=False, indent=2))
 
     def _load(self) -> None:
+        """
+        Load reservations from disk with file locking.
+
+        Uses exclusive file lock to ensure consistent reads.
+        """
         if not RES_PATH.exists():
             return
+
+        # Atomic read with file locking
         try:
-            raw = json.loads(RES_PATH.read_text() or "{}")
+            with FileLock(RES_PATH, timeout=5.0):
+                raw = json.loads(RES_PATH.read_text() or "{}")
+        except TimeoutError:
+            # Could not acquire lock - use current in-memory state
+            return
         except Exception:
             self.reservations = {}
             return
diff --git a/backend/app/utils.py b/backend/app/utils.py
index 81d1c37..2a6fe94 100644
--- a/backend/app/utils.py
+++ b/backend/app/utils.py
@@ -1,9 +1,12 @@
 from __future__ import annotations
 
 import asyncio
+import logging
 import math
 import time
 from collections import defaultdict, deque
+from contextvars import ContextVar
+from uuid import uuid4
 
 from fastapi import Request, status
 from fastapi.middleware.cors import CORSMiddleware
@@ -12,6 +15,9 @@ from starlette.middleware.base import BaseHTTPMiddleware
 
 from .settings import settings
 
+# Context variable for request ID (accessible throughout the request lifecycle)
+request_id_ctx: ContextVar[str] = ContextVar("request_id", default="")
+
 
 def add_cors(app):
     origins = settings.allow_origins
@@ -49,6 +55,68 @@ def add_security_headers(app):
     app.add_middleware(SecurityHeadersMiddleware)
 
 
+class RequestIDMiddleware(BaseHTTPMiddleware):
+    """
+    Middleware to add request ID tracing for distributed debugging.
+
+    Features:
+    - Generates UUID for each request or uses existing X-Request-ID header
+    - Adds X-Request-ID to response headers
+    - Sets request ID in context variable for access throughout request lifecycle
+    - Integrates with logging for structured logs
+    """
+
+    async def dispatch(self, request: Request, call_next):  # type: ignore[override]
+        # Get or generate request ID
+        request_id = request.headers.get("X-Request-ID")
+        if not request_id:
+            request_id = str(uuid4())
+
+        # Set in context variable for access throughout request
+        request_id_ctx.set(request_id)
+
+        # Add to request state for easy access in route handlers
+        request.state.request_id = request_id
+
+        # Process request
+        response = await call_next(request)
+
+        # Add request ID to response headers
+        response.headers["X-Request-ID"] = request_id
+
+        return response
+
+
+class RequestIDLogFilter(logging.Filter):
+    """
+    Logging filter that adds request ID to log records.
+
+    Usage in logging configuration:
+        formatter = logging.Formatter(
+            '%(asctime)s [%(request_id)s] %(levelname)s %(name)s: %(message)s'
+        )
+    """
+
+    def filter(self, record: logging.LogRecord) -> bool:
+        # Add request ID to log record if available
+        request_id = request_id_ctx.get("")
+        record.request_id = request_id if request_id else "-"  # type: ignore[attr-defined]
+        return True
+
+
+def add_request_id_tracing(app):
+    """Add request ID middleware and configure logging."""
+    app.add_middleware(RequestIDMiddleware)
+
+    # Add filter to root logger
+    logging.getLogger().addFilter(RequestIDLogFilter())
+
+
+def get_request_id() -> str:
+    """Get the current request ID from context."""
+    return request_id_ctx.get("")
+
+
 class RateLimiter:
     def __init__(self) -> None:
         self._history: dict[str, deque[float]] = defaultdict(deque)
@@ -94,12 +162,114 @@ class RateLimiter:
         self._history.clear()
 
     def _identifier_for(self, request: Request) -> str:
+        """
+        Determine client identifier for rate limiting with secure proxy handling.
+
+        Security considerations:
+        - Only trusts X-Forwarded-For if request comes from a trusted proxy
+        - Validates all IP addresses to prevent spoofing
+        - Uses rightmost trusted IP from X-Forwarded-For chain
+        - Falls back to direct client.host if X-Forwarded-For is untrusted
+
+        Returns:
+            Client IP address or "anonymous" if unavailable
+        """
+        # Get direct client IP (the immediate connection)
+        direct_client_ip = request.client.host if request.client else None
+
+        # Check if we should trust X-Forwarded-For from this client
+        if not direct_client_ip or not self._is_trusted_proxy(direct_client_ip):
+            # Direct connection or untrusted proxy - use direct IP
+            return direct_client_ip or "anonymous"
+
+        # Request came from trusted proxy - parse X-Forwarded-For
         forwarded = request.headers.get("x-forwarded-for")
-        if forwarded:
-            return forwarded.split(",")[0].strip()
-        if request.client and request.client.host:
-            return request.client.host
-        return "anonymous"
+        if not forwarded:
+            # No X-Forwarded-For header - use direct IP
+            return direct_client_ip
+
+        # Parse X-Forwarded-For chain (format: client, proxy1, proxy2, ...)
+        # The FIRST (leftmost) IP is the original client
+        ips = [ip.strip() for ip in forwarded.split(",")]
+        for ip in ips:
+            # Validate IP address format
+            if self._is_valid_ip(ip):
+                # Found valid IP - this is the real client
+                return ip
+
+        # All IPs invalid or empty - fall back to direct IP
+        return direct_client_ip
+
+    def _is_trusted_proxy(self, ip: str) -> bool:
+        """
+        Check if an IP address is a trusted proxy.
+
+        Args:
+            ip: IP address to check
+
+        Returns:
+            True if IP is in trusted proxy list
+        """
+        from .settings import settings
+
+        trusted = settings.TRUSTED_PROXIES.strip()
+
+        # No trusted proxies configured - don't trust anyone
+        if not trusted:
+            return False
+
+        # "*" means trust all (INSECURE - only for development)
+        if trusted == "*":
+            return True
+
+        # Parse comma-separated list of trusted IPs/CIDRs
+        import ipaddress
+
+        try:
+            ip_obj = ipaddress.ip_address(ip)
+        except ValueError:
+            # Invalid IP format
+            return False
+
+        # Check against each trusted network/IP
+        for trusted_entry in trusted.split(","):
+            trusted_entry = trusted_entry.strip()
+            if not trusted_entry:
+                continue
+
+            try:
+                # Try as network/CIDR first
+                if "/" in trusted_entry:
+                    network = ipaddress.ip_network(trusted_entry, strict=False)
+                    if ip_obj in network:
+                        return True
+                else:
+                    # Try as single IP
+                    if ip_obj == ipaddress.ip_address(trusted_entry):
+                        return True
+            except ValueError:
+                # Invalid trusted entry - skip it
+                continue
+
+        return False
+
+    def _is_valid_ip(self, ip: str) -> bool:
+        """
+        Validate IP address format (IPv4 or IPv6).
+
+        Args:
+            ip: IP address string to validate
+
+        Returns:
+            True if valid IP address format
+        """
+        import ipaddress
+
+        try:
+            ipaddress.ip_address(ip)
+            return True
+        except ValueError:
+            return False
 
 
 def add_rate_limiting(app):
diff --git a/backend/requirements.txt b/backend/requirements.txt
index ccdecd0..ad2b658 100644
--- a/backend/requirements.txt
+++ b/backend/requirements.txt
@@ -17,3 +17,6 @@ numpy>=1.26
 
 # Observability
 sentry-sdk>=1.39.0,<2
+prometheus-client>=0.19.0,<1
+structlog>=24.0.0,<25
+redis>=5.0.0,<6  # Optional: for circuit breaker state persistence
diff --git a/backend/tests/conftest.py b/backend/tests/conftest.py
index deca329..dd4e77e 100644
--- a/backend/tests/conftest.py
+++ b/backend/tests/conftest.py
@@ -1,3 +1,4 @@
+import os
 import sys
 from pathlib import Path
 
@@ -27,6 +28,11 @@ def client() -> TestClient:
 def clean_reservations() -> None:
     settings.AUTH0_BYPASS = True
     settings.RATE_LIMIT_ENABLED = False
+    settings.OPENAI_API_KEY = None
+    settings.CONCIERGE_MODE = "local"
+    settings.SENTRY_DSN = None
+    os.environ.setdefault("CONCIERGE_MODE", "local")
+    os.environ.pop("OPENAI_API_KEY", None)
     limiter = getattr(app.state, "rate_limiter", None)
     if limiter:
         limiter.reset()
diff --git a/backend/tests/test_backend_system.py b/backend/tests/test_backend_system.py
index 91c049d..33bc80f 100644
--- a/backend/tests/test_backend_system.py
+++ b/backend/tests/test_backend_system.py
@@ -6,6 +6,7 @@ from uuid import uuid4
 
 import pytest
 from backend.app.availability import availability_for_day
+from backend.app.gomap import GoMapRoute
 from backend.app.models import ReservationCreate
 from backend.app.serializers import absolute_media_list, absolute_media_url
 from backend.app.storage import DB
@@ -33,12 +34,18 @@ def _iso_today() -> str:
 
 
 def test_health_and_documentation_endpoints_present(client: TestClient) -> None:
-    payload = client.get("/health").json()
-    assert payload == {
-        "ok": True,
-        "service": "baku-reserve",
-        "version": "0.1.0",
-    }
+    response = client.get("/health")
+    payload = response.json()
+
+    # Verify enhanced health check structure
+    assert "status" in payload
+    assert "service" in payload
+    assert "version" in payload
+    assert "checks" in payload
+    assert payload["service"] == "baku-reserve"
+    assert payload["version"] == "0.1.0"
+    assert response.status_code in [200, 503]  # 200 if healthy, 503 if degraded
+
     for path in ("/docs", "/openapi.json"):
         resp = client.get(path)
         assert resp.status_code == 200
@@ -192,6 +199,57 @@ def test_reservation_lifecycle_and_conflict_detection(client: TestClient) -> Non
     assert missing.status_code == 404
 
 
+def test_arrival_location_suggestions_include_eta(client: TestClient, monkeypatch) -> None:
+    day = _iso_today()
+    slot = _viable_slot(client, day)
+    table_id = slot["available_table_ids"][0]
+
+    payload = {
+        "restaurant_id": RID,
+        "party_size": 2,
+        "start": slot["start"],
+        "end": slot["end"],
+        "guest_name": "Suggestion Test",
+        "table_id": table_id,
+    }
+    created = client.post("/reservations", json=payload)
+    assert created.status_code == 201
+    resid = created.json()["id"]
+
+    sample_places = [
+        {
+            "id": "poi-123",
+            "name": "Flame Towers",
+            "address": "Baku Flame Towers",
+            "latitude": 40.3595,
+            "longitude": 49.8274,
+            "provider": "gomap",
+        }
+    ]
+
+    from backend.app import main as main_module
+
+    monkeypatch.setattr(main_module, "search_places", lambda query, limit=5: sample_places)
+
+    def fake_route(*_args, **_kwargs):  # noqa: ANN001, ANN002
+        return GoMapRoute(distance_km=12.5, duration_seconds=780, geometry=None, notice="Fastest route")
+
+    monkeypatch.setattr(main_module, "route_directions", fake_route)
+
+    resp = client.get(
+        f"/reservations/{resid}/arrival_intent/suggestions",
+        params={"q": "Flame", "limit": 3},
+    )
+
+    assert resp.status_code == 200
+    data = resp.json()
+    assert isinstance(data, list)
+    assert data and data[0]["name"] == "Flame Towers"
+    assert data[0]["distance_km"] == 12.5
+    assert data[0]["eta_minutes"] == 13
+    assert data[0]["route_summary"] == "Fastest route"
+
+
 def test_validation_and_unknown_restaurant_rejections(client: TestClient) -> None:
     day = _iso_today()
     start = f"{day}T18:00:00"
diff --git a/backend/tests/test_cache.py b/backend/tests/test_cache.py
new file mode 100644
index 0000000..038fd59
--- /dev/null
+++ b/backend/tests/test_cache.py
@@ -0,0 +1,269 @@
+"""Test caching implementation."""
+import time
+import pytest
+from unittest.mock import patch
+
+from app.cache import (
+    TTLCache,
+    CacheEntry,
+    make_cache_key,
+    cache_route,
+    get_cached_route,
+    cache_geocode,
+    get_cached_geocode,
+    cache_traffic,
+    get_cached_traffic,
+    clear_all_caches,
+)
+
+
+class TestCacheEntry:
+    """Test cache entry functionality."""
+
+    def test_entry_creation(self):
+        """Cache entry should store value and expiry time."""
+        entry = CacheEntry("test_value", time.time() + 10)
+        assert entry.value == "test_value"
+        assert not entry.is_expired()
+        assert entry.hits == 0
+
+    def test_entry_expiration(self):
+        """Cache entry should detect expiration."""
+        # Already expired
+        entry = CacheEntry("value", time.time() - 1)
+        assert entry.is_expired()
+
+        # Not yet expired
+        entry = CacheEntry("value", time.time() + 10)
+        assert not entry.is_expired()
+
+    def test_entry_hit_tracking(self):
+        """Cache entry should track hits."""
+        entry = CacheEntry("value", time.time() + 10)
+        assert entry.hits == 0
+
+        entry.increment_hits()
+        entry.increment_hits()
+        assert entry.hits == 2
+
+
+class TestTTLCache:
+    """Test TTL cache functionality."""
+
+    def test_cache_initialization(self):
+        """Cache should initialize with correct parameters."""
+        cache = TTLCache("test", max_size=100, default_ttl=60)
+        assert cache.name == "test"
+        assert cache.max_size == 100
+        assert cache.default_ttl == 60
+        assert cache.enabled is True
+
+    def test_cache_get_set(self):
+        """Cache should store and retrieve values."""
+        cache = TTLCache("test", default_ttl=10)
+
+        # Set a value
+        cache.set("key1", "value1")
+
+        # Get the value
+        result = cache.get("key1")
+        assert result == "value1"
+
+        # Non-existent key
+        result = cache.get("non_existent")
+        assert result is None
+
+    def test_cache_expiration(self):
+        """Cache should expire entries after TTL."""
+        cache = TTLCache("test", default_ttl=0.1)
+
+        cache.set("key1", "value1")
+        assert cache.get("key1") == "value1"
+
+        # Wait for expiration
+        time.sleep(0.15)
+        assert cache.get("key1") is None
+
+    def test_cache_custom_ttl(self):
+        """Cache should respect custom TTL per entry."""
+        cache = TTLCache("test", default_ttl=10)
+
+        # Set with custom short TTL
+        cache.set("short", "value", ttl=0.1)
+        # Set with default TTL
+        cache.set("long", "value")
+
+        assert cache.get("short") == "value"
+        assert cache.get("long") == "value"
+
+        # Wait for short TTL to expire
+        time.sleep(0.15)
+        assert cache.get("short") is None
+        assert cache.get("long") == "value"
+
+    def test_cache_lru_eviction(self):
+        """Cache should evict LRU entry when full."""
+        cache = TTLCache("test", max_size=3, default_ttl=10)
+
+        # Fill the cache
+        cache.set("key1", "value1")
+        cache.set("key2", "value2")
+        cache.set("key3", "value3")
+
+        # Access key1 and key2 to make them more recently used
+        cache.get("key1")
+        cache.get("key2")
+
+        # Add a new entry - should evict key3 (LRU)
+        cache.set("key4", "value4")
+
+        assert cache.get("key1") == "value1"
+        assert cache.get("key2") == "value2"
+        assert cache.get("key3") is None  # Evicted
+        assert cache.get("key4") == "value4"
+
+    def test_cache_disabled(self):
+        """Disabled cache should not store anything."""
+        cache = TTLCache("test", enabled=False)
+
+        cache.set("key1", "value1")
+        result = cache.get("key1")
+        assert result is None
+
+    def test_cache_clear(self):
+        """Cache clear should remove all entries."""
+        cache = TTLCache("test")
+
+        cache.set("key1", "value1")
+        cache.set("key2", "value2")
+        assert cache.get("key1") == "value1"
+
+        cache.clear()
+        assert cache.get("key1") is None
+        assert cache.get("key2") is None
+
+    def test_cache_cleanup_expired(self):
+        """Cache cleanup should remove only expired entries."""
+        cache = TTLCache("test", default_ttl=10)
+
+        # Set entries with different TTLs
+        cache.set("expire1", "value", ttl=0.1)
+        cache.set("expire2", "value", ttl=0.1)
+        cache.set("keep", "value", ttl=10)
+
+        time.sleep(0.15)
+
+        # Cleanup expired
+        removed = cache.cleanup_expired()
+        assert removed == 2
+        assert cache.get("keep") == "value"
+        assert cache.get("expire1") is None
+        assert cache.get("expire2") is None
+
+    def test_cache_stats(self):
+        """Cache should track statistics correctly."""
+        cache = TTLCache("test", max_size=10)
+
+        # Generate some hits and misses
+        cache.set("key1", "value1")
+        cache.get("key1")  # Hit
+        cache.get("key1")  # Hit
+        cache.get("missing")  # Miss
+        cache.get("missing")  # Miss
+
+        stats = cache.get_stats()
+        assert stats["name"] == "test"
+        assert stats["size"] == 1
+        assert stats["hits"] == 2
+        assert stats["misses"] == 2
+        assert stats["hit_rate"] == 0.5
+
+
+class TestCacheHelpers:
+    """Test cache helper functions."""
+
+    def test_make_cache_key(self):
+        """Cache key generation should be consistent."""
+        # Same arguments should produce same key
+        key1 = make_cache_key("route", 40.1, 49.2, 40.3, 49.4)
+        key2 = make_cache_key("route", 40.1, 49.2, 40.3, 49.4)
+        assert key1 == key2
+
+        # Different arguments should produce different keys
+        key3 = make_cache_key("route", 40.2, 49.2, 40.3, 49.4)
+        assert key1 != key3
+
+        # Different types should be handled
+        key4 = make_cache_key("test", 123, "string", None, True)
+        assert len(key4) == 16  # Truncated hash
+
+    def test_route_caching(self):
+        """Route caching helpers should work correctly."""
+        clear_all_caches()
+
+        route_data = {"distance": 10, "duration": 600}
+
+        # Cache a route
+        cache_route(40.1, 49.2, 40.3, 49.4, route_data)
+
+        # Retrieve cached route
+        cached = get_cached_route(40.1, 49.2, 40.3, 49.4)
+        assert cached == route_data
+
+        # Different coordinates should not match
+        cached = get_cached_route(40.2, 49.2, 40.3, 49.4)
+        assert cached is None
+
+    def test_geocode_caching(self):
+        """Geocode caching helpers should work correctly."""
+        clear_all_caches()
+
+        results = [{"name": "Place 1"}, {"name": "Place 2"}]
+
+        # Cache geocoding results
+        cache_geocode("Sahil", results)
+
+        # Retrieve cached results
+        cached = get_cached_geocode("Sahil")
+        assert cached == results
+
+        # Case sensitivity in query
+        cached = get_cached_geocode("sahil")  # Lowercase
+        assert cached == results  # Should match due to normalization
+
+    def test_traffic_caching(self):
+        """Traffic caching helpers should work correctly."""
+        clear_all_caches()
+
+        traffic_data = {"severity": 2, "speed": 30}
+
+        # Cache traffic conditions
+        cache_traffic(40.1, 49.2, 2.0, traffic_data)
+
+        # Retrieve cached traffic
+        cached = get_cached_traffic(40.1, 49.2, 2.0)
+        assert cached == traffic_data
+
+        # Different radius should not match
+        cached = get_cached_traffic(40.1, 49.2, 3.0)
+        assert cached is None
+
+    def test_clear_all_caches(self):
+        """Clear all caches should remove all cached data."""
+        # Add data to different caches
+        cache_route(40.1, 49.2, 40.3, 49.4, {"data": "route"})
+        cache_geocode("test", [{"data": "geocode"}])
+        cache_traffic(40.1, 49.2, 2.0, {"data": "traffic"})
+
+        # Verify data is cached
+        assert get_cached_route(40.1, 49.2, 40.3, 49.4) is not None
+        assert get_cached_geocode("test") is not None
+        assert get_cached_traffic(40.1, 49.2, 2.0) is not None
+
+        # Clear all caches
+        clear_all_caches()
+
+        # Verify all caches are empty
+        assert get_cached_route(40.1, 49.2, 40.3, 49.4) is None
+        assert get_cached_geocode("test") is None
+        assert get_cached_traffic(40.1, 49.2, 2.0) is None
\ No newline at end of file
diff --git a/backend/tests/test_circuit_breaker.py b/backend/tests/test_circuit_breaker.py
new file mode 100644
index 0000000..c99de1c
--- /dev/null
+++ b/backend/tests/test_circuit_breaker.py
@@ -0,0 +1,218 @@
+"""Test circuit breaker implementation."""
+import time
+import pytest
+from unittest.mock import Mock, patch
+
+from app.circuit_breaker import (
+    CircuitBreaker,
+    CircuitOpenError,
+    CircuitState,
+    get_circuit_breaker,
+    with_circuit_breaker,
+)
+
+
+class TestCircuitBreaker:
+    """Test the circuit breaker pattern implementation."""
+
+    def test_circuit_starts_closed(self):
+        """Circuit should start in closed state."""
+        breaker = CircuitBreaker("test", failure_threshold=3, cooldown_seconds=1)
+        assert breaker.state == CircuitState.CLOSED
+        assert breaker.is_closed()
+        assert not breaker.is_open()
+
+    def test_successful_calls_pass_through(self):
+        """Successful calls should pass through when circuit is closed."""
+        breaker = CircuitBreaker("test", failure_threshold=3)
+        func = Mock(return_value="success")
+
+        result = breaker.call(func, "arg1", key="value")
+
+        assert result == "success"
+        func.assert_called_once_with("arg1", key="value")
+        assert breaker.state == CircuitState.CLOSED
+        assert breaker.stats.successful_calls == 1
+        assert breaker.stats.failed_calls == 0
+
+    def test_circuit_opens_after_threshold(self):
+        """Circuit should open after consecutive failures reach threshold."""
+        breaker = CircuitBreaker("test", failure_threshold=3, cooldown_seconds=10)
+        failing_func = Mock(side_effect=Exception("Test failure"))
+
+        # First two failures shouldn't open circuit
+        for i in range(2):
+            with pytest.raises(Exception, match="Test failure"):
+                breaker.call(failing_func)
+            assert breaker.state == CircuitState.CLOSED
+
+        # Third failure should open the circuit
+        with pytest.raises(Exception, match="Test failure"):
+            breaker.call(failing_func)
+        assert breaker.state == CircuitState.OPEN
+        assert breaker.stats.consecutive_failures == 3
+
+    def test_open_circuit_rejects_calls(self):
+        """Open circuit should reject calls immediately."""
+        breaker = CircuitBreaker("test", failure_threshold=1, cooldown_seconds=10)
+        failing_func = Mock(side_effect=Exception("Test failure"))
+
+        # Open the circuit
+        with pytest.raises(Exception):
+            breaker.call(failing_func)
+        assert breaker.state == CircuitState.OPEN
+
+        # Subsequent calls should be rejected
+        func = Mock(return_value="success")
+        with pytest.raises(CircuitOpenError) as exc_info:
+            breaker.call(func)
+
+        # Function should not be called when circuit is open
+        func.assert_not_called()
+        assert "Circuit breaker 'test' is open" in str(exc_info.value)
+        assert breaker.stats.rejected_calls == 1
+
+    def test_circuit_transitions_to_half_open(self):
+        """Circuit should transition to half-open after cooldown."""
+        breaker = CircuitBreaker("test", failure_threshold=1, cooldown_seconds=0.1)
+        failing_func = Mock(side_effect=Exception("Test failure"))
+
+        # Open the circuit
+        with pytest.raises(Exception):
+            breaker.call(failing_func)
+        assert breaker.state == CircuitState.OPEN
+
+        # Wait for cooldown
+        time.sleep(0.15)
+
+        # Circuit should now be half-open
+        assert breaker.state == CircuitState.HALF_OPEN
+
+    def test_half_open_closes_on_success(self):
+        """Half-open circuit should close after successful call."""
+        breaker = CircuitBreaker(
+            "test", failure_threshold=1, cooldown_seconds=0.1, success_threshold=1
+        )
+        failing_func = Mock(side_effect=Exception("Test failure"))
+        success_func = Mock(return_value="success")
+
+        # Open the circuit
+        with pytest.raises(Exception):
+            breaker.call(failing_func)
+        assert breaker.state == CircuitState.OPEN
+
+        # Wait for cooldown
+        time.sleep(0.15)
+        assert breaker.state == CircuitState.HALF_OPEN
+
+        # Successful call should close the circuit
+        result = breaker.call(success_func)
+        assert result == "success"
+        assert breaker.state == CircuitState.CLOSED
+        assert breaker.stats.consecutive_failures == 0
+
+    def test_half_open_reopens_on_failure(self):
+        """Half-open circuit should reopen immediately on failure."""
+        breaker = CircuitBreaker("test", failure_threshold=2, cooldown_seconds=0.1)
+        failing_func = Mock(side_effect=Exception("Test failure"))
+
+        # Open the circuit
+        for _ in range(2):
+            with pytest.raises(Exception):
+                breaker.call(failing_func)
+        assert breaker.state == CircuitState.OPEN
+
+        # Wait for cooldown
+        time.sleep(0.15)
+        assert breaker.state == CircuitState.HALF_OPEN
+
+        # Failure in half-open should immediately reopen
+        with pytest.raises(Exception):
+            breaker.call(failing_func)
+        assert breaker.state == CircuitState.OPEN
+
+    def test_manual_reset(self):
+        """Manual reset should close the circuit."""
+        breaker = CircuitBreaker("test", failure_threshold=1)
+        failing_func = Mock(side_effect=Exception("Test failure"))
+
+        # Open the circuit
+        with pytest.raises(Exception):
+            breaker.call(failing_func)
+        assert breaker.state == CircuitState.OPEN
+
+        # Manual reset
+        breaker.reset()
+        assert breaker.state == CircuitState.CLOSED
+        assert breaker.stats.consecutive_failures == 0
+
+        # Should be able to call again
+        success_func = Mock(return_value="success")
+        result = breaker.call(success_func)
+        assert result == "success"
+
+    def test_disabled_circuit_breaker(self):
+        """Disabled circuit breaker should always pass through calls."""
+        breaker = CircuitBreaker("test", failure_threshold=1, enabled=False)
+        failing_func = Mock(side_effect=Exception("Test failure"))
+
+        # Should pass through failures without opening
+        for _ in range(5):
+            with pytest.raises(Exception, match="Test failure"):
+                breaker.call(failing_func)
+
+        # Circuit should remain closed
+        assert breaker.state == CircuitState.CLOSED
+        # Stats should not be updated when disabled
+        assert breaker.stats.failed_calls == 0
+
+    def test_circuit_breaker_stats(self):
+        """Circuit breaker should track statistics correctly."""
+        breaker = CircuitBreaker("test", failure_threshold=2)
+        success_func = Mock(return_value="success")
+        failing_func = Mock(side_effect=Exception("failure"))
+
+        # Some successful calls
+        for _ in range(3):
+            breaker.call(success_func)
+
+        # Some failures
+        with pytest.raises(Exception):
+            breaker.call(failing_func)
+
+        stats = breaker.stats
+        assert stats.total_calls == 4
+        assert stats.successful_calls == 3
+        assert stats.failed_calls == 1
+        assert stats.consecutive_failures == 1
+
+    def test_global_circuit_breaker_instances(self):
+        """Global circuit breaker instances should be reused."""
+        breaker1 = get_circuit_breaker("test_api")
+        breaker2 = get_circuit_breaker("test_api")
+        breaker3 = get_circuit_breaker("other_api")
+
+        assert breaker1 is breaker2
+        assert breaker1 is not breaker3
+
+    def test_with_circuit_breaker_wrapper(self):
+        """with_circuit_breaker function should wrap calls correctly."""
+        success_func = Mock(return_value="result")
+
+        result = with_circuit_breaker(success_func, "test_circuit", "arg", key="value")
+
+        assert result == "result"
+        success_func.assert_called_once_with("arg", key="value")
+
+    @patch("app.circuit_breaker.settings")
+    def test_uses_settings_defaults(self, mock_settings):
+        """Circuit breaker should use settings for defaults."""
+        mock_settings.GOMAP_CIRCUIT_BREAKER_THRESHOLD = 5
+        mock_settings.GOMAP_CIRCUIT_BREAKER_COOLDOWN_SECONDS = 120
+        mock_settings.GOMAP_CIRCUIT_BREAKER_ENABLED = True
+
+        breaker = CircuitBreaker("test")
+
+        assert breaker.failure_threshold == 5
+        assert breaker.cooldown_seconds == 120
+        assert breaker.enabled is True
\ No newline at end of file
diff --git a/backend/tests/test_e2e_workflows.py b/backend/tests/test_e2e_workflows.py
index dc45923..e697a20 100644
--- a/backend/tests/test_e2e_workflows.py
+++ b/backend/tests/test_e2e_workflows.py
@@ -21,9 +21,10 @@ class TestCompleteUserJourneys:
         """Test: New user opens app and discovers restaurants"""
         # Step 1: User opens app, app checks health
         health = client.get("/health")
-        assert health.status_code == 200
+        assert health.status_code in [200, 503]  # 200 if healthy, 503 if degraded
         data = health.json()
-        assert data["ok"] is True
+        assert data["status"] in ["healthy", "degraded"]
+        assert data["service"] == "baku-reserve"
 
         # Step 2: User views restaurant list
         restaurants = client.get("/restaurants")
diff --git a/backend/tests/test_integration_api.py b/backend/tests/test_integration_api.py
index 68454bc..b6c7e9a 100644
--- a/backend/tests/test_integration_api.py
+++ b/backend/tests/test_integration_api.py
@@ -51,9 +51,10 @@ class TestRestaurantIntegration:
     def test_health_check_integration(self, client):
         """Test health endpoint"""
         response = client.get("/health")
-        assert response.status_code == 200
+        assert response.status_code in [200, 503]  # 200 if healthy, 503 if degraded
         data = response.json()
-        assert data["ok"] is True
+        assert data["status"] in ["healthy", "degraded"]
+        assert data["service"] == "baku-reserve"
 
 
 class TestConciergeIntegration:
diff --git a/backend/tests/test_validation.py b/backend/tests/test_validation.py
index 846f97e..a3628f8 100644
--- a/backend/tests/test_validation.py
+++ b/backend/tests/test_validation.py
@@ -3,7 +3,7 @@ from __future__ import annotations
 from datetime import datetime, timedelta
 
 import pytest
-from backend.app.models import ArrivalIntentRequest, ReservationCreate
+from backend.app.models import ArrivalIntent, ArrivalIntentRequest, ReservationCreate
 from backend.app.schemas import PreorderRequest
 from pydantic import ValidationError
 
@@ -55,3 +55,8 @@ def test_arrival_intent_notes_trimmed_and_limited():
     long_note = "x" * 500
     with pytest.raises(ValidationError):
         ArrivalIntentRequest(lead_minutes=20, notes=long_note)
+
+
+def test_arrival_intent_accepts_unknown_traffic():
+    intent = ArrivalIntent(traffic_condition="unknown")
+    assert intent.traffic_condition == "unknown"
diff --git a/mobile/__tests__/experience.ui.test.tsx b/mobile/__tests__/experience.ui.test.tsx
index 77cc433..d644eb4 100644
--- a/mobile/__tests__/experience.ui.test.tsx
+++ b/mobile/__tests__/experience.ui.test.tsx
@@ -6,14 +6,23 @@ import RestaurantCard from '../src/components/RestaurantCard';
 import PhotoCarousel from '../src/components/PhotoCarousel';
 import LiveSyncBadge from '../src/screens/SeatPicker/components/LiveSyncBadge';
 import { useRestaurants } from '../src/hooks/useRestaurants';
+import { useArrivalSuggestions } from '../src/hooks/useArrivalSuggestions';
 import { useVenueLayout } from '../src/screens/SeatPicker/useVenueLayout';
 import PrepNotifyScreen from '../src/screens/PrepNotifyScreen';
-import type { FeatureFlags, RestaurantSummary, RestaurantDetail, Reservation } from '../src/api';
+import type {
+  FeatureFlags,
+  RestaurantSummary,
+  RestaurantDetail,
+  Reservation,
+  ArrivalLocationSuggestion,
+} from '../src/api';
 
 jest.mock('../src/api', () => ({
   fetchRestaurants: jest.fn(),
   getPreorderQuote: jest.fn(),
   confirmPreorder: jest.fn(),
+  sendArrivalLocation: jest.fn(),
+  fetchArrivalLocationSuggestions: jest.fn(),
 }));
 
 jest.mock('expo-location', () => ({
@@ -26,10 +35,14 @@ const apiMock = jest.requireMock('../src/api') as {
   fetchRestaurants: jest.Mock;
   getPreorderQuote: jest.Mock;
   confirmPreorder: jest.Mock;
+  sendArrivalLocation: jest.Mock;
+  fetchArrivalLocationSuggestions: jest.Mock;
 };
 const fetchRestaurants = apiMock.fetchRestaurants;
 const getPreorderQuote = apiMock.getPreorderQuote;
 const confirmPreorder = apiMock.confirmPreorder;
+const sendArrivalLocation = apiMock.sendArrivalLocation;
+const fetchArrivalLocationSuggestions = apiMock.fetchArrivalLocationSuggestions;
 const alertSpy = jest.spyOn(Alert, 'alert').mockImplementation(() => undefined);
 
 const sampleRestaurants: RestaurantSummary[] = [
@@ -88,6 +101,134 @@ describe('Hooks and UI experiences', () => {
     });
   });
 
+  describe('useArrivalSuggestions', () => {
+    const makeSuggestion = (id: string): ArrivalLocationSuggestion => ({
+      id,
+      name: id,
+      latitude: 40.4,
+      longitude: 49.9,
+    });
+
+    beforeEach(() => {
+      jest.useFakeTimers();
+    });
+
+    afterEach(() => {
+      jest.useRealTimers();
+    });
+
+    const advanceDebounce = async (ms = 30) => {
+      await act(async () => {
+        jest.advanceTimersByTime(ms);
+      });
+      await act(async () => {});
+    };
+
+    it('applies only the latest query results', async () => {
+      let resolveFirst: ((value: ArrivalLocationSuggestion[]) => void) | null = null;
+      fetchArrivalLocationSuggestions
+        .mockImplementationOnce(() => new Promise((resolve) => {
+          resolveFirst = resolve;
+        }))
+        .mockImplementationOnce(async () => [makeSuggestion('second')]);
+
+      const { result, rerender } = renderHook(
+        ({ query, enabled }: { query: string; enabled: boolean }) =>
+          useArrivalSuggestions('res-1', query, { enabled, debounceMs: 25 }),
+        { initialProps: { query: '', enabled: true } },
+      );
+
+      await act(async () => {
+        rerender({ query: 'ko', enabled: true });
+      });
+      await advanceDebounce();
+
+      await act(async () => {
+        rerender({ query: 'koala', enabled: true });
+      });
+      await advanceDebounce();
+
+      expect(result.current.suggestions[0]?.id).toBe('second');
+      expect(fetchArrivalLocationSuggestions).toHaveBeenCalledTimes(2);
+
+      await act(async () => {
+        resolveFirst?.([makeSuggestion('first')]);
+      });
+      await act(async () => {});
+      expect(result.current.suggestions[0]?.id).toBe('second');
+    });
+
+    it('keeps prior suggestions when disabled for preset fallback', async () => {
+      fetchArrivalLocationSuggestions.mockResolvedValue([makeSuggestion('alpha')]);
+
+      const { result, rerender } = renderHook(
+        ({ query, enabled }: { query: string; enabled: boolean }) =>
+          useArrivalSuggestions('res-2', query, { enabled, debounceMs: 20 }),
+        { initialProps: { query: '', enabled: true } },
+      );
+
+      await act(async () => {
+        rerender({ query: 'alpha', enabled: true });
+      });
+      await advanceDebounce();
+      expect(result.current.suggestions).toHaveLength(1);
+      expect(result.current.isStale).toBe(false);
+
+      rerender({ query: 'alpha', enabled: false });
+      await act(async () => {});
+      expect(result.current.suggestions).toHaveLength(1);
+      expect(result.current.isStale).toBe(true);
+      expect(fetchArrivalLocationSuggestions).toHaveBeenCalledTimes(1);
+    });
+
+    it('surfaces API errors without clearing existing data mid-flight', async () => {
+      fetchArrivalLocationSuggestions.mockRejectedValue(new Error('GoMap down'));
+
+      const { result, rerender } = renderHook(
+        ({ query, enabled }: { query: string; enabled: boolean }) =>
+          useArrivalSuggestions('res-3', query, { enabled, debounceMs: 20 }),
+        { initialProps: { query: '', enabled: true } },
+      );
+
+      await act(async () => {
+        rerender({ query: 'fail', enabled: true });
+      });
+      await advanceDebounce();
+      expect(result.current.error).toBe('GoMap down');
+      expect(result.current.isStale).toBe(true);
+      expect(result.current.suggestions).toHaveLength(0);
+    });
+
+    it('marks cached suggestions as stale when query clears for preset mode', async () => {
+      fetchArrivalLocationSuggestions.mockResolvedValue([makeSuggestion('preset')]);
+
+      const { result, rerender } = renderHook(
+        ({ query, enabled }: { query: string; enabled: boolean }) =>
+          useArrivalSuggestions('res-4', query, { enabled, debounceMs: 20 }),
+        { initialProps: { query: '', enabled: true } },
+      );
+
+      await act(async () => {
+        rerender({ query: 'preset', enabled: true });
+      });
+      await advanceDebounce();
+      expect(result.current.suggestions).toHaveLength(1);
+      expect(result.current.isStale).toBe(false);
+
+      rerender({ query: '', enabled: true });
+      await act(async () => {});
+      expect(result.current.isStale).toBe(true);
+      expect(result.current.suggestions).toHaveLength(1);
+
+      await act(async () => {
+        result.current.reset();
+      });
+      await act(async () => {});
+      expect(result.current.suggestions).toHaveLength(0);
+      expect(result.current.hasFetched).toBe(false);
+    });
+  });
+
   describe('useVenueLayout', () => {
     const restaurant: RestaurantDetail = {
       id: 'venue-1',
@@ -255,5 +396,47 @@ describe('Hooks and UI experiences', () => {
       }
       expect(navigation.goBack).toHaveBeenCalled();
     });
+
+    it('shares live location when GoMap is ready', async () => {
+      const reservation: Reservation = {
+        id: 'res-2',
+        restaurant_id: 'rest-9',
+        party_size: 2,
+        start: new Date().toISOString(),
+        end: new Date(Date.now() + 3600_000).toISOString(),
+        status: 'booked',
+        arrival_intent: undefined,
+      };
+      const features: FeatureFlags = {
+        prep_notify_enabled: true,
+        payments_mode: 'mock',
+        payment_provider: 'mock',
+        currency: 'AZN',
+        gomap_ready: true,
+      };
+      getPreorderQuote.mockResolvedValue({
+        policy: 'Kitchen starts once you are en route.',
+        recommended_prep_minutes: 10,
+      });
+      sendArrivalLocation.mockResolvedValue(reservation);
+
+      const route = { params: { reservation, restaurantName: 'Test Kitchen', features } } as any;
+      const navigation = { goBack: jest.fn() } as any;
+
+      const { findByText, getByText } = render(
+        <PrepNotifyScreen navigation={navigation} route={route} />,
+      );
+
+      await findByText('Kitchen starts once you are en route.');
+      fireEvent.press(getByText('Use my location to estimate'));
+
+      await waitFor(() =>
+        expect(sendArrivalLocation).toHaveBeenCalledWith('res-2', {
+          latitude: 40.4,
+          longitude: 49.9,
+        }),
+      );
+      await findByText('Location shared. The kitchen will auto-refresh your ETA.');
+    });
   });
 });
diff --git a/mobile/__tests__/platform.core.test.tsx b/mobile/__tests__/platform.core.test.tsx
index e373a2a..5d2ce9e 100644
--- a/mobile/__tests__/platform.core.test.tsx
+++ b/mobile/__tests__/platform.core.test.tsx
@@ -278,19 +278,20 @@ describe('Utility helpers', () => {
         hold_ids: [],
       },
     ] as const;
+    const testTimezone = 'America/Chicago';
 
     it('locates the slot matching a selected time', () => {
-      const match = findSlotForTime(baseSlots as any, '2025-05-01', '19:30');
+      const match = findSlotForTime(baseSlots as any, '2025-05-01', '19:30', testTimezone);
       expect(match).toBe(baseSlots[1]);
     });
 
     it('returns null when target time is missing', () => {
-      expect(findSlotForTime(baseSlots as any, '2025-05-01', '17:15')).toBeNull();
+      expect(findSlotForTime(baseSlots as any, '2025-05-01', '17:15', testTimezone)).toBeNull();
     });
 
     it('suggests slots ordered by proximity to target', () => {
-      const target = getSelectionTimestamp('2025-05-01', '19:00');
-      const suggestions = getSuggestedSlots(baseSlots as any, target, 2);
+      const target = getSelectionTimestamp('2025-05-01', '19:00', testTimezone);
+      const suggestions = getSuggestedSlots(baseSlots as any, target, 2, testTimezone);
       expect(suggestions).toHaveLength(2);
       expect(suggestions[0]).toBe(baseSlots[1]);
       expect(suggestions[1]).toBe(baseSlots[0]);
diff --git a/mobile/src/api.ts b/mobile/src/api.ts
index 17ca4cf..eeb9e21 100644
--- a/mobile/src/api.ts
+++ b/mobile/src/api.ts
@@ -14,6 +14,7 @@ export type RestaurantSummary = {
   slug?: string;
   cuisine: string[];
   city?: string;
+  timezone?: string;
   neighborhood?: string;
   address?: string;
   cover_photo?: string;
@@ -99,6 +100,7 @@ export type AvailabilitySlot = {
 
 export type AvailabilityResponse = {
   slots: AvailabilitySlot[];
+  restaurant_timezone?: string | null;
 };
 
 export type Reservation = {
@@ -140,8 +142,15 @@ export type ArrivalIntent = {
   notes?: string | null;
   auto_charge?: boolean;
   predicted_eta_minutes?: number | null;
+  predicted_eta_seconds?: number | null;
   confirmed_eta_minutes?: number | null;
   last_location?: { latitude: number; longitude: number } | null;
+  typical_eta_minutes?: number | null;
+  route_distance_km?: number | null;
+  route_summary?: string | null;
+  traffic_condition?: 'smooth' | 'moderate' | 'heavy' | 'severe' | 'unknown' | null;
+  traffic_source?: 'gomap' | 'osrm' | 'fallback' | null;
+  traffic_updated_at?: string | null;
 };
 
 export type ArrivalIntentRequest = {
@@ -167,6 +176,19 @@ export type ArrivalEtaConfirmation = {
   eta_minutes: number;
 };
 
+export type ArrivalLocationSuggestion = {
+  id: string;
+  name: string;
+  address?: string | null;
+  latitude: number;
+  longitude: number;
+  distance_km?: number | null;
+  eta_minutes?: number | null;
+  eta_seconds?: number | null;
+  route_summary?: string | null;
+  provider?: string | null;
+};
+
 export type FeatureFlags = {
   prep_notify_enabled: boolean;
   payments_mode: 'mock' | 'live' | string;
@@ -359,6 +381,29 @@ export async function sendArrivalLocation(reservationId: string, payload: Arriva
   return handleResponse<Reservation>(res, 'Failed to share location');
 }
 
+export async function fetchArrivalLocationSuggestions(
+  reservationId: string,
+  query: string,
+  limit = 5,
+  signal?: AbortSignal,
+) {
+  const trimmed = query.trim();
+  if (!trimmed) {
+    return [] as ArrivalLocationSuggestion[];
+  }
+  const params = new URLSearchParams();
+  params.set('q', trimmed);
+  params.set('limit', String(limit));
+  const res = await fetch(
+    `${API_URL}/reservations/${reservationId}/arrival_intent/suggestions?${params.toString()}`,
+    { headers: withAuth(), signal },
+  );
+  return handleResponse<ArrivalLocationSuggestion[]>(
+    res,
+    'Unable to load GoMap suggestions',
+  );
+}
+
 export async function confirmArrivalEta(reservationId: string, payload: ArrivalEtaConfirmation) {
   const res = await fetch(`${API_URL}/reservations/${reservationId}/arrival_intent/eta`, {
     method: 'POST',
diff --git a/mobile/src/screens/BookScreen.tsx b/mobile/src/screens/BookScreen.tsx
index a3a3ae9..2a88b05 100644
--- a/mobile/src/screens/BookScreen.tsx
+++ b/mobile/src/screens/BookScreen.tsx
@@ -20,7 +20,15 @@ import { fetchAvailability, fetchRestaurant, AvailabilitySlot, RestaurantDetail
 import { colors, radius, shadow, spacing } from '../config/theme';
 import FloorPlanExplorer from '../components/floor/FloorPlanExplorer';
 import { RESTAURANT_FLOOR_PLANS } from '../data/floorPlans';
-import { findSlotForTime, getSuggestedSlots, getSelectionTimestamp } from '../utils/availability';
+import {
+  DEFAULT_TIMEZONE,
+  findSlotForTime,
+  getSuggestedSlots,
+  getSelectionTimestamp,
+  getTimeString,
+  formatDateLabel,
+  formatTimeLabel,
+} from '../utils/availability';
 import { buildFloorPlanForRestaurant } from '../utils/floorPlans';
 import type { NativeStackScreenProps } from '@react-navigation/native-stack';
 import type { RootStackParamList } from '../types/navigation';
@@ -44,109 +52,52 @@ function parseDateInput(value: string): Date | null {
   return parsed;
 }
 
-const CENTRAL_TIMEZONE = 'America/Chicago';
-
-type ZonedParts = {
-  year: string;
-  month: string;
-  day: string;
-  hour: string;
-  minute: string;
-  second: string;
-};
-
-const centralPartsFormatter = new Intl.DateTimeFormat('en-US', {
-  timeZone: CENTRAL_TIMEZONE,
-  hour12: false,
-  year: 'numeric',
-  month: '2-digit',
-  day: '2-digit',
-  hour: '2-digit',
-  minute: '2-digit',
-  second: '2-digit',
-});
-
-const centralDateDisplayFormatter = new Intl.DateTimeFormat('en-US', {
-  timeZone: CENTRAL_TIMEZONE,
-  weekday: 'short',
-  month: 'short',
-  day: 'numeric',
-});
+const zoneLabelCache = new Map<string, string>();
 
-const centralTimeFormatter12 = new Intl.DateTimeFormat('en-US', {
-  timeZone: CENTRAL_TIMEZONE,
-  hour: 'numeric',
-  minute: '2-digit',
-});
-
-const centralTimeFormatter24 = new Intl.DateTimeFormat('en-GB', {
-  timeZone: CENTRAL_TIMEZONE,
-  hour: '2-digit',
-  minute: '2-digit',
-  hour12: false,
-});
-
-const getCentralParts = (date: Date): ZonedParts => {
-  const parts = centralPartsFormatter.formatToParts(date);
-  const map: Record<string, string> = {};
-  parts.forEach(({ type, value }) => {
-    if (type !== 'literal') {
-      map[type] = value;
-    }
+const getZoneAbbreviation = (timezone: string) => {
+  if (zoneLabelCache.has(timezone)) {
+    return zoneLabelCache.get(timezone)!;
+  }
+  const formatter = new Intl.DateTimeFormat('en-US', {
+    timeZone: timezone,
+    timeZoneName: 'short',
   });
-  return map as ZonedParts;
+  const parts = formatter.formatToParts(new Date());
+  const label = parts.find((part) => part.type === 'timeZoneName')?.value ?? timezone;
+  zoneLabelCache.set(timezone, label);
+  return label;
 };
 
-const getCentralTimestamp = (date: Date) => {
-  const parts = getCentralParts(date);
-  const timestamp = Date.UTC(
-    Number(parts.year),
-    Number(parts.month) - 1,
-    Number(parts.day),
-    Number(parts.hour),
-    Number(parts.minute),
-    Number(parts.second),
-  );
-  return { timestamp, parts };
-};
-
-const getCentralTimestampFromSelection = (dateValue: string, timeValue: string) => {
-  const [year, month, day] = dateValue.split('-').map(Number);
-  const [hour, minute] = timeValue.split(':').map(Number);
-  return Date.UTC(year, month - 1, day, hour, minute, 0);
-};
-
-const formatCentral24Hour = (date: Date) => {
-  return centralTimeFormatter24.format(date);
-};
-
-function timeFromISO(iso: string) {
-  const date = new Date(iso);
-  return centralTimeFormatter12.format(date);
+function formatIsoTime(iso: string, timezone: string) {
+  return formatTimeLabel(new Date(iso), timezone);
 }
 
-function formatHumanDate(value: string) {
+function formatHumanDate(value: string, timezone: string) {
   const trimmed = value.trim();
   if (!/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
     return 'Select date';
   }
   const [year, month, day] = trimmed.split('-').map(Number);
   const base = new Date(Date.UTC(year, month - 1, day, 12));
-  return centralDateDisplayFormatter.format(base);
+  return formatDateLabel(base, timezone);
 }
 
-function formatTimeInput(date: Date) {
-  return formatCentral24Hour(date);
+function formatTimeInput(date: Date, timezone: string) {
+  return getTimeString(date, timezone);
 }
 
-function formatHumanTime(value: string | null) {
+function formatHumanTime(value: string | null, timezone: string) {
   if (!value) return 'Select time';
   const [hourStr, minuteStr] = value.split(':');
   const hour = Number(hourStr);
   const minute = Number(minuteStr);
+  if (Number.isNaN(hour) || Number.isNaN(minute)) {
+    return 'Select time';
+  }
   const suffix = hour >= 12 ? 'PM' : 'AM';
   const displayHour = ((hour + 11) % 12) + 1;
-  return `${displayHour}:${minute.toString().padStart(2, '0')} ${suffix}`;
+  const zone = getZoneAbbreviation(timezone);
+  return `${displayHour}:${minute.toString().padStart(2, '0')} ${suffix}${zone ? ` ${zone}` : ''}`;
 }
 
 function composeDateTime(dateValue: string, timeValue: string | null) {
@@ -191,6 +142,7 @@ export default function BookScreen({ route, navigation }: Props) {
   const [showTimePicker, setShowTimePicker] = useState<boolean>(false);
   const [pendingTime, setPendingTime] = useState<Date>(() => roundToQuarterHour(new Date()));
   const [restaurantDetail, setRestaurantDetail] = useState<RestaurantDetail | null>(null);
+  const [timezone, setTimezone] = useState<string>(DEFAULT_TIMEZONE);
   const timerRef = useRef<NodeJS.Timeout | null>(null);
   const planBundle = useMemo(() => buildFloorPlanForRestaurant(restaurantDetail), [restaurantDetail]);
   const floorPlan = useMemo(() => planBundle?.plan ?? RESTAURANT_FLOOR_PLANS[id] ?? null, [id, planBundle]);
@@ -232,6 +184,9 @@ export default function BookScreen({ route, navigation }: Props) {
           setDateStr(normalizedDate);
         }
         const data = await fetchAvailability(id, normalizedDate, partySize);
+        if (data.restaurant_timezone) {
+          setTimezone(data.restaurant_timezone);
+        }
         setSlots(data.slots ?? []);
       } catch (err: any) {
         setError(err.message || 'Failed to load availability');
@@ -243,8 +198,8 @@ export default function BookScreen({ route, navigation }: Props) {
     [dateStr, id, partySize],
   );
 
-  const friendlyDate = useMemo(() => formatHumanDate(dateStr), [dateStr]);
-  const friendlyTime = useMemo(() => formatHumanTime(timeStr), [timeStr]);
+  const friendlyDate = useMemo(() => formatHumanDate(dateStr, timezone), [dateStr, timezone]);
+  const friendlyTime = useMemo(() => formatHumanTime(timeStr, timezone), [timeStr, timezone]);
 
   useEffect(() => {
     navigation.setOptions({ title: `Book · ${name}` });
@@ -257,6 +212,9 @@ export default function BookScreen({ route, navigation }: Props) {
         const detail = await fetchRestaurant(id);
         if (mounted) {
           setRestaurantDetail(detail);
+          if (detail.timezone) {
+            setTimezone(detail.timezone);
+          }
         }
       } catch {
         // best-effort; map will fall back to static assets
@@ -311,11 +269,11 @@ export default function BookScreen({ route, navigation }: Props) {
     if (!timeStr && slots.length) {
       const first = new Date(slots[0].start);
       if (!Number.isNaN(first.getTime())) {
-        setTimeStr(formatTimeInput(first));
+        setTimeStr(formatTimeInput(first, timezone));
         setPendingTime(first);
       }
     }
-  }, [slots, timeStr]);
+  }, [slots, timeStr, timezone]);
 
   useEffect(() => {
     if (timeStr) {
@@ -456,17 +414,20 @@ export default function BookScreen({ route, navigation }: Props) {
     handleDateConfirm(pendingDate);
   }, [handleDateConfirm, pendingDate]);
 
-  const handleTimeConfirm = useCallback((selectedTime: Date) => {
-    const rounded = roundToQuarterHour(selectedTime);
-    const normalized = formatTimeInput(rounded);
-    setTimeStr(normalized);
-    setPendingTime(rounded);
-  }, []);
+  const handleTimeConfirm = useCallback(
+    (selectedTime: Date) => {
+      const rounded = roundToQuarterHour(selectedTime);
+      const normalized = formatTimeInput(rounded, timezone);
+      setTimeStr(normalized);
+      setPendingTime(rounded);
+    },
+    [timezone],
+  );
 
   const openTimePicker = useCallback(() => {
     const base = composeDateTime(dateStr, timeStr);
     if (Platform.OS === 'web') {
-      const initial = formatTimeInput(base);
+      const initial = formatTimeInput(base, timezone);
       openWebPicker('time', initial, (raw) => {
         if (!raw) return;
         const [hourStr, minuteStr] = raw.split(':');
@@ -496,7 +457,7 @@ export default function BookScreen({ route, navigation }: Props) {
     }
     setPendingTime(base);
     setShowTimePicker(true);
-  }, [dateStr, handleTimeConfirm, openWebPicker, timeStr]);
+  }, [dateStr, handleTimeConfirm, openWebPicker, timeStr, timezone]);
 
   const closeTimePicker = useCallback(() => setShowTimePicker(false), []);
 
@@ -513,22 +474,23 @@ export default function BookScreen({ route, navigation }: Props) {
       slot,
       guestName: (guestName || profileName).trim(),
       guestPhone: guestPhone.trim(),
+      timezone,
     });
   };
 
   const selectedSlot = useMemo(
-    () => findSlotForTime(slots, dateStr, timeStr),
-    [slots, dateStr, timeStr],
+    () => findSlotForTime(slots, dateStr, timeStr, timezone),
+    [slots, dateStr, timeStr, timezone],
   );
 
   const targetTimestamp = useMemo(
-    () => getSelectionTimestamp(dateStr, timeStr),
-    [dateStr, timeStr],
+    () => getSelectionTimestamp(dateStr, timeStr, timezone),
+    [dateStr, timeStr, timezone],
   );
 
   const suggestedSlots = useMemo(
-    () => getSuggestedSlots(slots, targetTimestamp, 4),
-    [slots, targetTimestamp],
+    () => getSuggestedSlots(slots, targetTimestamp, 4, timezone),
+    [slots, targetTimestamp, timezone],
   );
 
   const selectedSlotAvailability = selectedSlot?.available_table_ids?.length ?? 0;
@@ -538,13 +500,13 @@ export default function BookScreen({ route, navigation }: Props) {
       Alert.alert('Choose a time', 'Select a preferred time before searching for tables.');
       return;
     }
-    const match = findSlotForTime(slots, dateStr, timeStr);
+    const match = findSlotForTime(slots, dateStr, timeStr, timezone);
     if (!match) {
       Alert.alert('No tables at that time', 'Try a suggested time from the list below.');
       return;
     }
     openSeatPicker(match);
-  }, [dateStr, openSeatPicker, slots, timeStr]);
+  }, [dateStr, openSeatPicker, slots, timeStr, timezone]);
 
   const handleSuggestionPick = useCallback((slot: AvailabilitySlot) => {
     const slotDate = new Date(slot.start);
@@ -765,7 +727,7 @@ export default function BookScreen({ route, navigation }: Props) {
               <View style={styles.suggestionRow}>
                 {suggestedSlots.map((slot) => {
                   const slotDate = new Date(slot.start);
-                  const slotTime = formatTimeInput(slotDate);
+                  const slotTime = formatTimeInput(slotDate, timezone);
                   const openCount = slot.available_table_ids?.length ?? 0;
                   const active = slotTime === timeStr;
                   return (
@@ -775,7 +737,7 @@ export default function BookScreen({ route, navigation }: Props) {
                       onPress={() => handleSuggestionPick(slot)}
                     >
                       <Text style={[styles.suggestionTime, active && styles.suggestionTimeActive]}>
-                        {timeFromISO(slot.start)}
+                        {formatIsoTime(slot.start, timezone)}
                       </Text>
                       <Text style={[styles.suggestionMetaSmall, active && styles.suggestionMetaSmallActive]}>
                         {openCount ? `${openCount} open` : 'Waitlist'}
diff --git a/mobile/src/screens/HomeScreen.tsx b/mobile/src/screens/HomeScreen.tsx
index 5fc3cb0..b57b915 100644
--- a/mobile/src/screens/HomeScreen.tsx
+++ b/mobile/src/screens/HomeScreen.tsx
@@ -28,19 +28,14 @@ import type { MainTabParamList, RootStackParamList } from '../types/navigation';
 import type { RestaurantSummary } from '../api';
 import { resolveRestaurantPhotos, defaultFallbackSource } from '../utils/photoSources';
 
-const quickFilters = [
-  { label: 'Tonight', query: 'Dinner' },
-  { label: 'Brunch', query: 'Brunch' },
-  { label: 'Live music', query: 'DJ' },
-  { label: 'Terrace', query: 'Terrace' },
-];
-
 const tagFilterMap: Record<string, string[]> = {
   book_early: ['book_early'],
   waterfront: ['waterfront', 'sunset', 'seaside'],
   skyline: ['skyline', 'rooftop', 'panorama', 'hotel_partner'],
   late_night: ['late_night', 'dj', 'cocktails', 'nikkei'],
-  family_brunch: ['family_brunch', 'family_style', 'breakfast'],
+  family_brunch: ['family_brunch', 'family_style', 'breakfast', 'brunch'],
+  live_music: ['live_music', 'music', 'dj', 'performance'],
+  terrace: ['terrace', 'rooftop', 'garden', 'patio', 'waterfront'],
 };
 
 const vibeFilters = [
@@ -49,6 +44,22 @@ const vibeFilters = [
   { label: 'Skyline lounges', value: 'skyline' },
   { label: 'After dark', value: 'late_night' },
   { label: 'Family brunch', value: 'family_brunch' },
+  { label: 'Live music', value: 'live_music' },
+  { label: 'Terrace views', value: 'terrace' },
+];
+
+type QuickFilterOption = {
+  id: string;
+  label: string;
+  query?: string;
+  tag?: keyof typeof tagFilterMap;
+};
+
+const quickFilters: QuickFilterOption[] = [
+  { id: 'tonight', label: 'Tonight', tag: 'book_early' },
+  { id: 'brunch', label: 'Brunch', tag: 'family_brunch' },
+  { id: 'live-music', label: 'Live music', tag: 'live_music' },
+  { id: 'terrace', label: 'Terrace', tag: 'terrace' },
 ];
 
 const fallbackImageSource = defaultFallbackSource;
@@ -150,11 +161,24 @@ export default function HomeScreen({ navigation }: Props) {
     search(trimmed);
   }, [clear, query, search]);
 
-  const handleQuickFilter = useCallback((value: string) => {
-    setTimeout(() => setQuery(value), 0);
-    setSelectedTag(null);
-    search(value);
-  }, [search]);
+  const handleQuickFilter = useCallback(
+    (filter: QuickFilterOption) => {
+      if (filter.tag) {
+        setSelectedTag(filter.tag);
+        if (query.length) {
+          setQuery('');
+        }
+        clear();
+        return;
+      }
+      if (filter.query) {
+        setSelectedTag(null);
+        setTimeout(() => setQuery(filter.query ?? ''), 0);
+        search(filter.query);
+      }
+    },
+    [clear, query.length, search, setQuery],
+  );
 
   const handleClearQuery = useCallback(() => {
     setSelectedTag(null);
@@ -534,7 +558,7 @@ type HomeListHeaderProps = {
   onChangeQuery: (value: string) => void;
   onSubmitSearch: () => void;
   onClearQuery: () => void;
-  onQuickFilter: (value: string) => void;
+  onQuickFilter: (filter: QuickFilterOption) => void;
   selectedTag: string | null;
   onToggleTag: (value: string) => void;
   error: string | null;
@@ -618,7 +642,11 @@ function HomeListHeader({
           contentContainerStyle={styles.quickRow}
         >
           {quickFilters.map((item) => {
-            const active = lowerQuery === item.query.toLowerCase();
+            const active = item.tag
+              ? selectedTag === item.tag
+              : item.query
+              ? lowerQuery === item.query.toLowerCase()
+              : false;
             const icon = (
               item.label === 'Tonight'
                 ? 'sunset'
@@ -630,8 +658,8 @@ function HomeListHeader({
             ) as keyof typeof Feather.glyphMap;
             return (
               <Pressable
-                key={item.query}
-                onPress={() => onQuickFilter(item.query)}
+                key={item.id}
+                onPress={() => onQuickFilter(item)}
                 style={[styles.quickChip, active && styles.quickChipActive]}
               >
                 <Feather
diff --git a/mobile/src/screens/PrepNotifyScreen.tsx b/mobile/src/screens/PrepNotifyScreen.tsx
index 71231ec..09ee50f 100644
--- a/mobile/src/screens/PrepNotifyScreen.tsx
+++ b/mobile/src/screens/PrepNotifyScreen.tsx
@@ -12,17 +12,24 @@ import {
   View,
 } from 'react-native';
 import type { NativeStackScreenProps } from '@react-navigation/native-stack';
+import { Feather } from '@expo/vector-icons';
 import {
   confirmPreorder,
   getPreorderQuote,
+  sendArrivalLocation,
+  type ArrivalLocationSuggestion,
   type PreorderQuoteResponse,
   type PreorderRequestPayload,
   type Reservation,
 } from '../api';
 import Surface from '../components/Surface';
 import InfoBanner from '../components/InfoBanner';
+import ArrivalInsightCard from '../components/ArrivalInsightCard';
 import { colors, radius, spacing } from '../config/theme';
 import type { RootStackParamList } from '../types/navigation';
+import * as Location from 'expo-location';
+import { isWithinAzerbaijan } from '../utils/location';
+import { useArrivalSuggestions } from '../hooks/useArrivalSuggestions';
 
 const ETA_CHOICES = [5, 10, 15];
 const SCOPE_CHOICES: Array<{ key: PreorderRequestPayload['scope']; label: string }> = [
@@ -30,10 +37,23 @@ const SCOPE_CHOICES: Array<{ key: PreorderRequestPayload['scope']; label: string
   { key: 'full', label: 'Full meal' },
 ];
 
+const describeSuggestion = (suggestion: ArrivalLocationSuggestion) => {
+  const parts: string[] = [];
+  if (suggestion.address) parts.push(suggestion.address);
+  if (typeof suggestion.distance_km === 'number') {
+    parts.push(`${suggestion.distance_km.toFixed(1)} km`);
+  }
+  if (typeof suggestion.eta_minutes === 'number') {
+    parts.push(`${suggestion.eta_minutes} min`);
+  }
+  return parts.join(' • ');
+};
+
 type Props = NativeStackScreenProps<RootStackParamList, 'PrepNotify'>;
 
 export default function PrepNotifyScreen({ navigation, route }: Props) {
-  const { reservation, restaurantName, features } = route.params;
+  const { reservation: initialReservation, restaurantName, features } = route.params;
+  const [reservation, setReservation] = useState<Reservation>(initialReservation);
   const [minutesAway, setMinutesAway] = useState<number>(10);
   const [scope, setScope] = useState<PreorderRequestPayload['scope']>('starters');
   const [itemsNote, setItemsNote] = useState('');
@@ -42,6 +62,26 @@ export default function PrepNotifyScreen({ navigation, route }: Props) {
   const [quoteLoading, setQuoteLoading] = useState(true);
   const [submitting, setSubmitting] = useState(false);
   const [submitError, setSubmitError] = useState<string | null>(null);
+  const [locationState, setLocationState] = useState<'idle' | 'pending' | 'shared' | 'denied'>('idle');
+  const [locationError, setLocationError] = useState<string | null>(null);
+  const [locationNotice, setLocationNotice] = useState<string | null>(null);
+  const [manualQuery, setManualQuery] = useState('');
+  const [manualActive, setManualActive] = useState(false);
+  const [manualStatus, setManualStatus] = useState<string | null>(null);
+  const [manualSubmitting, setManualSubmitting] = useState(false);
+
+  const {
+    suggestions: manualSuggestions,
+    loading: manualLoading,
+    error: manualSuggestionsError,
+    isStale: manualIsStale,
+    hasFetched: manualHasFetched,
+  } = useArrivalSuggestions(reservation.id, manualQuery, {
+    limit: 6,
+    enabled: manualActive || manualQuery.trim().length > 0,
+  });
+  const manualQueryTrimmed = manualQuery.trim();
+  const hasLiveManualSuggestions = manualSuggestions.length > 0 && !manualIsStale;
 
   const reservationWindow = useMemo(() => {
     const start = new Date(reservation.start);
@@ -112,13 +152,57 @@ export default function PrepNotifyScreen({ navigation, route }: Props) {
     }
   };
 
-  const locationSupported = Boolean(features?.maps_api_key_present ?? features?.gomap_ready);
+  const locationSupported = Boolean(features?.gomap_ready ?? features?.maps_api_key_present);
+
+  const handleLocationEstimate = async () => {
+    try {
+      setLocationState('pending');
+      setLocationError(null);
+      setLocationNotice(null);
+      const { status } = await Location.requestForegroundPermissionsAsync();
+      if (status !== 'granted') {
+        setLocationState('denied');
+        setLocationError('Location permission denied. Enable access to sync ETA.');
+        return;
+      }
+      const coords = await Location.getCurrentPositionAsync({ accuracy: Location.Accuracy.High });
+      const { latitude, longitude } = coords.coords;
+      if (!isWithinAzerbaijan(latitude, longitude)) {
+        setLocationState('idle');
+        setLocationError('Share a point within Azerbaijan or pick a manual preset.');
+        setManualStatus('Detected outside Azerbaijan. Search below to pick a manual point.');
+        setManualActive(true);
+        return;
+      }
+      const updated = await sendArrivalLocation(reservation.id, { latitude, longitude });
+      setReservation(updated);
+      setLocationState('shared');
+      setLocationNotice('Location shared. The kitchen will auto-refresh your ETA.');
+      Alert.alert('ETA synced', 'We will keep the kitchen updated automatically.');
+    } catch (err: any) {
+      setLocationState('idle');
+      setLocationError(err?.message || 'Unable to use your location right now.');
+    }
+  };
 
-  const handleLocationEstimate = () => {
-    Alert.alert(
-      'Coming soon',
-      'Live ETA via location will be available once the mapping API is configured.',
-    );
+  const handleManualShare = async (suggestion: ArrivalLocationSuggestion) => {
+    try {
+      setManualSubmitting(true);
+      setManualStatus(`Sharing ${suggestion.name}…`);
+      const updated = await sendArrivalLocation(reservation.id, {
+        latitude: suggestion.latitude,
+        longitude: suggestion.longitude,
+      });
+      setReservation(updated);
+      setLocationState('shared');
+      setLocationNotice('Location shared. The kitchen will auto-refresh your ETA.');
+      setManualStatus(`Using ${suggestion.name}`);
+      Alert.alert('ETA synced', `We will keep the kitchen updated from ${suggestion.name}.`);
+    } catch (err: any) {
+      setManualStatus(err?.message || 'Unable to use that location right now.');
+    } finally {
+      setManualSubmitting(false);
+    }
   };
 
   return (
@@ -156,10 +240,83 @@ export default function PrepNotifyScreen({ navigation, route }: Props) {
             ))}
           </View>
           {locationSupported ? (
-            <Pressable style={styles.locationButton} onPress={handleLocationEstimate}>
-              <Text style={styles.locationButtonText}>Use my location to estimate</Text>
-            </Pressable>
+            <View style={styles.locationBlock}>
+              <Pressable
+                style={[
+                  styles.locationButton,
+                  locationState === 'pending' && styles.locationButtonDisabled,
+                ]}
+                onPress={handleLocationEstimate}
+                disabled={locationState === 'pending'}
+              >
+                <Text style={styles.locationButtonText}>
+                  {locationState === 'pending' ? 'Sharing…' : 'Use my location to estimate'}
+                </Text>
+              </Pressable>
+              {locationError ? (
+                <InfoBanner tone="warning" icon="alert-triangle" title={locationError} />
+              ) : null}
+              {locationNotice ? (
+                <InfoBanner tone="success" icon="navigation" title={locationNotice} />
+              ) : null}
+              <ArrivalInsightCard intent={reservation.arrival_intent} />
+            </View>
+          ) : null}
+        </Surface>
+
+        <Surface tone="overlay" style={styles.section}>
+          <Text style={styles.sectionTitle}>Manual GoMap location</Text>
+          <Text style={styles.sectionSubtitle}>
+            Outside Azerbaijan or GPS blocked? Start typing and GoMap suggests options after every letter.
+          </Text>
+          <TextInput
+            style={styles.manualInlineInput}
+            value={manualQuery}
+            placeholder="Type Flame Towers, Koala Park…"
+            placeholderTextColor={colors.muted}
+            onFocus={() => setManualActive(true)}
+            onChangeText={(value) => {
+              setManualQuery(value);
+              if (!manualActive) setManualActive(true);
+            }}
+          />
+          {manualStatus ? <Text style={styles.manualStatus}>{manualStatus}</Text> : null}
+          {manualSuggestionsError ? (
+            <InfoBanner tone="warning" icon="alert-triangle" title={manualSuggestionsError} />
+          ) : null}
+          {manualLoading ? (
+            <ActivityIndicator style={styles.manualInlineLoading} color={colors.primaryStrong} />
           ) : null}
+          <View style={styles.manualSuggestionList}>
+            {!manualQueryTrimmed ? (
+              <Text style={styles.manualSuggestionEmpty}>Start typing to see live GoMap suggestions.</Text>
+            ) : manualLoading || manualIsStale ? (
+              <Text style={styles.manualSuggestionEmpty}>Fetching live suggestions…</Text>
+            ) : hasLiveManualSuggestions ? (
+              manualSuggestions.map((suggestion) => {
+                const meta = describeSuggestion(suggestion);
+                return (
+                  <Pressable
+                    key={suggestion.id}
+                    style={[styles.manualSuggestionRow, manualSubmitting && styles.manualSuggestionDisabled]}
+                    disabled={manualSubmitting}
+                    onPress={() => handleManualShare(suggestion)}
+                  >
+                    <Feather name="map-pin" size={16} color={colors.primaryStrong} />
+                    <View style={styles.manualSuggestionBody}>
+                      <Text style={styles.manualSuggestionTitle}>{suggestion.name}</Text>
+                      {meta ? <Text style={styles.manualSuggestionMeta}>{meta}</Text> : null}
+                    </View>
+                    <Feather name="chevron-right" size={16} color={colors.muted} />
+                  </Pressable>
+                );
+              })
+            ) : manualHasFetched ? (
+              <Text style={styles.manualSuggestionEmpty}>No matches yet. Keep typing for more options.</Text>
+            ) : (
+              <Text style={styles.manualSuggestionEmpty}>Start typing to see live GoMap suggestions.</Text>
+            )}
+          </View>
         </Surface>
 
         <Surface tone="overlay" style={styles.section}>
@@ -261,6 +418,10 @@ const styles = StyleSheet.create({
     fontWeight: '600',
     color: colors.text,
   },
+  sectionSubtitle: {
+    color: colors.muted,
+    fontSize: 12,
+  },
   segmentRow: {
     flexDirection: 'row',
     flexWrap: 'wrap',
@@ -322,6 +483,9 @@ const styles = StyleSheet.create({
     fontWeight: '600',
     fontSize: 16,
   },
+  locationBlock: {
+    gap: spacing.xs,
+  },
   locationButton: {
     paddingVertical: spacing.sm,
     paddingHorizontal: spacing.md,
@@ -330,9 +494,55 @@ const styles = StyleSheet.create({
     borderWidth: 1,
     borderColor: colors.border,
   },
+  locationButtonDisabled: {
+    opacity: 0.7,
+  },
   locationButtonText: {
     textAlign: 'center',
     fontWeight: '600',
     color: colors.primaryStrong,
   },
+  manualInlineInput: {
+    borderWidth: 1,
+    borderColor: colors.border,
+    borderRadius: radius.md,
+    paddingHorizontal: spacing.md,
+    paddingVertical: spacing.sm,
+    color: colors.text,
+  },
+  manualStatus: {
+    color: colors.text,
+    fontSize: 12,
+  },
+  manualInlineLoading: {
+    marginTop: spacing.xs,
+  },
+  manualSuggestionList: {
+    gap: spacing.xs,
+  },
+  manualSuggestionRow: {
+    flexDirection: 'row',
+    alignItems: 'center',
+    gap: spacing.sm,
+    paddingVertical: spacing.xs,
+  },
+  manualSuggestionDisabled: {
+    opacity: 0.5,
+  },
+  manualSuggestionBody: {
+    flex: 1,
+    gap: 2,
+  },
+  manualSuggestionTitle: {
+    color: colors.text,
+    fontWeight: '600',
+  },
+  manualSuggestionMeta: {
+    color: colors.muted,
+    fontSize: 12,
+  },
+  manualSuggestionEmpty: {
+    color: colors.muted,
+    fontSize: 12,
+  },
 });
diff --git a/mobile/src/screens/ReservationsScreen.tsx b/mobile/src/screens/ReservationsScreen.tsx
index 1c0a34f..8796222 100644
--- a/mobile/src/screens/ReservationsScreen.tsx
+++ b/mobile/src/screens/ReservationsScreen.tsx
@@ -21,6 +21,7 @@ import {
   fetchReservationsList,
   requestArrivalIntent,
   sendArrivalLocation,
+  type ArrivalLocationSuggestion,
   type FeatureFlags,
   type Reservation,
 } from '../api';
@@ -28,6 +29,8 @@ import { colors, radius, spacing } from '../config/theme';
 import Surface from '../components/Surface';
 import SectionHeading from '../components/SectionHeading';
 import InfoBanner from '../components/InfoBanner';
+import ArrivalInsightCard from '../components/ArrivalInsightCard';
+import { useArrivalSuggestions } from '../hooks/useArrivalSuggestions';
 import { useRestaurants } from '../hooks/useRestaurants';
 import { useAuth } from '../contexts/AuthContext';
 import { useFocusEffect } from '@react-navigation/native';
@@ -35,6 +38,7 @@ import type { CompositeScreenProps } from '@react-navigation/native';
 import type { BottomTabScreenProps } from '@react-navigation/bottom-tabs';
 import type { NativeStackScreenProps } from '@react-navigation/native-stack';
 import type { MainTabParamList, RootStackParamList } from '../types/navigation';
+import { isWithinAzerbaijan } from '../utils/location';
 
 type Props = CompositeScreenProps<
   BottomTabScreenProps<MainTabParamList, 'Reservations'>,
@@ -52,19 +56,42 @@ const timeFormatter = new Intl.DateTimeFormat(undefined, {
   minute: '2-digit',
 });
 
-const AZERBAIJAN_BOUNDS = {
-  minLat: 38.3,
-  maxLat: 42.8,
-  minLon: 44,
-  maxLon: 51.7,
-};
-
-const PRESET_LOCATIONS = [
-  { label: 'Koala Park, Baku', latitude: 40.4021, longitude: 49.8431 },
-  { label: 'Icherisheher', latitude: 40.3666, longitude: 49.8352 },
-  { label: 'Port Baku Mall', latitude: 40.3722, longitude: 49.8553 },
-  { label: 'Flame Towers', latitude: 40.3595, longitude: 49.8274 },
-  { label: 'Deniz Mall', latitude: 40.3694, longitude: 49.8408 },
+const PRESET_LOCATIONS: ArrivalLocationSuggestion[] = [
+  {
+    id: 'preset-koala',
+    name: 'Koala Park, Baku',
+    address: 'Central Baku',
+    latitude: 40.4021,
+    longitude: 49.8431,
+  },
+  {
+    id: 'preset-icherisheher',
+    name: 'Icherisheher',
+    address: 'Old City',
+    latitude: 40.3666,
+    longitude: 49.8352,
+  },
+  {
+    id: 'preset-port-baku',
+    name: 'Port Baku Mall',
+    address: 'Shopping district',
+    latitude: 40.3722,
+    longitude: 49.8553,
+  },
+  {
+    id: 'preset-flame-towers',
+    name: 'Flame Towers',
+    address: 'Flame Towers complex',
+    latitude: 40.3595,
+    longitude: 49.8274,
+  },
+  {
+    id: 'preset-deniz-mall',
+    name: 'Deniz Mall',
+    address: 'Seaside promenade',
+    latitude: 40.3694,
+    longitude: 49.8408,
+  },
 ];
 
 const normalizeError = (value: string | undefined, fallback: string) => {
@@ -72,6 +99,20 @@ const normalizeError = (value: string | undefined, fallback: string) => {
   return value.toLowerCase().includes('setmanualerror') ? fallback : value;
 };
 
+const formatSuggestionMeta = (suggestion: ArrivalLocationSuggestion) => {
+  const parts: string[] = [];
+  if (suggestion.address) {
+    parts.push(suggestion.address);
+  }
+  if (typeof suggestion.distance_km === 'number') {
+    parts.push(`${suggestion.distance_km.toFixed(1)} km`);
+  }
+  if (typeof suggestion.eta_minutes === 'number') {
+    parts.push(`${suggestion.eta_minutes} min`);
+  }
+  return parts.join(' • ');
+};
+
 export default function ReservationsScreen({ navigation }: Props) {
   const { restaurants } = useRestaurants();
   const { isAuthenticated } = useAuth();
@@ -85,6 +126,25 @@ export default function ReservationsScreen({ navigation }: Props) {
   const [manualQuery, setManualQuery] = useState('');
   const [manualError, setManualError] = useState<string | null>(null);
   const [manualReservationId, setManualReservationId] = useState<string | null>(null);
+  const [manualHelper, setManualHelper] = useState<string | null>(null);
+
+  const manualSuggestionsEnabled = manualLocationVisible && Boolean(manualReservationId);
+  const {
+    suggestions: manualSuggestions,
+    loading: manualSuggestionsLoading,
+    error: manualSuggestionsError,
+    isStale: manualSuggestionsStale,
+    hasFetched: manualSuggestionsFetched,
+    reset: resetManualSuggestions,
+    cancel: cancelManualSuggestions,
+  } = useArrivalSuggestions(manualSuggestionsEnabled ? manualReservationId : null, manualQuery, {
+    limit: 6,
+    enabled: manualSuggestionsEnabled,
+  });
+
+  const manualQueryTrimmed = manualQuery.trim();
+  const showLiveSuggestions = manualSuggestions.length > 0 && !manualSuggestionsStale;
+  const manualList = showLiveSuggestions ? manualSuggestions : PRESET_LOCATIONS;
 
   const restaurantLookup = useMemo(() => {
     const map = new Map<string, string>();
@@ -141,24 +201,20 @@ export default function ReservationsScreen({ navigation }: Props) {
   );
 
   const now = new Date();
-  const filteredManualLocations = useMemo(() => {
-    const q = manualQuery.trim().toLowerCase();
-    if (!q) return PRESET_LOCATIONS;
-    return PRESET_LOCATIONS.filter((loc) => loc.label.toLowerCase().includes(q));
-  }, [manualQuery]);
-
   const triggerManualPicker = useCallback(
     (reservationId: string, message?: string) => {
+      resetManualSuggestions();
       setManualReservationId(reservationId);
       setManualError(message ?? null);
+      setManualHelper(message ?? 'Search updates after each character.');
       setManualQuery('');
       setManualLocationVisible(true);
     },
-    [],
+    [resetManualSuggestions],
   );
 
   const handleManualSelection = useCallback(
-    async (loc: { label: string; latitude: number; longitude: number }) => {
+    async (loc: ArrivalLocationSuggestion) => {
       if (!manualReservationId) {
         setManualError('Select a reservation before sharing your location.');
         return;
@@ -167,6 +223,7 @@ export default function ReservationsScreen({ navigation }: Props) {
         setManualError(null);
         setManualLocationVisible(false);
         setManualReservationId(null);
+        setManualHelper(`Using ${loc.name}`);
         await sendArrivalLocation(manualReservationId, {
           latitude: loc.latitude,
           longitude: loc.longitude,
@@ -367,31 +424,52 @@ export default function ReservationsScreen({ navigation }: Props) {
           <View style={styles.manualModalCard}>
             <Text style={styles.manualTitle}>Choose a nearby point</Text>
             <Text style={styles.manualSubtitle}>
-              We couldn’t use GPS. Pick a spot in Baku so the restaurant knows where you are.
+              We couldn’t use GPS. Start typing any landmark—GoMap will suggest matches as you type.
             </Text>
+            {manualHelper ? <Text style={styles.manualHelper}>{manualHelper}</Text> : null}
+            {manualSuggestionsEnabled && manualQueryTrimmed.length > 0 && (manualSuggestionsLoading || manualSuggestionsStale) ? (
+              <Text style={styles.manualHelper}>Searching GoMap…</Text>
+            ) : null}
             <TextInput
               placeholder="Search Koala Park, Icherisheher…"
               style={styles.manualInput}
               value={manualQuery}
               onChangeText={setManualQuery}
             />
+            {manualSuggestionsLoading ? (
+              <ActivityIndicator style={styles.manualLoading} color={colors.primaryStrong} />
+            ) : null}
+            {manualSuggestionsError ? (
+              <Text style={styles.manualError}>{manualSuggestionsError}</Text>
+            ) : null}
             {manualError ? <Text style={styles.manualError}>{manualError}</Text> : null}
             <View style={styles.manualList}>
-              {filteredManualLocations.map((loc) => (
-                <Pressable key={loc.label} style={styles.manualRow} onPress={() => handleManualSelection(loc)}>
-                  <Feather name="map-pin" size={16} color={colors.primaryStrong} />
-                  <Text style={styles.manualRowText}>{loc.label}</Text>
-                </Pressable>
-              ))}
-              {filteredManualLocations.length === 0 ? (
-                <Text style={styles.manualEmpty}>No matches</Text>
-              ) : null}
+              {manualList.map((loc) => {
+                const meta = formatSuggestionMeta(loc);
+                return (
+                  <Pressable key={loc.id} style={styles.manualRow} onPress={() => handleManualSelection(loc)}>
+                    <Feather name="map-pin" size={16} color={colors.primaryStrong} />
+                    <View style={styles.manualRowBody}>
+                      <Text style={styles.manualRowTitle}>{loc.name}</Text>
+                      {meta ? <Text style={styles.manualRowMeta}>{meta}</Text> : null}
+                    </View>
+                    <Feather name="chevron-right" size={16} color={colors.muted} />
+                  </Pressable>
+                );
+              })}
             </View>
+            {manualSuggestionsFetched && !manualSuggestionsStale && manualSuggestions.length === 0 && manualQueryTrimmed.length > 0 ? (
+              <Text style={styles.manualEmpty}>No GoMap matches yet. Try a different landmark.</Text>
+            ) : null}
             <Pressable
               style={styles.manualClose}
               onPress={() => {
+                cancelManualSuggestions();
                 setManualLocationVisible(false);
                 setManualReservationId(null);
+                setManualError(null);
+                setManualHelper(null);
+                setManualQuery('');
               }}
             >
               <Text style={styles.manualCloseText}>Cancel</Text>
@@ -531,13 +609,7 @@ function ArrivalPrepControls({ reservation, onUpdated, onManualRequest }: PrepPr
       }
       const coords = await Location.getCurrentPositionAsync({ accuracy: Location.Accuracy.High });
       const { latitude, longitude } = coords.coords;
-      const withinBounds =
-        latitude >= AZERBAIJAN_BOUNDS.minLat &&
-        latitude <= AZERBAIJAN_BOUNDS.maxLat &&
-        longitude >= AZERBAIJAN_BOUNDS.minLon &&
-        longitude <= AZERBAIJAN_BOUNDS.maxLon;
-
-      if (!withinBounds) {
+      if (!isWithinAzerbaijan(latitude, longitude)) {
         setLocationState('idle');
         onManualRequest?.('Detected outside Azerbaijan. Pick a nearby point below.');
         return;
@@ -617,6 +689,7 @@ function ArrivalPrepControls({ reservation, onUpdated, onManualRequest }: PrepPr
       {confirmedEta ? (
         <Text style={styles.prepStatus}>Confirmed ETA: {confirmedEta} min</Text>
       ) : null}
+      <ArrivalInsightCard intent={reservation.arrival_intent} />
       {error ? <Text style={styles.prepError}>{error}</Text> : null}
       <View style={styles.prepButtonRow}>
         <Pressable
@@ -925,6 +998,10 @@ const styles = StyleSheet.create({
   manualSubtitle: {
     color: colors.muted,
   },
+  manualHelper: {
+    color: colors.text,
+    fontSize: 13,
+  },
   manualInput: {
     borderWidth: 1,
     borderColor: colors.border,
@@ -937,6 +1014,9 @@ const styles = StyleSheet.create({
     color: colors.primaryStrong,
     fontSize: 12,
   },
+  manualLoading: {
+    marginVertical: spacing.xs,
+  },
   manualList: {
     maxHeight: 200,
     gap: spacing.xs,
@@ -947,10 +1027,18 @@ const styles = StyleSheet.create({
     gap: spacing.sm,
     paddingVertical: spacing.xs,
   },
-  manualRowText: {
+  manualRowBody: {
+    flex: 1,
+    gap: 2,
+  },
+  manualRowTitle: {
     color: colors.text,
     fontWeight: '600',
   },
+  manualRowMeta: {
+    color: colors.muted,
+    fontSize: 12,
+  },
   manualEmpty: {
     textAlign: 'center',
     color: colors.muted,
diff --git a/mobile/src/screens/SeatPicker.tsx b/mobile/src/screens/SeatPicker.tsx
index 646a76e..cf1a490 100644
--- a/mobile/src/screens/SeatPicker.tsx
+++ b/mobile/src/screens/SeatPicker.tsx
@@ -16,7 +16,7 @@ import {
 import FloorPlanExplorer from '../components/floor/FloorPlanExplorer';
 import InfoBanner from '../components/InfoBanner';
 import { buildFloorPlanForRestaurant } from '../utils/floorPlans';
-import { formatCentralDateLabel, formatCentralTimeLabel } from '../utils/availability';
+import { formatDateLabel, formatTimeLabel, DEFAULT_TIMEZONE } from '../utils/availability';
 import { colors, radius, shadow, spacing } from '../config/theme';
 import type { FloorOverlay } from '../components/floor/types';
 import type { NativeStackScreenProps } from '@react-navigation/native-stack';
@@ -52,9 +52,10 @@ type TableDrawerProps = {
   onRequestClose: () => void;
   onConfirm: (table: TableSummary) => void;
   onClosed: () => void;
+  timezone: string;
 };
 
-function TableConfirmDrawer({ open, state, partySize, slot, accent, onRequestClose, onConfirm, onClosed }: TableDrawerProps) {
+function TableConfirmDrawer({ open, state, partySize, slot, accent, onRequestClose, onConfirm, onClosed, timezone }: TableDrawerProps) {
   const [rendered, setRendered] = useState(open);
   const translateY = React.useRef(new Animated.Value(open ? 0 : SHEET_HEIGHT)).current;
 
@@ -115,8 +116,8 @@ function TableConfirmDrawer({ open, state, partySize, slot, accent, onRequestClo
 
   const startsAt = new Date(slot.start);
   const endsAt = new Date(slot.end);
-  const sheetDateLabel = formatCentralDateLabel(startsAt);
-  const sheetTimeRange = `${formatCentralTimeLabel(startsAt)} → ${formatCentralTimeLabel(endsAt)}`;
+  const sheetDateLabel = formatDateLabel(startsAt, timezone);
+  const sheetTimeRange = `${formatTimeLabel(startsAt, timezone)} → ${formatTimeLabel(endsAt, timezone)}`;
 
   return (
     <View style={styles.sheetOverlay} pointerEvents="box-none">
@@ -166,7 +167,7 @@ function TableConfirmDrawer({ open, state, partySize, slot, accent, onRequestClo
 }
 
 export default function SeatPicker({ route, navigation }: Props) {
-  const { id, name, partySize, slot, guestName, guestPhone } = route.params;
+  const { id, name, partySize, slot, guestName, guestPhone, timezone: initialTimezone } = route.params;
   const [restaurant, setRestaurant] = useState<RestaurantDetail | null>(null);
   const [loading, setLoading] = useState(true);
   const [error, setError] = useState<string | null>(null);
@@ -184,6 +185,8 @@ export default function SeatPicker({ route, navigation }: Props) {
     navigation.setOptions({ title: `Choose table · ${name}` });
   }, [name, navigation]);
 
+  const resolvedTimezone = restaurant?.timezone ?? initialTimezone ?? DEFAULT_TIMEZONE;
+
   useEffect(() => {
     let mounted = true;
     (async () => {
@@ -412,14 +415,17 @@ export default function SeatPicker({ route, navigation }: Props) {
   const heroAccent = colors.primaryStrong;
   const slotStartDate = useMemo(() => new Date(slot.start), [slot.start]);
   const slotEndDate = useMemo(() => new Date(slot.end), [slot.end]);
-  const slotDateLabel = useMemo(() => formatCentralDateLabel(slotStartDate), [slotStartDate]);
+  const slotDateLabel = useMemo(
+    () => formatDateLabel(slotStartDate, resolvedTimezone),
+    [slotStartDate, resolvedTimezone],
+  );
   const slotTimeRange = useMemo(
-    () => `${formatCentralTimeLabel(slotStartDate)} → ${formatCentralTimeLabel(slotEndDate)}`,
-    [slotStartDate, slotEndDate],
+    () => `${formatTimeLabel(slotStartDate, resolvedTimezone)} → ${formatTimeLabel(slotEndDate, resolvedTimezone)}`,
+    [slotStartDate, slotEndDate, resolvedTimezone],
   );
   const lastSyncedLabel = useMemo(
-    () => (lastSyncedAt ? formatCentralTimeLabel(lastSyncedAt) : null),
-    [lastSyncedAt],
+    () => (lastSyncedAt ? formatTimeLabel(lastSyncedAt, resolvedTimezone) : null),
+    [lastSyncedAt, resolvedTimezone],
   );
 
   return (
@@ -558,6 +564,7 @@ export default function SeatPicker({ route, navigation }: Props) {
         onRequestClose={handleDrawerRequestClose}
         onConfirm={(table) => book(table.id)}
         onClosed={handleDrawerClosed}
+        timezone={resolvedTimezone}
       />
     </SafeAreaView>
   );
diff --git a/mobile/src/types/navigation.ts b/mobile/src/types/navigation.ts
index 859c232..2decb9e 100644
--- a/mobile/src/types/navigation.ts
+++ b/mobile/src/types/navigation.ts
@@ -20,6 +20,7 @@ export type RootStackParamList = {
     slot: AvailabilitySlot;
     guestName?: string;
     guestPhone?: string;
+    timezone?: string;
   };
   PrepNotify: {
     reservation: Reservation;
diff --git a/mobile/src/utils/availability.ts b/mobile/src/utils/availability.ts
index 351199d..33afe5e 100644
--- a/mobile/src/utils/availability.ts
+++ b/mobile/src/utils/availability.ts
@@ -1,6 +1,6 @@
 import type { AvailabilitySlot } from '../api';
 
-const CENTRAL_TIMEZONE = 'America/Chicago';
+export const DEFAULT_TIMEZONE = 'Asia/Baku';
 
 type ZonedParts = {
   year: string;
@@ -11,43 +11,64 @@ type ZonedParts = {
   second: string;
 };
 
-const partsFormatter = new Intl.DateTimeFormat('en-US', {
-  timeZone: CENTRAL_TIMEZONE,
-  hour12: false,
-  year: 'numeric',
-  month: '2-digit',
-  day: '2-digit',
-  hour: '2-digit',
-  minute: '2-digit',
-  second: '2-digit',
-});
-
-const timeFormatter24 = new Intl.DateTimeFormat('en-GB', {
-  timeZone: CENTRAL_TIMEZONE,
-  hour: '2-digit',
-  minute: '2-digit',
-  hour12: false,
-});
-
-const dateFormatter = new Intl.DateTimeFormat('en-CA', {
-  timeZone: CENTRAL_TIMEZONE,
-});
-
-const displayDateFormatter = new Intl.DateTimeFormat('en-US', {
-  timeZone: CENTRAL_TIMEZONE,
-  weekday: 'short',
-  month: 'short',
-  day: 'numeric',
-});
-
-const displayTimeFormatter = new Intl.DateTimeFormat('en-US', {
-  timeZone: CENTRAL_TIMEZONE,
-  hour: 'numeric',
-  minute: '2-digit',
-});
-
-const getCentralParts = (date: Date): ZonedParts => {
-  const formatted = partsFormatter.formatToParts(date);
+type FormatterBundle = {
+  parts: Intl.DateTimeFormat;
+  time24: Intl.DateTimeFormat;
+  date: Intl.DateTimeFormat;
+  displayDate: Intl.DateTimeFormat;
+  displayTime: Intl.DateTimeFormat;
+  displayTimeWithZone: Intl.DateTimeFormat;
+};
+
+const formatterCache = new Map<string, FormatterBundle>();
+
+const getFormatters = (timezone?: string): FormatterBundle => {
+  const tz = timezone || DEFAULT_TIMEZONE;
+  if (!formatterCache.has(tz)) {
+    formatterCache.set(tz, {
+      parts: new Intl.DateTimeFormat('en-US', {
+        timeZone: tz,
+        hour12: false,
+        year: 'numeric',
+        month: '2-digit',
+        day: '2-digit',
+        hour: '2-digit',
+        minute: '2-digit',
+        second: '2-digit',
+      }),
+      time24: new Intl.DateTimeFormat('en-GB', {
+        timeZone: tz,
+        hour: '2-digit',
+        minute: '2-digit',
+        hour12: false,
+      }),
+      date: new Intl.DateTimeFormat('en-CA', {
+        timeZone: tz,
+      }),
+      displayDate: new Intl.DateTimeFormat('en-US', {
+        timeZone: tz,
+        weekday: 'short',
+        month: 'short',
+        day: 'numeric',
+      }),
+      displayTime: new Intl.DateTimeFormat('en-US', {
+        timeZone: tz,
+        hour: 'numeric',
+        minute: '2-digit',
+      }),
+      displayTimeWithZone: new Intl.DateTimeFormat('en-US', {
+        timeZone: tz,
+        hour: 'numeric',
+        minute: '2-digit',
+        timeZoneName: 'short',
+      }),
+    });
+  }
+  return formatterCache.get(tz)!;
+};
+
+const getZonedParts = (date: Date, timezone?: string): ZonedParts => {
+  const formatted = getFormatters(timezone).parts.formatToParts(date);
   const map: Record<string, string> = {};
   formatted.forEach(({ type, value }) => {
     if (type !== 'literal') {
@@ -57,8 +78,8 @@ const getCentralParts = (date: Date): ZonedParts => {
   return map as ZonedParts;
 };
 
-const getCentralTimestamp = (date: Date) => {
-  const parts = getCentralParts(date);
+const getZonedTimestamp = (date: Date, timezone?: string) => {
+  const parts = getZonedParts(date, timezone);
   const timestamp = Date.UTC(
     Number(parts.year),
     Number(parts.month) - 1,
@@ -70,7 +91,7 @@ const getCentralTimestamp = (date: Date) => {
   return { timestamp, parts };
 };
 
-const getCentralTimestampFromSelection = (dateStr: string, timeStr: string) => {
+const getZonedTimestampFromSelection = (dateStr: string, timeStr: string) => {
   const [year, month, day] = dateStr.split('-').map(Number);
   const [hour, minute] = timeStr.split(':').map(Number);
   return Date.UTC(year, month - 1, day, hour, minute, 0);
@@ -80,13 +101,14 @@ export const findSlotForTime = (
   slots: AvailabilitySlot[],
   dateStr: string,
   timeStr: string | null,
+  timezone?: string,
 ): AvailabilitySlot | null => {
   if (!timeStr) return null;
   return (
     slots.find((slot) => {
-      const { parts } = getCentralTimestamp(new Date(slot.start));
+      const { parts } = getZonedTimestamp(new Date(slot.start), timezone);
       const slotDate = `${parts.year}-${parts.month}-${parts.day}`;
-      const slotTime = timeFormatter24.format(new Date(slot.start));
+      const slotTime = getFormatters(timezone).time24.format(new Date(slot.start));
       return slotDate === dateStr && slotTime === timeStr;
     }) ?? null
   );
@@ -96,12 +118,13 @@ export const getSuggestedSlots = (
   slots: AvailabilitySlot[],
   targetTimestamp: number | null,
   limit = 4,
+  timezone?: string,
 ): AvailabilitySlot[] => {
   if (!slots.length) {
     return [];
   }
   const enriched = slots.map((slot) => {
-    const { timestamp } = getCentralTimestamp(new Date(slot.start));
+    const { timestamp } = getZonedTimestamp(new Date(slot.start), timezone);
     return { timestamp, slot };
   });
 
@@ -119,13 +142,29 @@ export const getSuggestedSlots = (
     .map(({ slot }) => slot);
 };
 
-export const getCentralDateString = (date: Date) => dateFormatter.format(date);
+export const getDateString = (date: Date, timezone?: string) => getFormatters(timezone).date.format(date);
 
-export const getCentralTimeString = (date: Date) => timeFormatter24.format(date);
+export const getTimeString = (date: Date, timezone?: string) =>
+  getFormatters(timezone).time24.format(date);
 
-export const getSelectionTimestamp = (dateStr: string, timeStr: string | null) =>
-  timeStr ? getCentralTimestampFromSelection(dateStr, timeStr) : null;
+export const getSelectionTimestamp = (dateStr: string, timeStr: string | null, timezone?: string) =>
+  timeStr ? getZonedTimestampFromSelection(dateStr, timeStr) : null;
 
-export const formatCentralDateLabel = (date: Date) => displayDateFormatter.format(date);
+export const formatDateLabel = (date: Date, timezone?: string) =>
+  getFormatters(timezone).displayDate.format(date);
 
-export const formatCentralTimeLabel = (date: Date) => `${displayTimeFormatter.format(date)} CT`;
+export const formatTimeLabel = (date: Date, timezone?: string) => {
+  const formatter = getFormatters(timezone).displayTimeWithZone;
+  const parts = formatter.formatToParts(date);
+  let timeText = '';
+  let zoneText = '';
+  parts.forEach((part) => {
+    if (part.type === 'timeZoneName') {
+      zoneText = part.value.trim();
+    } else {
+      timeText += part.value;
+    }
+  });
+  const trimmedTime = timeText.trim();
+  return zoneText ? `${trimmedTime} ${zoneText}` : trimmedTime;
+};
